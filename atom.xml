<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在此恭候夷陵老祖的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-19T11:32:45.861Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>joyning</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>话题通信介绍</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:32:45.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信介绍"><a href="#话题通信介绍" class="headerlink" title="话题通信介绍"></a>话题通信介绍</h1><p>1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。</p><p>2.”ros2 node info &#x2F;节点名字”：查看接口定义。（有发布者以及订阅者等相关信息）【发布者下的内容格式：话题：消息接口】</p><p>3.”ros2 topic echo &#x2F;话题名字”：查看话题内容。</p><p>4.”ros2 topic info &#x2F;话题名字”：查看消息接口。</p><p>5.”ros2 interface show 消息接口”：找到消息接口的定义。</p><p>6.”ros2 topic pub &#x2F;话题名字 消息接口 消息接口样本格式的数据填充”:使用话题控制机器人。【使用订阅者话题】</p><p><strong>注</strong>：消息接口样本格式的数据填充可以在”消息接口的定义”处查看，每下一个级别，需要加”{}”，<strong>参数名称后的”:”和自定义参数值之间需要加一个空格</strong>。</p><p>当自定义消息接口或者调用话题接口时常见步骤：</p><ul><li>“ros2 topic list -t”：返回话题及对应的消息接口。</li><li>“ros2 interface show 消息接口”：查消息接口的详细内容 | “ros2 interface proto 消息接口”：显示消息模板。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信介绍&quot;&gt;&lt;a href=&quot;#话题通信介绍&quot; class=&quot;headerlink&quot; title=&quot;话题通信介绍&quot;&gt;&lt;/a&gt;话题通信介绍&lt;/h1&gt;&lt;p&gt;1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。&lt;/p&gt;
&lt;p&gt;2.”ros2 node in</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>git命令基础入门</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_git%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_git%E5%85%A5%E9%97%A8/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:36:14.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git命令基础入门"><a href="#git命令基础入门" class="headerlink" title="git命令基础入门"></a>git命令基础入门</h1><ol><li><strong>克隆仓库</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br><span class="line">cd repo</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建新分支</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new-feature</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>暂存文件：将修改过的文件添加到暂存区</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名</span><br><span class="line">git add . # 添加所有修改的文件</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提交更改：将暂存区的更改提交到本地仓库</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;附加信息&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>拉取最新更改：在推送本地之前，最好从远程仓库拉取最新的更改，以免冲突</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br><span class="line">git pull origin new-feature #添加在新的分支上</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>合并更改：在PR审核过合并后，可以将远程仓库的主分支合并在本地分支</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>删除分支</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d new-feature</span><br><span class="line">git push origin --delete new-feature</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>[接下来是基础但较有用的功能]</strong></li></ol><ul><li>git status：查看仓库当前状态，显示有变更的文件。</li><li>git diff：比较文件的不同，即暂存区和工作区的差异。</li><li>git difftool：使用外部工具比较文件差异。</li><li>git reset：回退版本（即把暂存区的文件撤出）。</li><li>git rm：将文件从暂存区和工作区删除。</li><li>git mv：移动或者重命名工作区文件。</li><li>git  notes：添加注释。</li><li>git checkout：分支切换。|git switch：更清晰的分支切换。</li><li>git restore：恢复或撤销文件更改。</li><li>git show：显示git对象详细信息。</li><li>git log：查看历史提交记录。</li><li>git blame <file>：以列表形式查看指定文件的历史修改记录。</li><li>关于远程操作：<ul><li>git remove：远程仓库操作。</li><li>git fetch：从远程获得代码。</li><li>git pull：下载远程代码并合并。</li><li>git push：上传远程代码并合并。</li><li>git submodule：管理包含其他Git仓库的项目。</li></ul></li></ul><ol start="9"><li><strong>关于git忽略文件的命令</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .gitinore  (在gitinore文件中添加不需要加入缓冲区的文件)</span><br><span class="line">git commit -m &quot;注释&quot;：添加忽略文件；</span><br><span class="line">rm -rf .git ：删除 .git目录。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git命令基础入门&quot;&gt;&lt;a href=&quot;#git命令基础入门&quot; class=&quot;headerlink&quot; title=&quot;git命令基础入门&quot;&gt;&lt;/a&gt;git命令基础入门&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;克隆仓库&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;fi</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>话题通信实战-通过话题发布小说</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98-%E9%80%9A%E8%BF%87%E8%AF%9D%E9%A2%98%E5%8F%91%E5%B8%83%E5%B0%8F%E8%AF%B4/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98-%E9%80%9A%E8%BF%87%E8%AF%9D%E9%A2%98%E5%8F%91%E5%B8%83%E5%B0%8F%E8%AF%B4/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:33:22.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信实战-通过话题发布小说"><a href="#话题通信实战-通过话题发布小说" class="headerlink" title="话题通信实战-通过话题发布小说"></a>话题通信实战-通过话题发布小说</h1><p><strong>需求</strong>：下载小说并通过话题间隔5s发布一行<br><strong>核心问题：</strong></p><pre><code>   1. 怎么下载小说？ 使用requests;   2. 怎么发布？确定名字和接口;   3. 怎么间隔5s发布？Timer定时器。</code></pre><p><strong>1. 定义一个继承rclpy.node的节点</strong></p><p><strong>属性：</strong></p><ul><li>存放小说的队列</li><li>发布者</li><li>定时器</li></ul><p><strong>方法：</strong></p><ul><li>判断队列大小的回调函数</li><li>下载函数</li></ul><p>【<strong>注】：</strong></p><ul><li>创建发布者代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.create_publisher(消息接口,<span class="string">&#x27;自定义话题名字&#x27;</span>,服务质量配置)</span><br></pre></td></tr></table></figure><p>关于服务质量配置是给一个表示队列大小的数字。create_publisher()的返回值为</p><p>一个发布者。</p><ul><li>创建定时器代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.create_timer(时间间隔周期,自定义回调函数) </span><br></pre></td></tr></table></figure><p>create_timer()没有返回值，其会按照传入的间隔周期去调用回调函数。</p><p><strong>2. 完整代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> example_interfaces.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pubNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node_name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(node_name)</span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;<span class="subst">&#123;node_name&#125;</span>,启动！&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.novels_queue = Queue() <span class="comment"># 创建队列</span></span><br><span class="line">        <span class="comment"># 参数依次为：消息接口，话题的名字(自定义)，服务质量配置（给一个表示队列大小的数字;返回值为发布者</span></span><br><span class="line">        <span class="variable language_">self</span>.novel_publisher_ = <span class="variable language_">self</span>.create_publisher(String,<span class="string">&#x27;novel&#x27;</span>,<span class="number">100</span>)  </span><br><span class="line">        <span class="variable language_">self</span>.create_timer(<span class="number">5</span>,<span class="variable language_">self</span>.timer_callback) <span class="comment"># 参数：时间间隔周期，回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断队列大小-&gt;若大于0则从队列里面取一行数据-&gt;组装成消息-&gt;发布消息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>): <span class="comment"># 设置一个回调函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.novels_queue.qsize() &gt; <span class="number">0</span>:</span><br><span class="line">            line = <span class="variable language_">self</span>.novels_queue.get()</span><br><span class="line">            msg = String() <span class="comment"># 组装数据</span></span><br><span class="line">            msg.data = line</span><br><span class="line">            <span class="variable language_">self</span>.novel_publisher_.publish(msg)</span><br><span class="line">            <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;发布了：<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下载：获取请求-&gt;按行分割-&gt;放到队列里面</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self, url</span>):</span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        res.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        text = res.text</span><br><span class="line">        <span class="comment"># text.splitlines() #把下载的内容按行分割</span></span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;下载<span class="subst">&#123;url&#125;</span>,<span class="subst">&#123;<span class="built_in">len</span>(text)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> text.splitlines():</span><br><span class="line">            <span class="variable language_">self</span>.novels_queue.put(line)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node = pubNode(<span class="string">&quot;novel_pub&quot;</span>)</span><br><span class="line">    node.download(<span class="string">&quot;http://0.0.0.0:8000/novel1.txt&quot;</span>)</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure><p>【笔记】：</p><ol><li>example_interface：样例消息类。</li><li>回调函数依赖的成员变量容器要提前初始化。</li><li>“python -m http.server”：在当前目录启动一个HTTP服务器，默认监听端口为8000。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信实战-通过话题发布小说&quot;&gt;&lt;a href=&quot;#话题通信实战-通过话题发布小说&quot; class=&quot;headerlink&quot; title=&quot;话题通信实战-通过话题发布小说&quot;&gt;&lt;/a&gt;话题通信实战-通过话题发布小说&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;需求&lt;/strong</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>话题通信实战_发布控制速度海龟画圈</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E5%8F%91%E5%B8%83%E6%8E%A7%E5%88%B6%E9%80%9F%E5%BA%A6%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9C%88/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E5%8F%91%E5%B8%83%E6%8E%A7%E5%88%B6%E9%80%9F%E5%BA%A6%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9C%88/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:35:02.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信实战-发布控制速度海龟画圈"><a href="#话题通信实战-发布控制速度海龟画圈" class="headerlink" title="话题通信实战_发布控制速度海龟画圈"></a>话题通信实战_发布控制速度海龟画圈</h1><p><strong>核心要求：</strong></p><ol><li>如何让小海龟按着我的指令？话题</li><li>怎么画圆？线速度&#x2F;角速度&#x3D;半径</li><li>发一下就停，如何循环发？定时器</li></ol><p><strong>1.创建类</strong></p><p><strong>属性：</strong></p><ul><li>定时器</li><li>发布者的智能指针</li></ul><p><strong>方法：</strong></p><ul><li>定时发布控制信息的函数</li></ul><p><strong>【注】：</strong></p><ul><li>定时器声明代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rclcpp::Publisher&lt;消息接口&gt;::SharedPtr 发布者实例名;</span><br></pre></td></tr></table></figure><ul><li>定时器创建代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(间隔时长, 回调函数);</span><br></pre></td></tr></table></figure><p>“create_wall_timer()”也称为墙钟函数，它与一般的定时器函数相比使用的不是ros时间，而是系统时间。</p><p><strong>2.完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleCircleNode</span>: <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; <span class="comment">//发布者的智能指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TurtleCircleNode</span><span class="params">(<span class="type">const</span> std::string&amp; node_name)</span>:Node(node_name)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;TurtleCircleNode::timer_callback,<span class="keyword">this</span>));</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line">        msg.linear.x = <span class="number">1.0</span>;</span><br><span class="line">        msg.angular.z = <span class="number">0.5</span>;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleCircleNode&gt;(<span class="string">&quot;turtleCircle&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>学习收获：</strong></p><ol><li>学会了墙钟定时器的声明和创建</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信实战-发布控制速度海龟画圈&quot;&gt;&lt;a href=&quot;#话题通信实战-发布控制速度海龟画圈&quot; class=&quot;headerlink&quot; title=&quot;话题通信实战_发布控制速度海龟画圈&quot;&gt;&lt;/a&gt;话题通信实战_发布控制速度海龟画圈&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;核心</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>话题通信实训-订阅pose实现闭环控制</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%AE%A2%E9%98%85pose%E5%AE%9E%E7%8E%B0%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%AE%A2%E9%98%85pose%E5%AE%9E%E7%8E%B0%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:34:24.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信实训-订阅pose实现闭环控制"><a href="#话题通信实训-订阅pose实现闭环控制" class="headerlink" title="话题通信实训-订阅pose实现闭环控制"></a>话题通信实训-订阅pose实现闭环控制</h1><p><strong>核心任务：</strong><br>       1. 小海龟怎么听我的？发布话题；<br>       2. 小海龟现在在哪里？订阅话题；<br>       3. 怎么根据当前位置和目标位置计算角速度和线速度？两点之间距离-&gt;线速度 当前朝向和目标朝向-&gt;角速度。</p><p><strong>1.定义控制小海龟的类</strong></p><p><strong>属性：</strong></p><ul><li>发布者的智能指针</li><li>订阅者的智能指针</li><li>目标坐标点、比例系数（用于控制运行速度）、最大速度</li></ul><p><strong>方法：</strong></p><ul><li>获取当前位置，并计算新位置发布出去的函数</li></ul><p><strong>【注】：</strong></p><ul><li>不同于python，C++在创建实例前需要声明。以下是发布者和订阅者声明的代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rclcpp::Publisher&lt;消息接口&gt;::SharedPtr publisher_; <span class="comment">//发布者的智能共享指针</span></span><br><span class="line">rclcpp::Subscription&lt;消息接口&gt;::SharedPtr subscriber_; <span class="comment">//订阅者的智能共享指针</span></span><br></pre></td></tr></table></figure><ul><li>发布者和订阅者创建代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;消息接口&gt;(<span class="string">&quot;话题名称&quot;</span>,qos); <span class="comment">//创建发布者</span></span><br><span class="line">subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;消息接口&gt;(<span class="string">&quot;话题名称&quot;</span>,qos,std::<span class="built_in">bind</span>(&amp;TurtleControlNode::on_pose_received,<span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1)); <span class="comment">//创建订阅者</span></span><br></pre></td></tr></table></figure><p>关于回调函数，这里采用的是将成员方法放入函数包装器中（其实用lambda函数更简单）。函数形式：std::bind(&amp;类节点实例化, 对象指针, 参数占位符))。”订阅者的话题名称”要与对应的发布者消息接口对应。</p><p><strong>2.完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleControlNode</span>: <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// rclcpp::TimerBase::SharedPtr timer_;</span></span><br><span class="line">    rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; <span class="comment">//发布者的智能共享指针</span></span><br><span class="line">    rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; <span class="comment">//订阅者的智能共享指针</span></span><br><span class="line">    <span class="type">double</span> target_x_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> target_y_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> k_&#123;<span class="number">1.0</span>&#125;;  <span class="comment">//比例系数【间接控制速度】</span></span><br><span class="line">    <span class="type">double</span> max_speed_&#123;<span class="number">3.0</span>&#125;; <span class="comment">//最大速度</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TurtleControlNode</span><span class="params">(<span class="type">const</span> std::string&amp; node_name)</span>:Node(node_name)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>); <span class="comment">// 这里传入运动控制的消息接口，由其发布控制信息给小海龟</span></span><br><span class="line">        subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">10</span>,std::<span class="built_in">bind</span>(&amp;TurtleControlNode::on_pose_received,<span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1)); </span><br><span class="line">        <span class="comment">// timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleControlNode::timer_callback,this));</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 获取当前位置，并计算新位置发布出去</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pose_received</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose::SharedPtr pose)</span></span>&#123; <span class="comment">//参数：收到数据的共享指针</span></span><br><span class="line">        <span class="comment">// 1.获取当前位置</span></span><br><span class="line">        <span class="keyword">auto</span> current_x = pose-&gt;x;</span><br><span class="line">        <span class="keyword">auto</span> current_y = pose-&gt;y; </span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(),<span class="string">&quot;获取当前位置:x=%f,y=%f&quot;</span>,current_x,current_y);</span><br><span class="line">        <span class="comment">// 2.计算当前海龟位置跟目标位置之间的距离差和角度差。</span></span><br><span class="line">        <span class="keyword">auto</span> distanc  e = std::<span class="built_in">sqrt</span>((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y));</span><br><span class="line">        <span class="comment">// 目标角度和当前角度的差值</span></span><br><span class="line">        <span class="keyword">auto</span> angle = std::<span class="built_in">atan2</span>((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta;</span><br><span class="line">        <span class="comment">// 3.控制策略</span></span><br><span class="line">        <span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line">        <span class="keyword">if</span>(distance&gt;<span class="number">0.1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(angle)&gt;<span class="number">0.2</span>)&#123;</span><br><span class="line">                msg.angular.z = <span class="built_in">fabs</span>(angle);  <span class="comment">//如果角度差大于0.2则改变角度(进行旋转)       </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                msg.linear.x = k_*distance; <span class="comment">//如果角度差不大，则提高速度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//限制最大线速度</span></span><br><span class="line">        <span class="keyword">if</span>(msg.linear.x &gt; max_speed_)&#123;</span><br><span class="line">            msg.linear.x = max_speed_;</span><br><span class="line">        &#125;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleControlNode&gt;(<span class="string">&quot;turtle_control&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>学习收获：</strong></p><ol><li><p>学会了C++版本的发布者和订阅者的声明和创建。</p></li><li><p>在小海龟程序中，可以通过”urtlesim&#x2F;msg&#x2F;pose”接口来获取当前海龟位置，通过”geometry_msgs&#x2F;msg&#x2F;twist”接口来控制海龟的运动。</p></li><li><p>在关键字前添加”explicit”：防止类进行单参数隐式转换。即类的构造函数只有一个参数时，可以通过唯一的参数值来构造该类。</p></li><li><p>c++中的”::”：访问命名空间内的标识符，避免不同命名空间的同名冲突。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信实训-订阅pose实现闭环控制&quot;&gt;&lt;a href=&quot;#话题通信实训-订阅pose实现闭环控制&quot; class=&quot;headerlink&quot; title=&quot;话题通信实训-订阅pose实现闭环控制&quot;&gt;&lt;/a&gt;话题通信实训-订阅pose实现闭环控制&lt;/h1&gt;&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>话题通信实战_自定义实现实时状态信息查询小工具</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:35:39.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信实战-自定义实现实时状态信息查询小工具"><a href="#话题通信实战-自定义实现实时状态信息查询小工具" class="headerlink" title="话题通信实战_自定义实现实时状态信息查询小工具"></a>话题通信实战_自定义实现实时状态信息查询小工具</h1><p><strong>需求：</strong></p><ol><li>通过该工具可以看到系统的实时状态信息，包括记录信息的时间、主机名称、cpu使用率、内存使用率、内存总大小、剩余内存、网络接收数据量和网络发送数据量。</li><li>要有一个简单的界面，可以将系统信息显示出来。</li><li>要能在局域网内其他主机上查看数据。</li></ol><p><strong>分析：</strong></p><ol><li>要能获取系统状态信息–&gt;python库psutils;</li><li>要有一个展示界面–&gt;QT;</li><li>要能共享数据–&gt;ROS2话题。<br>总体架构：&#x2F;sys_status_pub—-&gt;&#x2F;sys_status—&gt;&#x2F;sys_status_display</li></ol><p><strong>步骤：</strong></p><p><strong>1. 自定义通信接口</strong><br>【注】：</p><ul><li><p>builtin_interfaces()：提供时间戳；</p></li><li><p>按照需求编写一个.msg的接口文件。注意：msg文件的命名必须使用驼峰命名法。</p></li><li><p>需要在对应的CMakeList.txt文件中添加rosidl_generate_interfaces()，其为cmake函数，用于将msg消息接口定义文件转化为库或者头文件类。</p><p><strong>具体实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/SystemStatus.msg&quot;</span><br><span class="line">  DEPENDENCIES builtin_interfaces</span><br></pre></td></tr></table></figure></li></ul><p><strong>代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">builtin_interfaces/Time stamp #记录时间戳</span><br><span class="line">string host_name #主机名</span><br><span class="line">float32 memory_percent #主存使用率</span><br><span class="line">float32 cpu_percent #CPU使用率</span><br><span class="line">float32 memory_available #主存剩余率</span><br><span class="line">float64 net_send #网络发送率</span><br><span class="line">float64 net_recv #网络接收率</span><br></pre></td></tr></table></figure><p><strong>2. 系统信息获取和发布</strong><br>【注】：使用psutils和platform两个库主要用于获取信息；其中psutil库可以查询cpu利用率、内存情况和网络输出输入情况等。platform库用于查询主机名字等。</p><p><strong>代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> status_interfaces.msg <span class="keyword">import</span> SystemStatus</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SystemStatusPub</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node_name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(node_name)</span><br><span class="line">        <span class="variable language_">self</span>.status_publisher_ = <span class="variable language_">self</span>.create_publisher(SystemStatus, <span class="string">&#x27;sys_status&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">self</span>.time_ = <span class="variable language_">self</span>.create_timer(<span class="number">1.0</span>, <span class="variable language_">self</span>.timer_callback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        cup_percent = psutil.cpu_percent()</span><br><span class="line">        memory_info = psutil.virtual_memory() <span class="comment"># 查看当前内存情况</span></span><br><span class="line">        net_io_counters = psutil.net_io_counters() <span class="comment"># 查看网络输入输出情况</span></span><br><span class="line">        </span><br><span class="line">        msg = SystemStatus() <span class="comment"># 自定义的通信接口经过一系列操作变成了类</span></span><br><span class="line">        msg.stamp = <span class="variable language_">self</span>.get_clock().now().to_msg() <span class="comment"># 获取当前时间戳并转化为信息</span></span><br><span class="line">        msg.host_name = platform.node() <span class="comment"># 返回主机名字</span></span><br><span class="line">        msg.cpu_percent = cup_percent</span><br><span class="line">        msg.memory_percent = memory_info.percent</span><br><span class="line">        msg.memory_available = memory_info.available /<span class="number">1024</span>/<span class="number">1024</span><span class="comment"># 有效内存</span></span><br><span class="line">        msg.net_send = net_io_counters.packets_sent /<span class="number">1024</span>/<span class="number">1024</span> <span class="comment"># 将字节转换为兆字节</span></span><br><span class="line">        msg.net_recv = net_io_counters.packets_recv /<span class="number">1024</span>/<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;发布相关信息：<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.status_publisher_.publish(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    sys_status_pub = SystemStatusPub(<span class="string">&quot;status_publish&quot;</span>)</span><br><span class="line">    rclpy.spin(sys_status_pub)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure><p><strong>3.订阅数据并用QT显示</strong><br>【注】</p><ul><li>使用new()创建类后需要手动释放内存，只有遇到”delete()”时才会调用析构函数</li><li>使用”类名 创建的类”这种类定义声明的方式使用后不需要手动释放，这种类中的析构函数会自动执行。</li><li>关于类对象的三种创建方法：<br> 第一：Test test1; 栈中分配，由os进行内存分配和管理。<br> 第二：Test test2 &#x3D; Test(); 栈中分配，由os进行内存分配和管理。<br> 第三：Test *test3 &#x3D; new Test(); 堆中分配，由管理者进行内存分配和管理，显式使用delete()释放内存空间。</li><li>“.”:是结构体引用，”-&gt;”:是指针引用。</li></ul><p><strong>代码实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rclcpp/rclcpp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;status_interfaces/msg/system_status.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SystemStatus = status_interfaces::msg::SystemStatus; <span class="comment">// 将包名进行改名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SystemStatusDisplay</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">/*data*/</span></span><br><span class="line">    rclcpp::Subscription&lt;SystemStatus&gt;::SharedPtr subscriber_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QLabel *label_ = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">    <span class="built_in">SystemStatusDisplay</span>():<span class="built_in">Node</span>(<span class="string">&quot;sys_status_display&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 使用lambda函数作为回调函数,接收的函数为共享指针</span></span><br><span class="line">        subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;SystemStatus&gt;(<span class="string">&quot;sys_status&quot;</span>,<span class="number">10</span>,[&amp;](<span class="type">const</span> SystemStatus::SharedPtr msg)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">            label_-&gt;<span class="built_in">setText</span>(<span class="built_in">get_qstr_from_msg</span>(msg));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        label_-&gt;<span class="built_in">setText</span>(<span class="built_in">get_qstr_from_msg</span>(std::<span class="built_in">make_shared</span>&lt;SystemStatus&gt;()));  <span class="comment">// 初始给label传一个空的共享指针，这样有表头没有具体内容。</span></span><br><span class="line">        label_-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">get_qstr_from_msg</span><span class="params">(<span class="type">const</span> SystemStatus::SharedPtr msg)</span></span>&#123;  <span class="comment">// 将获取到的msg内容进行拆分组装</span></span><br><span class="line">        std::stringstream show_str;</span><br><span class="line">        show_str &lt;&lt; <span class="string">&quot;==========状态可视化显示工具============\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;数 据 时 间:\t&quot;</span> &lt;&lt; msg-&gt;stamp.sec &lt;&lt; <span class="string">&quot;\ts\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;主 机 名:\t&quot;</span> &lt;&lt; msg-&gt;host_name &lt;&lt; <span class="string">&quot;\t\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;cpu 利 用 率:\t&quot;</span> &lt;&lt; msg-&gt;cpu_percent &lt;&lt; <span class="string">&quot;\t%\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;内 存 利 用 率:\t&quot;</span> &lt;&lt; msg-&gt;memory_percent &lt;&lt; <span class="string">&quot;\t%\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;剩 余 有 效 内 存:\t&quot;</span> &lt;&lt; msg-&gt;memory_available &lt;&lt; <span class="string">&quot;\tMB\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;网 络 发 送 量:\t&quot;</span> &lt;&lt; msg-&gt;net_send &lt;&lt; <span class="string">&quot;\tMB\n&quot;</span> &lt;&lt;</span><br><span class="line">                <span class="string">&quot;网 络 接 收 量:\t&quot;</span> &lt;&lt; msg-&gt;net_recv &lt;&lt; <span class="string">&quot;\tMB\n&quot;</span> </span><br><span class="line">                &lt;&lt; <span class="string">&quot;=======================================&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QString::<span class="built_in">fromStdString</span>(show_str.<span class="built_in">str</span>());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>; <span class="comment">//类对象的声明</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SystemStatusDisplay&gt;(); <span class="comment">// 创建一个模板为SystemStatusDisplay的共享指针</span></span><br><span class="line">    <span class="function">std::thread <span class="title">spin_thread</span><span class="params">([&amp;]()-&gt;<span class="type">void</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rclcpp::spin(node); <span class="comment">// 为其单独开一个线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    spin_thread.<span class="built_in">detach</span>();</span><br><span class="line">    app.<span class="built_in">exec</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于rclcpp::spin()：会阻塞调用它的线程，直到与它关联的节点被销毁。函数执行期间，它执行以下操作：</p><ul><li>处理回调：调用所有已注册的回调，包括订阅者的消息回调、服务的请求回调、定时器回调。</li><li>事件循环：处理所有ROS通信相关的事件，确保节点能够响应外部消息和服务请求。</li><li>阻塞执行：该函数会一直运行，直到调用其的节点被销毁或者显示地调用rclcpp::shutdown()。</li></ul><p><strong>学习收获：</strong></p><ol><li>如何根据需求自定义.msg文件 ；</li><li>如何获取电脑基本参数信息；</li><li>如何进行字符串流输出。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信实战-自定义实现实时状态信息查询小工具&quot;&gt;&lt;a href=&quot;#话题通信实战-自定义实现实时状态信息查询小工具&quot; class=&quot;headerlink&quot; title=&quot;话题通信实战_自定义实现实时状态信息查询小工具&quot;&gt;&lt;/a&gt;话题通信实战_自定义实现实时状态信</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>话题通信实战-订阅小说并合成语音</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%AE%A2%E9%98%85%E5%B0%8F%E8%AF%B4%E5%B9%B6%E5%90%88%E6%88%90%E8%AF%AD%E9%9F%B3/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%AE%A2%E9%98%85%E5%B0%8F%E8%AF%B4%E5%B9%B6%E5%90%88%E6%88%90%E8%AF%AD%E9%9F%B3/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:33:47.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信实战-订阅小说并合成语音"><a href="#话题通信实战-订阅小说并合成语音" class="headerlink" title="话题通信实战-订阅小说并合成语音"></a>话题通信实战-订阅小说并合成语音</h1><p><strong>核心要求：</strong><br>    1. 怎么订阅？<br>        2. 用什么朗读文本？ Espeak<br>        3. 小说来的快，读得慢怎么办？使用队列</p><p> <strong>1. 定义一个继承rclpy.node的节点类</strong></p><p><strong>属性：</strong></p><ul><li>存放小说的队列</li><li>订阅者</li><li>线程对象</li></ul><p><strong>方法：</strong></p><ul><li>回调函数：用于不断将小说放入队列中。</li><li>线程函数：检测到队列中存在小说就开始朗读。</li><li>下载小说的函数。</li></ul><p><strong>【注】：</strong></p><ul><li>创建订阅者的代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.create_subscription(消息接口, <span class="string">&quot;自定义话题名称&quot;</span>, 回调函数, qos)</span><br></pre></td></tr></table></figure><p>这里的qos就是前文提到的ros2中的通信服务质量，通常是一个数字；函数返回值为一个订阅者实例。还要注意的是，这里的**”自定义话题名称”需要与话题发布者的名称相同**，这样才能订阅到话题。</p><ul><li>创建线程的代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.speech_thread_=threading.Thread(target=线程函数,传给线程函数的<span class="built_in">tuple</span>类型参数) </span><br><span class="line"><span class="variable language_">self</span>.speech_thread_.start() <span class="comment"># 注意python的线程不会自己启动，需要手动开始</span></span><br></pre></td></tr></table></figure><p>“传给线程函数的tuple类型参数”有默认值，可以不传参数。</p><p><strong>2. 完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> espeakng </span><br><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> example_interfaces.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Novel_sub_Node</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node_name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(node_name)</span><br><span class="line">        <span class="variable language_">self</span>.novel_queue = Queue() </span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;<span class="subst">&#123;node_name&#125;</span>,启动！&quot;</span>)</span><br><span class="line">        <span class="comment"># 创建订阅者 参数：信息类型，话题名称（这里一定要与发布者取的名字一致），回调函数,qos</span></span><br><span class="line">        <span class="variable language_">self</span>.novel_sub_ = <span class="variable language_">self</span>.create_subscription(String, <span class="string">&quot;novel&quot;</span>, <span class="variable language_">self</span>.novel_callback, <span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">self</span>.speech_thread_ = threading.Thread(target=<span class="variable language_">self</span>.speak_thread)</span><br><span class="line">        <span class="variable language_">self</span>.speech_thread_.start() <span class="comment"># 注意python的线程不会自己启动，需要手动开始     </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">novel_callback</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="variable language_">self</span>.novel_queue.put(msg.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak_thread</span>(<span class="params">self</span>):</span><br><span class="line">        speaker = espeakng.Speaker()</span><br><span class="line">        speaker.voice = <span class="string">&#x27;zh&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> rclpy.ok(): <span class="comment"># 检测当前ROS上下文是否ok；用于检查ROS2系统的运行状态，通常用于控制循环的执行，确保在系统关闭时能够优雅地退出。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.novel_queue.qsize() &gt; <span class="number">0</span>:</span><br><span class="line">                text = <span class="variable language_">self</span>.novel_queue.get()</span><br><span class="line">                <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;朗读：<span class="subst">&#123;text&#125;</span>&quot;</span>)</span><br><span class="line">                speaker.say(text)</span><br><span class="line">                speaker.wait()</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 当朗读队列为空时</span></span><br><span class="line">                time.sleep(<span class="number">1</span>) <span class="comment"># 让该线程休眠1s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self, url</span>):</span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        res.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        text = res.text</span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;<span class="subst">&#123;url&#125;</span>,<span class="subst">&#123;<span class="built_in">len</span>(text)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node = Novel_sub_Node(<span class="string">&quot;novel_sub&quot;</span>)</span><br><span class="line">    node.download(<span class="string">&quot;http://0.0.0.0:8000/novel1.txt&quot;</span>)</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure><p>学习收获：</p><ol><li><p>认识了python中可以获取文字并朗读的库”espeakng”，使用”espeakng.Speaker()”可以创建一个espeakng实例。</p></li><li><p>学会创建订阅者和线程。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信实战-订阅小说并合成语音&quot;&gt;&lt;a href=&quot;#话题通信实战-订阅小说并合成语音&quot; class=&quot;headerlink&quot; title=&quot;话题通信实战-订阅小说并合成语音&quot;&gt;&lt;/a&gt;话题通信实战-订阅小说并合成语音&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;核心要求：&lt;</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础之环境变量</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:31:08.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux基础之环境变量"><a href="#Linux基础之环境变量" class="headerlink" title="Linux基础之环境变量"></a>Linux基础之环境变量</h1><ol><li><p>ros2 命令就是通过环境变量来寻找功能包的。</p></li><li><p>printenv:可以用来打印环境变量。</p></li><li><p>printenv | grep 筛选内容：可以查找所选取的环境变量。</p></li><li><p>当出现报错“Package xx not found”时，可以检查AMENT_PREFIX_PATH下的lib是否有这个包。</p></li><li><p>AMENT_PREFIX_PATH（路径）的初始值是由默认脚本设置的，该默认脚本位置为:~&#x2F;.bashrc[该文件为隐藏文件]。</p></li><li><p>使用 ls -a可以查看当前目录下的隐藏文件。</p></li><li><p>“source &#x2F;opt&#x2F;ros&#x2F;jazzy&#x2F;setup.bash”语句用于设置环境变量。后面经常会用”source install&#x2F;setup.bash”来将colcon build生成的可执行文件写入Install文件中。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux基础之环境变量&quot;&gt;&lt;a href=&quot;#Linux基础之环境变量&quot; class=&quot;headerlink&quot; title=&quot;Linux基础之环境变量&quot;&gt;&lt;/a&gt;Linux基础之环境变量&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ros2 命令就是通过环境变量来寻找功能包</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>使用功能包组织节点</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E5%8C%85%E7%BB%84%E7%BB%87%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E5%8C%85%E7%BB%84%E7%BB%87%E8%8A%82%E7%82%B9/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:30:31.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用功能包组织节点"><a href="#使用功能包组织节点" class="headerlink" title="使用功能包组织节点"></a>使用功能包组织节点</h1><p>💖基本流程：<strong>命令行创建功能包</strong>-&gt;<strong>在功能包中创建节点</strong>-&gt;<strong>在set.up文件中进行配置</strong>-&gt;<strong>在xml文件中添加依赖信息</strong>（但是如果创建功能包时添加了–dependencies就不需要这步）-&gt;<strong>colcon build进行构建</strong>-&gt;<strong>source install&#x2F;setup.bash</strong>-&gt;<strong>“ros2 run 包名 文件名”运行文件</strong></p><ol><li><p>使用”ros2 pkg create demo_python_pkg –build-type ament_python –license Apache-2.0”可以创建Python功能包，如果不指定build-type，默认为C++类型功能包。【有时候还会有–dependencies等选项】</p></li><li><p>可以在第二级demo_python_pkg目录下新建节点文件。</p></li><li><p>在功能包中注册节点。[即在setup.py文件中添加节点函数在那一层]</p></li><li><p>打开功能包中的xml文件添加依赖信息。[添加“<depend>rclpy</depend>”]</p></li><li><p>“colcon build”:功能包的构建。[支持软链接，会把原来的包复制一份，然后执行复制的那份，即在install里面的python3.12&#x2F;site-packages中最里面那个python_node.py]</p><ul><li>[注]：colcon build一般在工作空间的根目录下进行，可以使用“colcon build-packages-select 包名”对特定的包进行构建。</li></ul></li><li><p>“source install&#x2F;setup.bash”：生成环境变量。[setup.bash脚本用于修改环境变量]</p><ul><li>[补]:”ros2 功能包名 节点名”：运行节点</li></ul></li></ol><p>7.export PYTHONPATH&#x3D;新位置:$PYTHONPATH”:临时修改参数的环境变量。[使用6就可以不用这个方法]</p><p>8.修改环境变量的几种方法：</p><ul><li><p>手动修改，即使用第7点</p></li><li><p>自动修改，即使用第6点</p></li></ul><p>9.如果希望节点能以”ros2 run 包名 节点名”的形式运行，创建类的时候需要对rclcpp&#x2F;rclpy中的Node进行继承。</p><p>关于C++和Python继承Node后，在main函数中的代码主要框架：</p><ul><li>C++：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv)</span></span>&#123;</span><br><span class="line">rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    ...</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(创建的节点);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">rclpy.init()</span><br><span class="line">    ...</span><br><span class="line">    rclpy.spin(节点)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用功能包组织节点&quot;&gt;&lt;a href=&quot;#使用功能包组织节点&quot; class=&quot;headerlink&quot; title=&quot;使用功能包组织节点&quot;&gt;&lt;/a&gt;使用功能包组织节点&lt;/h1&gt;&lt;p&gt;💖基本流程：&lt;strong&gt;命令行创建功能包&lt;/strong&gt;-&amp;gt;&lt;stro</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>编写第一个ROS节点</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAC++%E8%8A%82%E7%82%B9&amp;Python%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAC++%E8%8A%82%E7%82%B9&amp;Python%E8%8A%82%E7%82%B9/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:27:53.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写第一个ROS节点"><a href="#编写第一个ROS节点" class="headerlink" title="编写第一个ROS节点"></a>编写第一个ROS节点</h1><h2 id="ros中编写C-节点"><a href="#ros中编写C-节点" class="headerlink" title="ros中编写C++节点"></a>ros中编写C++节点</h2><ol><li><p>当项目较小时，可以在终端中使用”g++ cpp文件名”，得到一个可执行文件，再使用“.&#x2F;可执行文件名”运行程序。</p></li><li><p>当项目较大时，使用CMake得到生成指令。过程：编写一个CMakeList.txt文件(文件名不能改)-&gt;使用cmake指令转化为Makefile文件-&gt;使用make指令转化为exe文件。</p></li></ol><h2 id="ros中编写Python节点"><a href="#ros中编写Python节点" class="headerlink" title="ros中编写Python节点"></a>ros中编写Python节点</h2><p>1.直接编写后就可以使用”run 文件名”进行运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写第一个ROS节点&quot;&gt;&lt;a href=&quot;#编写第一个ROS节点&quot; class=&quot;headerlink&quot; title=&quot;编写第一个ROS节点&quot;&gt;&lt;/a&gt;编写第一个ROS节点&lt;/h1&gt;&lt;h2 id=&quot;ros中编写C-节点&quot;&gt;&lt;a href=&quot;#ros中编写C-节点&quot;</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>多线程与回调函数</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0(Python%E7%89%88)/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0(Python%E7%89%88)/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:29:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程与回调函数"><a href="#多线程与回调函数" class="headerlink" title="多线程与回调函数"></a>多线程与回调函数</h1><p>┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w</p><ol><li><p>回调函数：把统计函数当作参数传递给下载函数，下载完成自己第一时间调用。</p></li><li><p>“threading.get_ident()”：可以得到线程编号(python中)；”this_thread.get_id()”：可以得到线程编号(c++中)。</p></li><li><p>“echo “文字” “&gt; 文件名,可生成对应文件,并将文字写入。</p></li><li><p>“python3 -m http.server”：启动python3的内置服务器。</p></li><li><p>一个程序默认是在一个线程中完成的，如果需要多个线程并行，则需要使用thread。  </p></li><li><p>与python中的多线程不同，c++中的线程一旦创建就立刻运行，并阻塞当前进程，所以需要用”thread.detach()”将其与当前进程进行分离。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程与回调函数&quot;&gt;&lt;a href=&quot;#多线程与回调函数&quot; class=&quot;headerlink&quot; title=&quot;多线程与回调函数&quot;&gt;&lt;/a&gt;多线程与回调函数&lt;/h1&gt;&lt;p&gt;┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;回调函数：把统计</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>有用的C++特性</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%B8%B8%E7%94%A8%E7%9A%84C++%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%B8%B8%E7%94%A8%E7%9A%84C++%E7%89%B9%E6%80%A7/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:30:02.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有用的C-特性"><a href="#有用的C-特性" class="headerlink" title="有用的C++特性"></a>有用的C++特性</h1><p>1.auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名字”)  node的类型是自动推导的。</p><p>2.智能指针&#x2F;共享指针:专治占着内存不使用的程序。</p><ul><li>指针.use_count()：得到指针引用次数。</li><li>指针.get():得到指向的内存地址。</li><li>指针-&gt;c_str():得到指针指向内存地址数据。</li><li>对象.函数(参数):直接通过对象访问成员    指针-&gt;函数(参数):通过指向对象的指针访问成员。</li><li>具体使用哪一个要看“访问者是对象本身，还是指向对象的指针”。</li><li>CPP的”colcon build”会添加到环境变量，所以没有source也能运行。(但最好还是build一下好)</li></ul><p>💥3.lambda表达式(放在函数里面用)<br>即换个语法写函数：<a href="parameters">capture list</a>-(parameter list)&gt;return type{function body}</p><ul><li>注:常用[&amp;](输入列表)-&gt;void{函数体}，其中void表示不返回</li><li>捕获列表可以为空，也可以使用默认捕获模式&amp;或者&#x3D;表示按引用或者值捕获所有外部变量。</li></ul><p>💥4.函数包装器：统一自由函数、成员方法和Lambda函数</p><ul><li>对于自由函数：std::function&lt;函数返回值(函数传入参数)&gt; 给该函数一个新名字 &#x3D; 原自由函数名;</li><li>对于lambda函数: 同自由函数;</li><li>对于成员方法【较复杂】：</li></ul><p>std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应函数的指针&#x2F;模板地址,对象的指针,参数数量占位符);</p><p>or</p><ul><li><p><input checked="" disabled="" type="checkbox"> std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应创造的对象,类中要调用的方法,参数数量占位符);</p></li><li><p>注：关于绑定bind很好解决了调用成员函数必须要先创造一个成员函数的问题，它直接绑定了一个对象。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有用的C-特性&quot;&gt;&lt;a href=&quot;#有用的C-特性&quot; class=&quot;headerlink&quot; title=&quot;有用的C++特性&quot;&gt;&lt;/a&gt;有用的C++特性&lt;/h1&gt;&lt;p&gt;1.auto 节点名字 &amp;#x3D; std::make_shared&amp;lt;类名&amp;gt;(“节</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>补充一些基础编程知识</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:30:07.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补充一些基础编程知识"><a href="#补充一些基础编程知识" class="headerlink" title="补充一些基础编程知识"></a>补充一些基础编程知识</h1><p>1.每次修改代码文件后，需要重新colcon build构建再运行。</p><p>2.面向对象编程都可以创建类，类是对事物的封装。</p><p>3.对于继承：<br><strong>python：</strong></p><ul><li>“from 父类所在文件 import 父类”;</li><li>class 子类(父类):  ;</li><li>“.super().init(父类构造需要的参数)” :调用父类的init方法。</li></ul><p><strong>c++:</strong></p><ul><li>class 子类 : public 父类 【例如】：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class PersonNode : public rclcpp::Node</span><br></pre></td></tr></table></figure><p>-<br>  子类(const 参数类型 &amp;参数1,…):父类(const 参数类型 &amp;父类构造所需参数);</p><ul><li><strong>注：</strong>创建共享指针，”auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名”)”</li></ul><p><strong>注：</strong></p><ul><li><p>使用共享指针需要头文件<memory></p></li><li><p>RCLCPP_INFO(节点名字-&gt;get_logger(),”要打印出来的文字信息”); 注意这个函数的参数形式。</p></li><li><p>传入时格式为”string”,输出时为”%s”,则可以在输出时加上”.c_str()进行强制转换”。【c_str():将str类型转换为c语言格式的字符串】</p></li><li><p>CPP文件中，有时候构造函数时会在传入参数前加上”const”（加在类型前）和”&amp;”（加在变量名前），加上前者是希望用户不要对传入的数据进行修改，加上后者(称为拷贝指针)是为了避免不必要的数据拷贝，以提高运行效率。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;补充一些基础编程知识&quot;&gt;&lt;a href=&quot;#补充一些基础编程知识&quot; class=&quot;headerlink&quot; title=&quot;补充一些基础编程知识&quot;&gt;&lt;/a&gt;补充一些基础编程知识&lt;/h1&gt;&lt;p&gt;1.每次修改代码文件后，需要重新colcon build构建再运行。&lt;/p&gt;</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/%E8%AE%B0%E5%BD%95%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E5%B0%8F%E9%97%AE%E9%A2%98/%E5%AE%9E%E7%8E%B0Ubuntu%E4%B8%8E%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/"/>
    <id>http://example.com/2025/09/18/%E8%AE%B0%E5%BD%95%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E5%B0%8F%E9%97%AE%E9%A2%98/%E5%AE%9E%E7%8E%B0Ubuntu%E4%B8%8E%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/</id>
    <published>2025-09-18T10:43:02.063Z</published>
    <updated>2025-09-18T11:07:24.442Z</updated>
    
    <content type="html"><![CDATA[<p>1.方法一：虚拟机顶部工具栏点击”虚拟机设置”-&gt;”选项”-&gt;”客户机隔离”勾选，再次启动Ubuntu。</p><p>2.方法二：使用Ubuntu命令</p><p>在终端中依次运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su- //进入管理员模式</span><br><span class="line">sudo apt-get install open-vm-tools open-vm-tools-desktop //安装命令</span><br><span class="line">vmware-user //开启服务</span><br></pre></td></tr></table></figure><p>最后，重启虚拟机就可以实现跨平台复制粘贴。</p><p>3.方法三：（永久开启该服务）</p><ul><li>编写service配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># /etc/systemd/system/vmware-user.service </span><br><span class="line">[Unit] </span><br><span class="line">Description=开机启动一次vmware-user </span><br><span class="line">After=network.target </span><br><span class="line"></span><br><span class="line">[Service] </span><br><span class="line">Type=oneshot </span><br><span class="line">ExecStart=vmware-user </span><br><span class="line"></span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>重新加载systemd配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><ul><li>设置开机自启动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vmware-user</span><br></pre></td></tr></table></figure><p>重启虚拟机后基本成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.方法一：虚拟机顶部工具栏点击”虚拟机设置”-&amp;gt;”选项”-&amp;gt;”客户机隔离”勾选，再次启动Ubuntu。&lt;/p&gt;
&lt;p&gt;2.方法二：使用Ubuntu命令&lt;/p&gt;
&lt;p&gt;在终端中依次运行：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_git%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_git%E8%BF%9B%E9%98%B6/</id>
    <published>2025-09-18T10:26:06.144Z</published>
    <updated>2025-09-18T10:26:06.144Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</id>
    <published>2025-09-18T10:22:22.046Z</published>
    <updated>2025-09-18T10:22:22.046Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9F%A5%E8%AF%A2/</id>
    <published>2025-09-18T10:22:22.046Z</published>
    <updated>2025-09-18T10:24:33.027Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%8A%A8%E6%80%81TF%E7%9A%84%E5%8F%91%E5%B8%83/"/>
    <id>http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%8A%A8%E6%80%81TF%E7%9A%84%E5%8F%91%E5%B8%83/</id>
    <published>2025-09-18T10:22:22.046Z</published>
    <updated>2025-09-18T10:24:20.676Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7rqt&amp;Rviz/"/>
    <id>http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7rqt&amp;Rviz/</id>
    <published>2025-09-18T10:22:22.046Z</published>
    <updated>2025-09-18T10:24:57.508Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7ros2%20bag/"/>
    <id>http://example.com/2025/09/18/ros2/%E5%B7%A5%E5%85%B7/ros_%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7ros2%20bag/</id>
    <published>2025-09-18T10:22:22.046Z</published>
    <updated>2025-09-18T10:25:31.976Z</updated>
    
    
    
    
    
  </entry>
  
</feed>

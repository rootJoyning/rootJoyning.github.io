<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在此恭候夷陵老祖的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-21T08:50:52.370Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>joyning</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务通信介绍</title>
    <link href="http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T08:50:52.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务通信介绍"><a href="#服务通信介绍" class="headerlink" title="服务通信介绍"></a>服务通信介绍</h1><p>1.”ros2 service list -t”：查看ros2的服务列表，返回内容具体格式:服务名称 消息接口&#x2F;服务接口类型。</p><p>2.”ros2 interface show 消息接口”：查看消息接口具体定义（消息填充）。</p><p>3.”ros2 service call 服务名称 消息接口 ‘{消息接口具体填充}’：调用具体服务。<br>    【注】：消息接口的具体填充，”{参数1: 数值,参数2: 数值,…}”。冒号数值间有一个空格。<br>4.可以使用ros2中的可视化工具rqt选取服务。（plugins-&gt;services-&gt;service caller中可以配置）。</p><p>5.参数被视为节点的设置，是基于服务通信实现的。</p><p>6.”ros2 param list”：查看ros2的参数列表。</p><p>7.”ros2 param describe 包名 参数名称”：查看参数的具体信息。</p><p>8.”ros2 param get 包名 参数名称”：获得参数的值。</p><p>9.”ros2 param set 包名 修改的参数名称 修改数值”：修改参数的值。</p><p>10.”ros2 param dump 包名 &gt; 配置文件(.yaml)”：将包现在的参数写入配置文件。</p><p>11.”ros2 run 包名 节点名 –ros-args –params-file 配置文件”：运行节点时就根据配置文件将节点配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务通信介绍&quot;&gt;&lt;a href=&quot;#服务通信介绍&quot; class=&quot;headerlink&quot; title=&quot;服务通信介绍&quot;&gt;&lt;/a&gt;服务通信介绍&lt;/h1&gt;&lt;p&gt;1.”ros2 service list -t”：查看ros2的服务列表，返回内容具体格式:服务名称 消息接</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Service_communication" scheme="http://example.com/tags/Service-communication/"/>
    
  </entry>
  
  <entry>
    <title>ros_使用launch启动多个节点（基础版）</title>
    <link href="http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_%E4%BD%BF%E7%94%A8launch%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_%E4%BD%BF%E7%94%A8launch%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T12:33:25.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用launch启动多个节点"><a href="#使用launch启动多个节点" class="headerlink" title="使用launch启动多个节点"></a>使用launch启动多个节点</h1><p><strong>1.使用launch启动多个节点：</strong></p><ul><li>“generate_launch_description()”：产生launch描述【注意该函数名字是固定的】；其返回值也是固定的，返回actions动作(是一个数组)。</li><li>关于c++版本将launch文件写到install&#x2F;lib下，使用”install(DIRECTORY launch DESTINATION share&#x2F;${PROJECT_NAME})”。【更方便】</li><li>关于python版本将launch文件写到install&#x2F;lib下，使用” ‘share&#x2F;‘+package_name+’&#x2F;launch’,glob(‘launch&#x2F;*.launch.py’)”<br> [注意]：上述操作需要引入globe包[from glob import glob]。</li><li>python中的glob函数：用于查找符合特定规则的文件，需要传入指定匹配的路径字符串，返回值为当前目录下满足条件的文件(不包含子目录下的)。</li><li>launch脚本的启动，”ros2 launch 包名 launch文件名”。</li><li>“source 路径”：将路径加入到系统环境变量中，相当于激活该区域。</li></ul><p><strong>2.使用launch传递参数：</strong></p><ul><li>声明一个launch参数：launch.actions.DeclareLaunchArgument(‘参数名字’,default_value&#x3D;”默认参数值”,(可选)description&#x3D;”给该参数一个备注”)</li><li>把launch的参数手动传给某节点：<br>    “launch.substitutions.LaunchConfiguration(‘参数名称’,”默认参数值”)”:对参数值进行替换。<br>    在需要传入参数的节点处添加属性parameters&#x3D;[{节点参数名:launch.substitutions.LaunchConfiguration(‘参数名称’,default&#x3D;”默认参数值”)}]。<br>3.运行的时候可以使用：ros2 launch 包名 launch文件名 自定义参数名:&#x3D;参数值。</li></ul><p><strong>3.launch三大组件</strong>(4.6.3)<br>    动作：一个节点、一句打印、一段终端指令、另一个终端文件等<br>    替换：使用launch的参数替换节点的参数值(未学)<br>    条件：可以决定哪些节点启动，哪些不启动，相当于if(未学)</p><p><strong>代码实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">import</span> launch_ros</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="comment"># 生成launch描述【注意该函数名字是固定的】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.声明一个launch函数</span></span><br><span class="line">    action_declare_arg_background_g = launch.actions.DeclareLaunchArgument(<span class="string">&#x27;bg_param&#x27;</span>, default_value=<span class="string">&quot;150&quot;</span>)</span><br><span class="line">   </span><br><span class="line">    action_node_turtle_client = launch_ros.actions.Node( <span class="comment"># 传入包，可执行文件和日志输出的位置</span></span><br><span class="line">        package = <span class="string">&#x27;demo_cpp_service&#x27;</span>,</span><br><span class="line">        executable = <span class="string">&#x27;turtle_client&#x27;</span>,</span><br><span class="line">        output = <span class="string">&#x27;screen&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    action_node_turtle_control = launch_ros.actions.Node( <span class="comment"># 传入包，可执行文件和日志输出的位置</span></span><br><span class="line">        package = <span class="string">&#x27;demo_cpp_service&#x27;</span>,</span><br><span class="line">        executable = <span class="string">&#x27;turtle_control&#x27;</span>,</span><br><span class="line">        output = <span class="string">&#x27;screen&#x27;</span></span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.把launch的参数手动传递给某个参数</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;产生launch描述&#x27;&#x27;&#x27;</span></span><br><span class="line">    action_node_turtle_node = launch_ros.actions.Node( <span class="comment"># 传入包，可执行文件和日志输出的位置</span></span><br><span class="line">        package = <span class="string">&#x27;turtlesim&#x27;</span>,</span><br><span class="line">        executable = <span class="string">&#x27;turtlesim_node&#x27;</span>,</span><br><span class="line">        parameters =[&#123;<span class="string">&#x27;background_g&#x27;</span>:launch.substitutions.LaunchConfiguration(<span class="string">&#x27;bg_param&#x27;</span>,default=<span class="string">&quot;150&quot;</span>)&#125;],</span><br><span class="line">        output = <span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">     )</span><br><span class="line">    <span class="keyword">return</span> launch.LaunchDescription([</span><br><span class="line">        action_node_turtle_client,</span><br><span class="line">        action_node_turtle_control,</span><br><span class="line">        action_node_turtle_node,</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>【补充】：</p><ul><li>DeclareLaunchArgument(参数名称,default_name&#x3D;”默认取值”,description&#x3D;”参数的描述”)：声明launch文件可以修改的参数。【声明一个参数】</li><li>LaunchConfiguration(“在DeclareLaunchArgument中声明过的动态参数名称”)：在启动文件中用于动态配置参数、节点选项等的一种机制。可以在运行或者启动文件时灵活调整参数。一般与”DeclareLaunchArgument()”配套使用。【引用一个参数】</li></ul><p><strong>启动两个小海龟模拟器的例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">import</span> launch_ros</span><br><span class="line"><span class="keyword">from</span> ament_index_python.packages <span class="keyword">import</span> get_package_share_directory</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">太诡异了这个代码OTZ</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>(): </span><br><span class="line">    <span class="comment"># 这个动作实际上就是启动两个小海龟模拟器</span></span><br><span class="line">    <span class="comment"># 动作1：启动其它launch</span></span><br><span class="line">    action_launch_path = [get_package_share_directory(<span class="string">&#x27;turtlesim&#x27;</span>),<span class="string">&#x27;/launch/&#x27;</span>,<span class="string">&#x27;multisim.launch.py&#x27;</span>]</span><br><span class="line">    <span class="comment"># 因为该launch文件在不同场景均需要启动，故可将其包含到不同的父launch文件中。</span></span><br><span class="line">    action_include_launch = launch.actions.IncludeLaunchDescription(launch.launch_description_sources.PythonLaunchDescriptionSource(action_launch_path))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 动作2：打印这个路径</span></span><br><span class="line">    action_launch_info = launch.actions.LogInfo(msg=<span class="built_in">str</span>(action_launch_path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动作3：执行进程，即执行一个命令行</span></span><br><span class="line">    action_topic_list = launch.actions.ExecuteProcess(cmd=[<span class="string">&#x27;ros2&#x27;</span>,<span class="string">&#x27;topic&#x27;</span>,<span class="string">&#x27;list&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动作4：组织动作成组，把多个动作放一个组</span></span><br><span class="line">    action_group = launch.actions.GroupAction([</span><br><span class="line">        <span class="comment"># 动作5：定时器</span></span><br><span class="line">        launch.actions.TimerAction(period=<span class="number">2.0</span>,actions=[action_include_launch]),</span><br><span class="line">        launch.actions.TimerAction(period=<span class="number">4.0</span>,actions=[action_topic_list])</span><br><span class="line">    ])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> launch.LaunchDescription([</span><br><span class="line">        <span class="comment"># 执行顺序：打印路径--&gt;(执行动作组中的)启动两个小海龟模拟器--&gt;(执行动作组中的)执行一个命令行</span></span><br><span class="line">        action_launch_info,</span><br><span class="line">        action_group</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>IncludeLaunchDescription()：</p><ul><li>主要作用是包含其他Launch文件。</li><li>它是一个动作(launch.actions模块中的类)。</li></ul><p>PythonLaunchDescriptionSource()：</p><ul><li>是IncludeLaunchDescription()一个来源类，它指定所包含的launch文件是python格式的。</li><li>其它来源还包括XML和YAML格式。</li></ul><p>上述两个函数一般结合使用：IncludeLaunchDescription(PythonLaunchDescriptionSource(…))，其应用场景有：</p><ul><li>模块化启动：在大型项目中，可将不同功能节点拆分到多个launch文件中。使用IncludeLaunchDescription()将这些launch文件组合在一起。</li><li>复用已有launch文件：若某个launch文件在多个场景中均需要启动，可以将其包含在不同的父launch文件中。</li><li>传递函数：父launch文件通过launch_argument传递给子launch文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用launch启动多个节点&quot;&gt;&lt;a href=&quot;#使用launch启动多个节点&quot; class=&quot;headerlink&quot; title=&quot;使用launch启动多个节点&quot;&gt;&lt;/a&gt;使用launch启动多个节点&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1.使用launch启动多个</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Service_communication" scheme="http://example.com/tags/Service-communication/"/>
    
  </entry>
  
  <entry>
    <title>ros_C++服务通信实现小海龟巡逻</title>
    <link href="http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_C++%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%B0%8F%E6%B5%B7%E9%BE%9F%E5%B7%A1%E9%80%BB/"/>
    <id>http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_C++%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%B0%8F%E6%B5%B7%E9%BE%9F%E5%B7%A1%E9%80%BB/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T12:13:33.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-服务通信实现小海龟巡逻"><a href="#C-服务通信实现小海龟巡逻" class="headerlink" title="C++服务通信实现小海龟巡逻"></a>C++服务通信实现小海龟巡逻</h1><p><strong>需求</strong>：让小海龟在模拟器中随机游走进行巡逻。<br><strong>分析：</strong></p><ul><li>怎么让小海龟动态接收目标点？服务</li><li>用什么接口？自定义的</li><li>随机游走的实现？客户端来产生随机点，请求巡逻服务</li></ul><p><strong>整体框架图：</strong><br>客户端生成目标点，请求巡逻—（服务）–&gt;服务端规划路线，驾驶小海龟到达目标点—（话题）–&gt;小海龟<br>【注】：一般编写程序，可以先把服务端程序完成。</p><p><strong>注意：</strong></p><ul><li>自定义的接口上半部分请求是针对客户端；下半部分响应是针对服务端的。</li><li>srv接口文件对于未赋值变量要求小写，已赋值变量要求大写。【大概率是这样的了】</li><li>创建服务时传入的回调函数一般使用lambda表达式，比较方便。其中lambda表达式传入参数有两请求和响应两部分，</li><li>请求可以设置为const常量，而响应一般还需要进行后续修改故不设置成”const”。</li><li>python中的回调函数需要有返回值，因为python中传入的值是通过拷贝实现的；而c++中的回调函数不需要返回值，因为c++中传入的是指针。</li></ul><p><strong>1.自定义服务接口文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float32 target_x</span><br><span class="line">float32 target_y</span><br><span class="line">---</span><br><span class="line">int8 SUCCESS = 1</span><br><span class="line">int8 FAIL = 0</span><br><span class="line">int8 result # 结果在SUCCESS和FAIL中取其一</span><br></pre></td></tr></table></figure><p>srv文件的上半部分为请求参数，下半部分为响应(返回)参数。</p><p><strong>2.客户端实现步骤：</strong></p><ul><li>创建客户端和定时器;</li><li>定时产生目标点并请求服务端巡逻。</li></ul><p><strong>实现代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chapt4_interfaces/srv/patrol.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类重命名</span></span><br><span class="line"><span class="keyword">using</span> Patrol = chapt4_interfaces::srv::Patrol;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals; <span class="comment">// 使用命名空间std::chrono_literals[可以使用10s,100ms来表示时间]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleClient</span>: <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明定时器</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    <span class="comment">// 声明客户端</span></span><br><span class="line">    rclcpp::Client&lt;Patrol&gt;::SharedPtr turtle_client;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TurtleClient</span>():<span class="built_in">Node</span>(<span class="string">&quot;turtle_client&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 初始化随机种子</span></span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        turtle_client = <span class="keyword">this</span>-&gt;<span class="built_in">create_client</span>&lt;Patrol&gt;(<span class="string">&quot;Patrol&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">10</span>s, [&amp;]()-&gt;<span class="type">void</span>&#123;</span><br><span class="line">            <span class="comment">// 1.检测服务端是否上线</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="keyword">this</span>-&gt;turtle_client-&gt;<span class="built_in">wait_for_service</span>(<span class="number">1</span>s))&#123; <span class="comment">// 服务端没有上线</span></span><br><span class="line">                <span class="keyword">if</span>(!rclcpp::<span class="built_in">ok</span>())&#123; <span class="comment">// rclcpp没有准备好</span></span><br><span class="line">                    <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;等待服务上线中,rclcpp挂了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;等待服务上线中&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.构造请求对象</span></span><br><span class="line">            <span class="keyword">auto</span> request = std::<span class="built_in">make_shared</span>&lt;Patrol::Request&gt;();</span><br><span class="line">            request-&gt;target_x = <span class="built_in">rand</span>()%<span class="number">15</span>;</span><br><span class="line">            request-&gt;target_y = <span class="built_in">rand</span>()%<span class="number">15</span>;</span><br><span class="line">            <span class="comment">// 3.发送请求</span></span><br><span class="line">            <span class="comment">// 发送异步请求[请求 回调函数]</span></span><br><span class="line">            <span class="keyword">this</span> -&gt; turtle_client -&gt; <span class="built_in">async_send_request</span>(request, [&amp;](rclcpp::Client&lt;Patrol&gt;::SharedFuture result_future)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> response = result_future.<span class="built_in">get</span>();</span><br><span class="line">                <span class="keyword">if</span>(response-&gt;result==Patrol::Response::SUCCESS)&#123;</span><br><span class="line">                    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;请求成功！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">if</span>(response-&gt;result==Patrol::Response::FAIL)&#123;</span><br><span class="line">                    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;请求失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleClient&gt;();</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.服务端实现步骤：</strong></p><ul><li><p>定义基于Patrol类的服务共享指针、发布者的共享指针、订阅者的共享指针；</p></li><li><p>获取当前位置，并计算新位置发布出去。</p><p><strong>代码实现：</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chapt4_interfaces/srv/patrol.hpp&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">服务端编写：使小海龟到达具体点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类重命名</span></span><br><span class="line"><span class="keyword">using</span> Patrol = chapt4_interfaces::srv::Patrol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleControlNode</span>: <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::Service&lt;Patrol&gt;::SharedPtr patrol_service; <span class="comment">// 定义基于Patrol类的服务共享指针</span></span><br><span class="line">    rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; <span class="comment">//发布者的智能共享指针</span></span><br><span class="line">    rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; <span class="comment">//订阅者的智能共享指针</span></span><br><span class="line">    <span class="type">double</span> target_x_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> target_y_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> k_&#123;<span class="number">1.0</span>&#125;;  <span class="comment">//比例系数【间接控制速度】</span></span><br><span class="line">    <span class="type">double</span> max_speed_&#123;<span class="number">3.0</span>&#125;; <span class="comment">//最大速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TurtleControlNode</span><span class="params">(<span class="type">const</span> std::string&amp; node_name)</span>:Node(node_name)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">10</span>,std::<span class="built_in">bind</span>(&amp;TurtleControlNode::on_pose_received,<span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1)); </span><br><span class="line">        <span class="comment">// 服务智能指针的构造[服务名，回调函数(用lambda表达式实现)]</span></span><br><span class="line">        patrol_service = <span class="keyword">this</span>-&gt;<span class="built_in">create_service</span>&lt;Patrol&gt;(<span class="string">&quot;Patrol&quot;</span>,[&amp;](<span class="type">const</span> Patrol::Request::SharedPtr request, Patrol::Response::SharedPtr response)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">            <span class="comment">// 进行请求值合法性判断</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="number">0</span> &lt; request-&gt;target_x &amp;&amp; request-&gt;target_x &lt; <span class="number">12.0</span>)&amp;&amp;(<span class="number">0</span> &lt; request-&gt;target_y &amp;&amp; request-&gt;target_y &lt; <span class="number">12.0</span>))&#123;</span><br><span class="line">                target_x_ = request-&gt;target_x;</span><br><span class="line">                target_y_ = request-&gt;target_y;</span><br><span class="line">                response-&gt;result = Patrol::Response::SUCCESS;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                response-&gt;result = Patrol::Response::FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 作为服务的参数有两请求和响应两部分</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前位置，并计算新位置发布出去</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pose_received</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose::SharedPtr pose)</span></span>&#123; <span class="comment">//参数：收到数据的共享指针</span></span><br><span class="line">        <span class="comment">// 1.获取当前位置</span></span><br><span class="line">        <span class="keyword">auto</span> current_x = pose-&gt;x;</span><br><span class="line">        <span class="keyword">auto</span> current_y = pose-&gt;y; </span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(),<span class="string">&quot;获取当前位置:x=%f,y=%f&quot;</span>,current_x,current_y);</span><br><span class="line">        <span class="comment">// 2.计算当前海龟位置跟目标位置之间的距离差和角度差。</span></span><br><span class="line">        <span class="keyword">auto</span> distance = std::<span class="built_in">sqrt</span>((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y));</span><br><span class="line">        <span class="comment">// 目标角度和当前角度的差值</span></span><br><span class="line">        <span class="keyword">auto</span> angle = std::<span class="built_in">atan2</span>((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta;</span><br><span class="line">        <span class="comment">// 3.控制策略</span></span><br><span class="line">        <span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line">        <span class="keyword">if</span>(distance&gt;<span class="number">0.1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(angle)&gt;<span class="number">0.2</span>)&#123;</span><br><span class="line">                msg.angular.z = <span class="built_in">fabs</span>(angle);  <span class="comment">//如果角度差大于0.2则改变角度(进行旋转)        </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                msg.linear.x = k_*distance; <span class="comment">//如果角度差不大，则提高速度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//限制最大线速度</span></span><br><span class="line">        <span class="keyword">if</span>(msg.linear.x &gt; max_speed_)&#123;</span><br><span class="line">            msg.linear.x = max_speed_;</span><br><span class="line">        &#125;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleControlNode&gt;(<span class="string">&quot;turtle_control&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是需要回顾一下发布者（服务端）、订阅者（客户端）和服务的创建（声明就不讲了）。</p><ul><li>发布者的创建：</li></ul><p>create_publisher&lt;模板类&gt;():</p><p>参数列表：服务名称、qos；</p><p>返回值：发布者实例。</p><ul><li>订阅者的创建：</li></ul><p>create_subscription&lt;模板类&gt;():</p><p>参数列表：服务名称（这里应该与对应发布者中的服务名称对应）、qos、回调函数。</p><p>返回值：订阅者实例。</p><ul><li>服务的创建：</li></ul><p>create_service&lt;模板类&gt;():</p><p>参数列表：服务名称、回调函数。</p><p>返回值：服务实例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-服务通信实现小海龟巡逻&quot;&gt;&lt;a href=&quot;#C-服务通信实现小海龟巡逻&quot; class=&quot;headerlink&quot; title=&quot;C++服务通信实现小海龟巡逻&quot;&gt;&lt;/a&gt;C++服务通信实现小海龟巡逻&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：让小海龟</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Service_communication" scheme="http://example.com/tags/Service-communication/"/>
    
  </entry>
  
  <entry>
    <title>ros_服务通信实训_人脸识别</title>
    <link href="http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E5%AE%9E%E8%AE%AD_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <id>http://example.com/2025/09/21/ros2/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1/ros_%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E5%AE%9E%E8%AE%AD_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T13:29:51.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务通信实训-人脸识别"><a href="#服务通信实训-人脸识别" class="headerlink" title="服务通信实训_人脸识别"></a>服务通信实训_人脸识别</h1><p><strong>需求</strong>：使用python实现，创建一个人脸检测服务，提供图像，返回人脸数量位置信息。</p><p><strong>难点分析：</strong><br>    人脸怎么识别？使用face_recognition<br>    图片数据和结果怎么传递？使用服务通信<br>    没有合适的消息接口？自定义一个 【分为请求和响应两部分】</p><p><strong>1.自定义服务接口</strong></p><ul><li>消息接口文件命名不要使用”_”，而应该使用<strong>驼峰命名法</strong>；</li><li>“<strong>os.path.join(路径1,路经2)</strong>“：将两个路径拼接起来，会自动加上”&#x2F;“；</li><li>使用”CV BRIDGE”将opencv下图片格式与ROS消息接口中的sensor_msgs&#x2F;Image文件互相转化；</li></ul><p><strong>Facedetectors.srv文件的编写：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sensor_msgs/Image image</span><br><span class="line">---</span><br><span class="line">int16 number</span><br><span class="line">float32 use_time </span><br><span class="line">int32[] top</span><br><span class="line">int32[] right</span><br><span class="line">int32[] bottom</span><br><span class="line">int32[] left</span><br></pre></td></tr></table></figure><p><strong>2.服务实现步骤：</strong></p><ul><li>创建服务，接受请求Request；</li><li>调用face_recognition来识别人脸;</li><li>处理响应结果合成Response返回。</li></ul><p><strong>服务器代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> chapt4_interfaces.srv <span class="keyword">import</span> Facedetector</span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">from</span> ament_index_python.packages <span class="keyword">import</span> get_package_share_directory <span class="comment"># 获得功能包share目录绝对路径</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> cv_bridge <span class="keyword">import</span> CvBridge</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">人脸识别服务端</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FaceService</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;face_service&#x27;</span>)</span><br><span class="line">        <span class="comment"># 创建服务 参数：(服务类型，服务名称，回调函数)</span></span><br><span class="line">        <span class="variable language_">self</span>.service = <span class="variable language_">self</span>.create_service(Facedetector,<span class="string">&#x27;face_detect&#x27;</span>, <span class="variable language_">self</span>.detect_face_callback)</span><br><span class="line">        <span class="variable language_">self</span>.cvbridge = CvBridge() <span class="comment"># 主要用于ROS图像消息和opencv图像之间进行转换</span></span><br><span class="line">        <span class="variable language_">self</span>.declare_parameter(<span class="string">&#x27;upsample_flu&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">self</span>.declare_parameter(<span class="string">&#x27;model&#x27;</span>,<span class="string">&#x27;hog&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.default_path = os.path.join(get_package_share_directory(<span class="string">&quot;demo_python_service&quot;</span>),<span class="string">&quot;resource/test/.png&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.upsample_flu = <span class="variable language_">self</span>.get_parameter(<span class="string">&#x27;upsample_flu&#x27;</span>).value</span><br><span class="line">        <span class="variable language_">self</span>.model= <span class="variable language_">self</span>.get_parameter(<span class="string">&#x27;model&#x27;</span>).value</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">&quot;人脸识别！启动！！&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 服务器对用户上传的图片进行处理，以下为逻辑处理代码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detect_face_callback</span>(<span class="params">self, request, response</span>):</span><br><span class="line">        <span class="keyword">if</span>(request.image.data):</span><br><span class="line">            <span class="comment"># 请求中有图像时</span></span><br><span class="line">            cv_img = <span class="variable language_">self</span>.cvbridge.imgmsg_to_cv2(request.image) <span class="comment"># 将消息接口格式的图像文件转化为cv2能识别的图像文件</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 请求中没有图像时</span></span><br><span class="line">            cv_img = cv2.imread(<span class="variable language_">self</span>.default_path)</span><br><span class="line">            <span class="comment"># 此时的cv_img已经是opencv格式的图像了</span></span><br><span class="line">            <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;默认图像位置：<span class="subst">&#123;self.default_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;并未找到图片，已经加载到默认图像&quot;</span>)</span><br><span class="line"></span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得人脸位置(即检测人脸)，传入参数(图像，上采样次数，使用模型)【关于上采样，其次数越高，图像精度也越高】 </span></span><br><span class="line">        face_locations = face_recognition.face_locations(cv_img,<span class="variable language_">self</span>.upsample_flu,<span class="variable language_">self</span>.model)</span><br><span class="line">        <span class="comment"># 绘制人脸框</span></span><br><span class="line">        <span class="keyword">for</span> top,bottom,right,left <span class="keyword">in</span> face_locations: <span class="comment"># 这里的top,bottom,right,left就是消息文件里定义的四个消息接口</span></span><br><span class="line">            response.top.append(top)</span><br><span class="line">            response.bottom.append(bottom)</span><br><span class="line">            response.right.append(right)</span><br><span class="line">            response.left.append(left)</span><br><span class="line">        </span><br><span class="line">        response.use_time = time.time()-start_time <span class="comment"># 消息接口里定义的use_time</span></span><br><span class="line">        response.number = <span class="built_in">len</span>(face_locations) <span class="comment">#诶，这里face_locations数组的长度就是人脸的个数</span></span><br><span class="line">        <span class="keyword">return</span> response <span class="comment"># 因为传入的不是指针类型，故需要return一下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node = FaceService()</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure><p><strong>3.客户端实现步骤：</strong></p><ul><li>创建客户端；</li><li>构造Request,发送请求；</li><li>处理返回的Response,绘制人脸显示。</li></ul><p><strong>客户端代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> chapt4_interfaces.srv <span class="keyword">import</span> Facedetector</span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">from</span> ament_index_python.packages <span class="keyword">import</span> get_package_share_directory <span class="comment"># 获得功能包share目录绝对路径</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> cv_bridge <span class="keyword">import</span> CvBridge</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FaceClient</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;face_client&#x27;</span>)</span><br><span class="line">        <span class="comment"># 创建服务 参数：(消息接口，服务名称，回调函数)</span></span><br><span class="line">        <span class="comment"># self.service = self.create_service(Facedetector,&#x27;face_detect&#x27;, self.detect_face_callback)</span></span><br><span class="line">        <span class="variable language_">self</span>.cvbridge = CvBridge()</span><br><span class="line">        <span class="variable language_">self</span>.default_path = os.path.join(get_package_share_directory(<span class="string">&quot;demo_python_service&quot;</span>),<span class="string">&quot;resource/test2.png&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.get_logger().info(<span class="string">&quot;人脸识别客户端！启动！！&quot;</span>)</span><br><span class="line">        <span class="comment"># 创建客户端 参数：(服务类型，服务名称，回调函数)，注意这里传入的服务名称必须要与服务端一致</span></span><br><span class="line">        <span class="variable language_">self</span>.face_client = <span class="variable language_">self</span>.create_client(Facedetector,<span class="string">&#x27;face_detect&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.image = cv2.imread(<span class="variable language_">self</span>.default_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 1.判断服务端是否上线</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.face_client.wait_for_service(timeout_sec=<span class="number">0.1</span>) <span class="keyword">is</span> <span class="literal">False</span>: <span class="comment"># 每隔0.1s就请求一下服务端</span></span><br><span class="line">            <span class="variable language_">self</span>.get_logger().info(<span class="string">&quot;服务端还未上线，请等待！&quot;</span>)</span><br><span class="line">        <span class="comment"># 2.构造request</span></span><br><span class="line">        request = Facedetector.Request()</span><br><span class="line">        request.image = <span class="variable language_">self</span>.cvbridge.cv2_to_imgmsg(<span class="variable language_">self</span>.image) <span class="comment"># 将opencv格式图像转化为消息接口可接受的图像格式</span></span><br><span class="line">        <span class="comment"># 3.发送请求并等待完成</span></span><br><span class="line">        future = <span class="variable language_">self</span>.face_client.call_async(request) <span class="comment">#(异步获取结果)现在的future中不包含响应结果，需要等待服务端处理完成才会把结果放到future中</span></span><br><span class="line">        <span class="comment"># while not future.done():</span></span><br><span class="line">        <span class="comment">#     time.sleep(1.0) # 休眠当前进程，等待服务处理完成.会造成当前线程无法再接收服务端的返回，这样永远也不会得到future.done()--&gt;True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># self可以相当于自定义类的一个对象</span></span><br><span class="line">        <span class="comment"># rclpy.spin_until_future_complete(self,future) # 一边查看future是否完成，一边接收结果【等待服务端返回响应】</span></span><br><span class="line">        <span class="comment"># 使用回调函数代替上面的方法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">result_callback</span>(<span class="params">result_future</span>):</span><br><span class="line">            response = result_future.result() <span class="comment"># 获取响应</span></span><br><span class="line">            <span class="variable language_">self</span>.get_logger().info(<span class="string">f&quot;已经收到响应，共收到<span class="subst">&#123;response.number&#125;</span>张人脸，耗时<span class="subst">&#123;response.use_time&#125;</span>秒&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.show_response(response)</span><br><span class="line">        future.add_done_callback(result_callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示服务端的响应结果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_response</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 绘制人脸</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(response.number):</span><br><span class="line">            top = response.top[i]</span><br><span class="line">            right= response.right[i]</span><br><span class="line">            bottom = response.bottom[i]</span><br><span class="line">            left = response.left[i]</span><br><span class="line">            cv2.rectangle(<span class="variable language_">self</span>.image,(left,top),(right,bottom),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 显示图片</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;face_result&#x27;</span>,<span class="variable language_">self</span>.image)</span><br><span class="line">        cv2.waitKey(<span class="number">0</span>) <span class="comment"># 也是会阻塞spin的，使其无法正常运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node = FaceClient()</span><br><span class="line">    node.send_request()</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure><p><strong>[注意]：</strong></p><p>​    1.python中不使用”!”取反，而直接使用”is False”or”not”。<br>​    2.发送请求并等待结果的过程处理，不要使用while进行简单处理，最好使用rclpy.spin_until_future_complete(参数) # 一边查看future是否完成，一边接收结果。<br>​    其中参数为调用call_async()返回的结果。<br>​    3.对于解决客户端发送请求响应更好的解决办法，可以采用回调函数（具体见face_client.py）<br>​    即让call_async()返回的结果调用add_done_callback()，里面放入回调函数，回调函数负责获取响应和显示响应。</p><hr><p>一些关于在python的同步代码中调用异步函数：</p><ul><li>当需要在同步函数中调用异步函数时，可以使用”asyncio.get_event_loop()”：来获取当前时间的循环；</li><li>“asyncio.run_coroutine_threadsafe(异步函数，当前时间循环)”：将异步函数包装成一个可调用的线程安全的协程对象；</li><li>“result()”：获取异步函数的返回值。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_function</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 模拟异步操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello ros2&quot;</span></span><br><span class="line"><span class="comment">#同步函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_function</span>():</span><br><span class="line">    loop = asyncio.get_event_loop() <span class="comment"># 获取当前时间循环</span></span><br><span class="line">    future = asyncio.run_coroutine_threadsafe(async_function,loop) <span class="comment"># 将异步函数包装成一个可调用的协程对象</span></span><br><span class="line">    result = future.result()</span><br></pre></td></tr></table></figure><p>但在处理异步函数时，可能会出现异常情况。以下是应对措施：</p><ul><li>常在”asyncio.run_coroutine_threadsafe()”的返回值上调用”add_done_callback(回调函数)”，该回调函数会在异步函数处理完后被调用，可以在里面处理异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_function</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 模拟异步操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello ros2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同步函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_function</span>():</span><br><span class="line">    loop = asyncio.get_event_loop() <span class="comment"># 获取当前时间循环</span></span><br><span class="line">    future = asyncio.run_coroutine_threadsafe(async_function,loop) <span class="comment"># 将异步函数包装成一个可调用的协程对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">f</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = f.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;An Exception  error:<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">     future.add_done_callback(callback)</span><br></pre></td></tr></table></figure><p><strong>[补充]：</strong></p><ol><li><strong>关于python中的异常捕获，常用如下结构：</strong></li></ol><p>try:</p><p>​…</p><p>except Exception as e:</p><p>​…</p><ol start="2"><li><strong>关于C++中的异常捕获，常用如下结构：</strong></li></ol><p>try{</p><p>​…</p><p>}catch(Exception e){</p><p>​…</p><p>}</p><ol start="3"><li>python语言编写项目时，resource下的文件不会由”colcon build”拷贝到install下的share目录中，需要在setup.py文件的data_files中添加。添加语句：**(“share&#x2F;“ + package_name+”&#x2F;resource”,[“文件名”])**。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务通信实训-人脸识别&quot;&gt;&lt;a href=&quot;#服务通信实训-人脸识别&quot; class=&quot;headerlink&quot; title=&quot;服务通信实训_人脸识别&quot;&gt;&lt;/a&gt;服务通信实训_人脸识别&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：使用python实现，创建一</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Service_communication" scheme="http://example.com/tags/Service-communication/"/>
    
  </entry>
  
  <entry>
    <title>ros_TF关系的查询</title>
    <link href="http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9F%A5%E8%AF%A2/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T13:21:02.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros-TF关系的查询"><a href="#ros-TF关系的查询" class="headerlink" title="ros_TF关系的查询"></a>ros_TF关系的查询</h1><p><strong>1.原理：</strong>订阅话题&#x2F;tf &#x2F;tf_static 收集所有坐标系关系，进行计算。</p><p><strong>2.核心代码：</strong><br>    self.buffer_ &#x3D; Buffer()<br>    self.listener_ &#x3D; TransformListener(self.buffer_,self)<br>    self.timer_ &#x3D; self.create_timer(1,self.get_transform)<br>    [注]：其中self.get_transform是自定义的用于实时查询坐标关系的函数（因为可能会查询失败，故使用try…except）。</p><p><strong>3.代码实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/transform_stamped.hpp&quot;</span> <span class="comment">// 消息接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/LinearMath/Quaternion.hpp&quot;</span> <span class="comment">// 提供Quaternion类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot;</span> <span class="comment">// 消息类型转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_listener.h&quot;</span> <span class="comment">//坐标监听类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/buffer.h&quot;</span> <span class="comment">// 提供buffer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/utils.h&quot;</span> <span class="comment">//提供四元数转欧拉角的函数</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// map到base_link之间的坐标关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">using</span> dynamic_tf = tf2_ros::TransformListener;</span><br><span class="line"><span class="keyword">using</span> bf = tf2_ros::Buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicTfListener</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;dynamic_tf&gt; listener_; <span class="comment">// 声明一个广播器类的共享指针</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    std::shared_ptr&lt;bf&gt; buffer_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicTfListener</span>() : <span class="built_in">Node</span>(<span class="string">&quot;listener_node&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 定时获取坐标变换</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1</span>s,std::<span class="built_in">bind</span>(&amp;DynamicTfListener::get_transform,<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;buffer_ = std::<span class="built_in">make_shared</span>&lt;bf&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">get_clock</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;listener_= std::<span class="built_in">make_shared</span>&lt;dynamic_tf&gt;(*buffer_, <span class="keyword">this</span>); <span class="comment">// 在dynamic_tf里面创建一个发布者来发布tf_static的话题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_transform</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 到buffer_里查询坐标关系</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 查询坐标关系[从&quot;target_point&quot;到&quot;base_link&quot;]</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> result = buffer_-&gt;<span class="built_in">lookupTransform</span>(<span class="string">&quot;base_link&quot;</span>,<span class="string">&quot;target_point&quot;</span>,</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">get_clock</span>()-&gt;<span class="built_in">now</span>(),rclcpp::Duration::<span class="built_in">from_seconds</span>(<span class="number">2.0f</span>));</span><br><span class="line">            <span class="comment">// 获取查询结果</span></span><br><span class="line">            <span class="keyword">auto</span> transform = result.transform.translation;</span><br><span class="line">            <span class="keyword">auto</span> rotation = result.transform.rotation; <span class="comment">// 这个rotation是四元数格式</span></span><br><span class="line">            <span class="type">double</span> y, p, r;</span><br><span class="line">            tf2::<span class="built_in">getEulerYPR</span>(rotation, y, p, r);</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(),<span class="string">&quot;平移:%f,%f,%f&quot;</span>,transform.x, transform.y, transform.z);</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(),<span class="string">&quot;旋转:y:%f,p:%f,r:%f&quot;</span>, y, p, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)&#123;</span><br><span class="line">            <span class="built_in">RCLCPP_WARN</span>(<span class="built_in">get_logger</span>(),<span class="string">&quot;%s&quot;</span>,e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    <span class="keyword">auto</span> stb = std::<span class="built_in">make_shared</span>&lt;DynamicTfListener&gt;();</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(stb);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros-TF关系的查询&quot;&gt;&lt;a href=&quot;#ros-TF关系的查询&quot; class=&quot;headerlink&quot; title=&quot;ros_TF关系的查询&quot;&gt;&lt;/a&gt;ros_TF关系的查询&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1.原理：&lt;/strong&gt;订阅话题&amp;#x2F;tf</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ros_git进阶</title>
    <link href="http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_git%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_git%E8%BF%9B%E9%98%B6/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T13:22:19.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros-git进阶"><a href="#ros-git进阶" class="headerlink" title="ros_git进阶"></a>ros_git进阶</h1><ol><li>“git status”:可以查看修改的文件名。</li><li>“git diff” or “git diff 文件名”:可以查看具体修改内容。</li><li>还可以在vscode中的”源代码管理”下可视化查看修改的文件和内容。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros-git进阶&quot;&gt;&lt;a href=&quot;#ros-git进阶&quot; class=&quot;headerlink&quot; title=&quot;ros_git进阶&quot;&gt;&lt;/a&gt;ros_git进阶&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;“git status”:可以查看修改的文件名。&lt;/li&gt;
&lt;li&gt;“g</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ros_动态TF的发布</title>
    <link href="http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%8A%A8%E6%80%81TF%E7%9A%84%E5%8F%91%E5%B8%83/"/>
    <id>http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%8A%A8%E6%80%81TF%E7%9A%84%E5%8F%91%E5%B8%83/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T13:18:00.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态TF的发布"><a href="#动态TF的发布" class="headerlink" title="动态TF的发布"></a>动态TF的发布</h1><p><strong>原理：</strong>不停发布 &#x2F;tf 话题</p><p><strong>代码实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/transform_stamped.hpp&quot;</span> <span class="comment">// 消息接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/LinearMath/Quaternion.hpp&quot;</span> <span class="comment">// 提供Quaternion类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot;</span> <span class="comment">// 消息类型转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/transform_broadcaster.h&quot;</span> <span class="comment">//坐标广播器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map到base_link之间的坐标关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">using</span> dynamic_tf = tf2_ros::TransformBroadcaster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicTfBc</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;dynamic_tf&gt; broadcaster_; <span class="comment">// 声明一个广播器类的共享指针</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicTfBc</span>() : <span class="built_in">Node</span>(<span class="string">&quot;dynamic_node&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// ??????这里为啥一个有this-&gt; ,一个没有this-&gt;（哦哦，是因为create_wall_timer是在rclcpp::Node节点里的，而我们创建的类刚好继承了Node）</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;broadcaster_ = std::<span class="built_in">make_shared</span>&lt;dynamic_tf&gt;(<span class="keyword">this</span>); <span class="comment">// 在dynamic_tf里面创建一个发布者来发布tf_static的话题</span></span><br><span class="line">        <span class="comment">// this-&gt;publish_tf(); //静态发布，只能发布一次</span></span><br><span class="line">        <span class="comment">//参数： (类模板，对象指针)</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">100</span>ms,std::<span class="built_in">bind</span>(&amp;DynamicTfBc::publish_tf,<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publish_tf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建消息接口</span></span><br><span class="line">        geometry_msgs::msg::TransformStamped tf;</span><br><span class="line">        tf.header.stamp = <span class="keyword">this</span>-&gt;<span class="built_in">get_clock</span>()-&gt;<span class="built_in">now</span>();</span><br><span class="line">        tf.header.frame_id = <span class="string">&quot;map&quot;</span>;</span><br><span class="line">        tf.child_frame_id = <span class="string">&quot;base_link&quot;</span>;</span><br><span class="line">        <span class="comment">// 给平移部分赋值</span></span><br><span class="line">        tf.transform.translation.x = <span class="number">2.0</span>;</span><br><span class="line">        tf.transform.translation.y = <span class="number">3.0</span>;</span><br><span class="line">        tf.transform.translation.z = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">// 定义一个四元数类</span></span><br><span class="line">        tf2::Quaternion q;</span><br><span class="line">        <span class="comment">// 把已知欧拉角度转成四元数</span></span><br><span class="line">        q.<span class="built_in">setRPY</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">30</span>*M_PI/<span class="number">180</span>);</span><br><span class="line">        <span class="comment">// 给旋转部分赋值</span></span><br><span class="line">        tf.transform.rotation = tf2::<span class="built_in">toMsg</span>(q);</span><br><span class="line">        <span class="comment">// 把消息发布出去</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;broadcaster_-&gt;<span class="built_in">sendTransform</span>(tf);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    <span class="keyword">auto</span> stb = std::<span class="built_in">make_shared</span>&lt;DynamicTfBc&gt;();</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(stb);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不同于静态坐标只用发布一次，动态坐标需要一个定时器，不断的发送坐标。</li><li>静态和动态坐标的发布，核心逻辑都是先创建消息接口，再填充消息接口，最后把消息发布出去。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态TF的发布&quot;&gt;&lt;a href=&quot;#动态TF的发布&quot; class=&quot;headerlink&quot; title=&quot;动态TF的发布&quot;&gt;&lt;/a&gt;动态TF的发布&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt;不停发布 &amp;#x2F;tf 话题&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ros_TF相关命令及原理探究</title>
    <link href="http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_TF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T12:49:17.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros-TF相关命令及原理探究"><a href="#ros-TF相关命令及原理探究" class="headerlink" title="ros_TF相关命令及原理探究"></a>ros_TF相关命令及原理探究</h1><p>以下均是终端内输入的命令</p><p><strong>1.TF工具的简单介绍</strong></p><ul><li>通过命令行使用TF：（e.g）</li></ul><p>发布base_link到base_laser之间的变换:ros2 run tf2_ros static_transform_publisher –x 值 –y 值 -z 值</p><p> –roll 值 –pitch 值 –yaw 值 –frame-id id值 –child-frame-id id值。</p><p>​    **[注]**：roll:翻滚 pitch:俯仰 yaw:偏航</p><p>发布base_laser到wall_point之间的变换:ros2 run2 tf2_ros static_transform_publisher –x 值 –y 值 -z 值<br>–roll 值 –pitch 值 –yaw 值 –frame-id id值 –child-frame-id id值。</p><p>查询base_link到wall_point之间的关系：ros2 run tf2_ros tf2_echo id值1 id值2。</p><ul><li>“3d-rotation-converter”：可以对坐标变化过程进行可视化。</li><li>“ros2 run tf2_tools view_frames”:查看TF树。</li></ul><p><strong>2. TF原理探究</strong></p><ul><li>ros2 topic list -t：查询话题及其对应接口。</li><li>ros2 interface show 接口：接口详细填充展示。</li><li>static_transform_publisher适合于查询雷达这种固定物件相较于机器人的位置关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros-TF相关命令及原理探究&quot;&gt;&lt;a href=&quot;#ros-TF相关命令及原理探究&quot; class=&quot;headerlink&quot; title=&quot;ros_TF相关命令及原理探究&quot;&gt;&lt;/a&gt;ros_TF相关命令及原理探究&lt;/h1&gt;&lt;p&gt;以下均是终端内输入的命令&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ros_静态TF的发布</title>
    <link href="http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_%E9%9D%99%E6%80%81TF%E7%9A%84%E5%8F%91%E5%B8%83/"/>
    <id>http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_%E9%9D%99%E6%80%81TF%E7%9A%84%E5%8F%91%E5%B8%83/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T12:56:47.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros-静态TF的发布"><a href="#ros-静态TF的发布" class="headerlink" title="ros_静态TF的发布"></a>ros_静态TF的发布</h1><p>从机械臂底座到相机–&gt;使用静态TF发布<br>    <strong>原理</strong>：发布 &#x2F;tf_static话题。<br>    使用transform3d库可以让四元数和欧拉坐标相互转换。<br>    [注]：关于为什么静态TF<strong>只发布一次</strong>，但之后再去订阅还有消息？原因就在于tf_static每发布一次就会永久保留当前最新数据，当下次有订阅者订阅时还可以有内容发布。</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/transform_stamped.hpp&quot;</span> <span class="comment">// 消息接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2/LinearMath/Quaternion.hpp&quot;</span> <span class="comment">// 提供Quaternion类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot;</span> <span class="comment">// 消息类型转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tf2_ros/static_transform_broadcaster.h&quot;</span> <span class="comment">//静态坐标广播器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map到target_point之间的坐标关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> static_tf = tf2_ros::StaticTransformBroadcaster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTfBc</span> : <span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;static_tf&gt; broadcaster_; <span class="comment">// 声明一个广播器类的共享指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticTfBc</span>() : <span class="built_in">Node</span>(<span class="string">&quot;static_node&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;broadcaster_ = std::<span class="built_in">make_shared</span>&lt;static_tf&gt;(<span class="keyword">this</span>); <span class="comment">// 在static_tf里面创建一个发布者来发布tf_static的话题</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">publish_tf</span>(); <span class="comment">//静态发布，只能发布一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publish_tf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建消息接口</span></span><br><span class="line">        geometry_msgs::msg::TransformStamped tf;</span><br><span class="line">        tf.header.stamp = <span class="keyword">this</span>-&gt;<span class="built_in">get_clock</span>()-&gt;<span class="built_in">now</span>();</span><br><span class="line">        tf.header.frame_id = <span class="string">&quot;map&quot;</span>;</span><br><span class="line">        tf.child_frame_id = <span class="string">&quot;target_point&quot;</span>;</span><br><span class="line">        <span class="comment">// 给平移部分赋值</span></span><br><span class="line">        tf.transform.translation.x = <span class="number">5.0</span>;</span><br><span class="line">        tf.transform.translation.y = <span class="number">3.0</span>;</span><br><span class="line">        tf.transform.translation.z = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">// 定义一个四元数类</span></span><br><span class="line">        tf2::Quaternion q;</span><br><span class="line">        <span class="comment">// 把已知欧拉角度转成四元数</span></span><br><span class="line">        q.<span class="built_in">setRPY</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">60</span>*M_PI/<span class="number">180</span>);</span><br><span class="line">        <span class="comment">// 给旋转部分赋值</span></span><br><span class="line">        tf.transform.rotation = tf2::<span class="built_in">toMsg</span>(q);</span><br><span class="line">        <span class="comment">// 把消息发布出去</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;broadcaster_-&gt;<span class="built_in">sendTransform</span>(tf);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    <span class="keyword">auto</span> stb = std::<span class="built_in">make_shared</span>&lt;StaticTfBc&gt;();</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(stb);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>“四元数.setRPY(x,y,z)”：将传入的欧拉角度(弧度制)转换为四元数。</p></li><li><p>静态坐标的发布用到了静态坐标广播器。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ros-静态TF的发布&quot;&gt;&lt;a href=&quot;#ros-静态TF的发布&quot; class=&quot;headerlink&quot; title=&quot;ros_静态TF的发布&quot;&gt;&lt;/a&gt;ros_静态TF的发布&lt;/h1&gt;&lt;p&gt;从机械臂底座到相机–&amp;gt;使用静态TF发布&lt;br&gt;    &lt;str</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ros_常用可视化工具rqt&amp;Rviz和数据记录工具ros2 bag</title>
    <link href="http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7rqt&amp;Rviz%E5%92%8C%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7ros2%20bag/"/>
    <id>http://example.com/2025/09/21/ros2/%E5%B7%A5%E5%85%B7/ros_%E5%B8%B8%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7rqt&amp;Rviz%E5%92%8C%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7ros2%20bag/</id>
    <published>2025-09-20T16:00:00.000Z</published>
    <updated>2025-09-21T12:42:40.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用可视化工具rqt-Rviz和数据记录工具ros2-bag"><a href="#常用可视化工具rqt-Rviz和数据记录工具ros2-bag" class="headerlink" title="常用可视化工具rqt&amp;Rviz和数据记录工具ros2 bag"></a>常用可视化工具rqt&amp;Rviz和数据记录工具ros2 bag</h1><ol start="2"><li>在终端中输入”rviz2”可以启动该工具。</li><li>“ros2 bag record 订阅的话题名字”：可以记录下话题，方便下次重播。</li><li>“ros2 bag play 记录的文件名”：可以播放记录的文件。 【未成功实践版】</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用可视化工具rqt-Rviz和数据记录工具ros2-bag&quot;&gt;&lt;a href=&quot;#常用可视化工具rqt-Rviz和数据记录工具ros2-bag&quot; class=&quot;headerlink&quot; title=&quot;常用可视化工具rqt&amp;amp;Rviz和数据记录工具ros2 b</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/09/19/ros2/%E4%BB%BF%E7%9C%9F/ros_%E4%BD%BF%E7%94%A8URDF%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>http://example.com/2025/09/19/ros2/%E4%BB%BF%E7%9C%9F/ros_%E4%BD%BF%E7%94%A8URDF%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2025-09-19T13:17:16.591Z</published>
    <updated>2025-09-19T13:23:16.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-帮机器人创建一个身体"><a href="#1-帮机器人创建一个身体" class="headerlink" title="1.帮机器人创建一个身体"></a>1.帮机器人创建一个身体</h3><ul><li>URDF使用XML来描述机器人的几何结构、传感器和执行器等信息。</li></ul><p>e.g：下述代码定义了一个名为first_robot的机器人，该机器人有一个base_link的部件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;robot name=&quot;first_robot&quot;&gt;</span><br><span class="line">&lt;!--XML注释--&gt;</span><br><span class="line">&lt;link name=&quot;base_link&quot;&gt;&lt;/link&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-帮机器人创建一个身体&quot;&gt;&lt;a href=&quot;#1-帮机器人创建一个身体&quot; class=&quot;headerlink&quot; title=&quot;1.帮机器人创建一个身体&quot;&gt;&lt;/a&gt;1.帮机器人创建一个身体&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;URDF使用XML来描述机器人的几何结构、传感器</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux基础之环境变量</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:31:08.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux基础之环境变量"><a href="#Linux基础之环境变量" class="headerlink" title="Linux基础之环境变量"></a>Linux基础之环境变量</h1><ol><li><p>ros2 命令就是通过环境变量来寻找功能包的。</p></li><li><p>printenv:可以用来打印环境变量。</p></li><li><p>printenv | grep 筛选内容：可以查找所选取的环境变量。</p></li><li><p>当出现报错“Package xx not found”时，可以检查AMENT_PREFIX_PATH下的lib是否有这个包。</p></li><li><p>AMENT_PREFIX_PATH（路径）的初始值是由默认脚本设置的，该默认脚本位置为:~&#x2F;.bashrc[该文件为隐藏文件]。</p></li><li><p>使用 ls -a可以查看当前目录下的隐藏文件。</p></li><li><p>“source &#x2F;opt&#x2F;ros&#x2F;jazzy&#x2F;setup.bash”语句用于设置环境变量。后面经常会用”source install&#x2F;setup.bash”来将colcon build生成的可执行文件写入Install文件中。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux基础之环境变量&quot;&gt;&lt;a href=&quot;#Linux基础之环境变量&quot; class=&quot;headerlink&quot; title=&quot;Linux基础之环境变量&quot;&gt;&lt;/a&gt;Linux基础之环境变量&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ros2 命令就是通过环境变量来寻找功能包</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>使用功能包组织节点</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E5%8C%85%E7%BB%84%E7%BB%87%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E5%8C%85%E7%BB%84%E7%BB%87%E8%8A%82%E7%82%B9/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:30:31.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用功能包组织节点"><a href="#使用功能包组织节点" class="headerlink" title="使用功能包组织节点"></a>使用功能包组织节点</h1><p>💖基本流程：<strong>命令行创建功能包</strong>-&gt;<strong>在功能包中创建节点</strong>-&gt;<strong>在set.up文件中进行配置</strong>-&gt;<strong>在xml文件中添加依赖信息</strong>（但是如果创建功能包时添加了–dependencies就不需要这步）-&gt;<strong>colcon build进行构建</strong>-&gt;<strong>source install&#x2F;setup.bash</strong>-&gt;<strong>“ros2 run 包名 文件名”运行文件</strong></p><ol><li><p>使用”ros2 pkg create demo_python_pkg –build-type ament_python –license Apache-2.0”可以创建Python功能包，如果不指定build-type，默认为C++类型功能包。【有时候还会有–dependencies等选项】</p></li><li><p>可以在第二级demo_python_pkg目录下新建节点文件。</p></li><li><p>在功能包中注册节点。[即在setup.py文件中添加节点函数在那一层]</p></li><li><p>打开功能包中的xml文件添加依赖信息。[添加“<depend>rclpy</depend>”]</p></li><li><p>“colcon build”:功能包的构建。[支持软链接，会把原来的包复制一份，然后执行复制的那份，即在install里面的python3.12&#x2F;site-packages中最里面那个python_node.py]</p><ul><li>[注]：colcon build一般在工作空间的根目录下进行，可以使用“colcon build-packages-select 包名”对特定的包进行构建。</li></ul></li><li><p>“source install&#x2F;setup.bash”：生成环境变量。[setup.bash脚本用于修改环境变量]</p><ul><li>[补]:”ros2 功能包名 节点名”：运行节点</li></ul></li></ol><p>7.export PYTHONPATH&#x3D;新位置:$PYTHONPATH”:临时修改参数的环境变量。[使用6就可以不用这个方法]</p><p>8.修改环境变量的几种方法：</p><ul><li><p>手动修改，即使用第7点</p></li><li><p>自动修改，即使用第6点</p></li></ul><p>9.如果希望节点能以”ros2 run 包名 节点名”的形式运行，创建类的时候需要对rclcpp&#x2F;rclpy中的Node进行继承。</p><p>关于C++和Python继承Node后，在main函数中的代码主要框架：</p><ul><li>C++：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv)</span></span>&#123;</span><br><span class="line">rclcpp::<span class="built_in">init</span>(argc,argv);</span><br><span class="line">    ...</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(创建的节点);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">rclpy.init()</span><br><span class="line">    ...</span><br><span class="line">    rclpy.spin(节点)</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用功能包组织节点&quot;&gt;&lt;a href=&quot;#使用功能包组织节点&quot; class=&quot;headerlink&quot; title=&quot;使用功能包组织节点&quot;&gt;&lt;/a&gt;使用功能包组织节点&lt;/h1&gt;&lt;p&gt;💖基本流程：&lt;strong&gt;命令行创建功能包&lt;/strong&gt;-&amp;gt;&lt;stro</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>多线程与回调函数</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0(Python%E7%89%88)/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0(Python%E7%89%88)/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:29:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程与回调函数"><a href="#多线程与回调函数" class="headerlink" title="多线程与回调函数"></a>多线程与回调函数</h1><p>┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w</p><ol><li><p>回调函数：把统计函数当作参数传递给下载函数，下载完成自己第一时间调用。</p></li><li><p>“threading.get_ident()”：可以得到线程编号(python中)；”this_thread.get_id()”：可以得到线程编号(c++中)。</p></li><li><p>“echo “文字” “&gt; 文件名,可生成对应文件,并将文字写入。</p></li><li><p>“python3 -m http.server”：启动python3的内置服务器。</p></li><li><p>一个程序默认是在一个线程中完成的，如果需要多个线程并行，则需要使用thread。  </p></li><li><p>与python中的多线程不同，c++中的线程一旦创建就立刻运行，并阻塞当前进程，所以需要用”thread.detach()”将其与当前进程进行分离。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程与回调函数&quot;&gt;&lt;a href=&quot;#多线程与回调函数&quot; class=&quot;headerlink&quot; title=&quot;多线程与回调函数&quot;&gt;&lt;/a&gt;多线程与回调函数&lt;/h1&gt;&lt;p&gt;┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;回调函数：把统计</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>有用的C++特性</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%B8%B8%E7%94%A8%E7%9A%84C++%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E5%B8%B8%E7%94%A8%E7%9A%84C++%E7%89%B9%E6%80%A7/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:30:02.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有用的C-特性"><a href="#有用的C-特性" class="headerlink" title="有用的C++特性"></a>有用的C++特性</h1><p>1.auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名字”)  node的类型是自动推导的。</p><p>2.智能指针&#x2F;共享指针:专治占着内存不使用的程序。</p><ul><li>指针.use_count()：得到指针引用次数。</li><li>指针.get():得到指向的内存地址。</li><li>指针-&gt;c_str():得到指针指向内存地址数据。</li><li>对象.函数(参数):直接通过对象访问成员    指针-&gt;函数(参数):通过指向对象的指针访问成员。</li><li>具体使用哪一个要看“访问者是对象本身，还是指向对象的指针”。</li><li>CPP的”colcon build”会添加到环境变量，所以没有source也能运行。(但最好还是build一下好)</li></ul><p>💥3.lambda表达式(放在函数里面用)<br>即换个语法写函数：<a href="parameters">capture list</a>-(parameter list)&gt;return type{function body}</p><ul><li>注:常用[&amp;](输入列表)-&gt;void{函数体}，其中void表示不返回</li><li>捕获列表可以为空，也可以使用默认捕获模式&amp;或者&#x3D;表示按引用或者值捕获所有外部变量。</li></ul><p>💥4.函数包装器：统一自由函数、成员方法和Lambda函数</p><ul><li>对于自由函数：std::function&lt;函数返回值(函数传入参数)&gt; 给该函数一个新名字 &#x3D; 原自由函数名;</li><li>对于lambda函数: 同自由函数;</li><li>对于成员方法【较复杂】：</li></ul><p>std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应函数的指针&#x2F;模板地址,对象的指针,参数数量占位符);</p><p>or</p><ul><li><p><input checked="" disabled="" type="checkbox"> std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应创造的对象,类中要调用的方法,参数数量占位符);</p></li><li><p>注：关于绑定bind很好解决了调用成员函数必须要先创造一个成员函数的问题，它直接绑定了一个对象。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有用的C-特性&quot;&gt;&lt;a href=&quot;#有用的C-特性&quot; class=&quot;headerlink&quot; title=&quot;有用的C++特性&quot;&gt;&lt;/a&gt;有用的C++特性&lt;/h1&gt;&lt;p&gt;1.auto 节点名字 &amp;#x3D; std::make_shared&amp;lt;类名&amp;gt;(“节</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>补充一些基础编程知识</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:30:07.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补充一些基础编程知识"><a href="#补充一些基础编程知识" class="headerlink" title="补充一些基础编程知识"></a>补充一些基础编程知识</h1><p>1.每次修改代码文件后，需要重新colcon build构建再运行。</p><p>2.面向对象编程都可以创建类，类是对事物的封装。</p><p>3.对于继承：<br><strong>python：</strong></p><ul><li>“from 父类所在文件 import 父类”;</li><li>class 子类(父类):  ;</li><li>“.super().init(父类构造需要的参数)” :调用父类的init方法。</li></ul><p><strong>c++:</strong></p><ul><li>class 子类 : public 父类 【例如】：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class PersonNode : public rclcpp::Node</span><br></pre></td></tr></table></figure><p>-<br>  子类(const 参数类型 &amp;参数1,…):父类(const 参数类型 &amp;父类构造所需参数);</p><ul><li><strong>注：</strong>创建共享指针，”auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名”)”</li></ul><p><strong>注：</strong></p><ul><li><p>使用共享指针需要头文件<memory></p></li><li><p>RCLCPP_INFO(节点名字-&gt;get_logger(),”要打印出来的文字信息”); 注意这个函数的参数形式。</p></li><li><p>传入时格式为”string”,输出时为”%s”,则可以在输出时加上”.c_str()进行强制转换”。【c_str():将str类型转换为c语言格式的字符串】</p></li><li><p>CPP文件中，有时候构造函数时会在传入参数前加上”const”（加在类型前）和”&amp;”（加在变量名前），加上前者是希望用户不要对传入的数据进行修改，加上后者(称为拷贝指针)是为了避免不必要的数据拷贝，以提高运行效率。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;补充一些基础编程知识&quot;&gt;&lt;a href=&quot;#补充一些基础编程知识&quot; class=&quot;headerlink&quot; title=&quot;补充一些基础编程知识&quot;&gt;&lt;/a&gt;补充一些基础编程知识&lt;/h1&gt;&lt;p&gt;1.每次修改代码文件后，需要重新colcon build构建再运行。&lt;/p&gt;</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>git命令基础入门</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_git%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_git%E5%85%A5%E9%97%A8/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:36:14.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git命令基础入门"><a href="#git命令基础入门" class="headerlink" title="git命令基础入门"></a>git命令基础入门</h1><ol><li><strong>克隆仓库</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br><span class="line">cd repo</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建新分支</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new-feature</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>暂存文件：将修改过的文件添加到暂存区</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名</span><br><span class="line">git add . # 添加所有修改的文件</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提交更改：将暂存区的更改提交到本地仓库</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;附加信息&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>拉取最新更改：在推送本地之前，最好从远程仓库拉取最新的更改，以免冲突</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br><span class="line">git pull origin new-feature #添加在新的分支上</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>合并更改：在PR审核过合并后，可以将远程仓库的主分支合并在本地分支</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>删除分支</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d new-feature</span><br><span class="line">git push origin --delete new-feature</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>[接下来是基础但较有用的功能]</strong></li></ol><ul><li>git status：查看仓库当前状态，显示有变更的文件。</li><li>git diff：比较文件的不同，即暂存区和工作区的差异。</li><li>git difftool：使用外部工具比较文件差异。</li><li>git reset：回退版本（即把暂存区的文件撤出）。</li><li>git rm：将文件从暂存区和工作区删除。</li><li>git mv：移动或者重命名工作区文件。</li><li>git  notes：添加注释。</li><li>git checkout：分支切换。|git switch：更清晰的分支切换。</li><li>git restore：恢复或撤销文件更改。</li><li>git show：显示git对象详细信息。</li><li>git log：查看历史提交记录。</li><li>git blame <file>：以列表形式查看指定文件的历史修改记录。</li><li>关于远程操作：<ul><li>git remove：远程仓库操作。</li><li>git fetch：从远程获得代码。</li><li>git pull：下载远程代码并合并。</li><li>git push：上传远程代码并合并。</li><li>git submodule：管理包含其他Git仓库的项目。</li></ul></li></ul><ol start="9"><li><strong>关于git忽略文件的命令</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .gitinore  (在gitinore文件中添加不需要加入缓冲区的文件)</span><br><span class="line">git commit -m &quot;注释&quot;：添加忽略文件；</span><br><span class="line">rm -rf .git ：删除 .git目录。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git命令基础入门&quot;&gt;&lt;a href=&quot;#git命令基础入门&quot; class=&quot;headerlink&quot; title=&quot;git命令基础入门&quot;&gt;&lt;/a&gt;git命令基础入门&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;克隆仓库&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;fi</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>话题通信介绍</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:32:45.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信介绍"><a href="#话题通信介绍" class="headerlink" title="话题通信介绍"></a>话题通信介绍</h1><p>1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。</p><p>2.”ros2 node info &#x2F;节点名字”：查看接口定义。（有发布者以及订阅者等相关信息）【发布者下的内容格式：话题：消息接口】</p><p>3.”ros2 topic echo &#x2F;话题名字”：查看话题内容。</p><p>4.”ros2 topic info &#x2F;话题名字”：查看消息接口。</p><p>5.”ros2 interface show 消息接口”：找到消息接口的定义。</p><p>6.”ros2 topic pub &#x2F;话题名字 消息接口 消息接口样本格式的数据填充”:使用话题控制机器人。【使用订阅者话题】</p><p><strong>注</strong>：消息接口样本格式的数据填充可以在”消息接口的定义”处查看，每下一个级别，需要加”{}”，<strong>参数名称后的”:”和自定义参数值之间需要加一个空格</strong>。</p><p>当自定义消息接口或者调用话题接口时常见步骤：</p><ul><li>“ros2 topic list -t”：返回话题及对应的消息接口。</li><li>“ros2 interface show 消息接口”：查消息接口的详细内容 | “ros2 interface proto 消息接口”：显示消息模板。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信介绍&quot;&gt;&lt;a href=&quot;#话题通信介绍&quot; class=&quot;headerlink&quot; title=&quot;话题通信介绍&quot;&gt;&lt;/a&gt;话题通信介绍&lt;/h1&gt;&lt;p&gt;1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。&lt;/p&gt;
&lt;p&gt;2.”ros2 node in</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
  <entry>
    <title>编写第一个ROS节点</title>
    <link href="http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAC++%E8%8A%82%E7%82%B9&amp;Python%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2025/09/19/ros2/%E5%9F%BA%E7%A1%80/ros_%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAC++%E8%8A%82%E7%82%B9&amp;Python%E8%8A%82%E7%82%B9/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:27:53.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写第一个ROS节点"><a href="#编写第一个ROS节点" class="headerlink" title="编写第一个ROS节点"></a>编写第一个ROS节点</h1><h2 id="ros中编写C-节点"><a href="#ros中编写C-节点" class="headerlink" title="ros中编写C++节点"></a>ros中编写C++节点</h2><ol><li><p>当项目较小时，可以在终端中使用”g++ cpp文件名”，得到一个可执行文件，再使用“.&#x2F;可执行文件名”运行程序。</p></li><li><p>当项目较大时，使用CMake得到生成指令。过程：编写一个CMakeList.txt文件(文件名不能改)-&gt;使用cmake指令转化为Makefile文件-&gt;使用make指令转化为exe文件。</p></li></ol><h2 id="ros中编写Python节点"><a href="#ros中编写Python节点" class="headerlink" title="ros中编写Python节点"></a>ros中编写Python节点</h2><p>1.直接编写后就可以使用”run 文件名”进行运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写第一个ROS节点&quot;&gt;&lt;a href=&quot;#编写第一个ROS节点&quot; class=&quot;headerlink&quot; title=&quot;编写第一个ROS节点&quot;&gt;&lt;/a&gt;编写第一个ROS节点&lt;/h1&gt;&lt;h2 id=&quot;ros中编写C-节点&quot;&gt;&lt;a href=&quot;#ros中编写C-节点&quot;</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="foundation" scheme="http://example.com/tags/foundation/"/>
    
  </entry>
  
  <entry>
    <title>话题通信实训-订阅pose实现闭环控制</title>
    <link href="http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%AE%A2%E9%98%85pose%E5%AE%9E%E7%8E%B0%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2025/09/19/ros2/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/ros_%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98_%E8%AE%A2%E9%98%85pose%E5%AE%9E%E7%8E%B0%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/</id>
    <published>2025-09-18T16:00:00.000Z</published>
    <updated>2025-09-19T11:34:24.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="话题通信实训-订阅pose实现闭环控制"><a href="#话题通信实训-订阅pose实现闭环控制" class="headerlink" title="话题通信实训-订阅pose实现闭环控制"></a>话题通信实训-订阅pose实现闭环控制</h1><p><strong>核心任务：</strong><br>       1. 小海龟怎么听我的？发布话题；<br>       2. 小海龟现在在哪里？订阅话题；<br>       3. 怎么根据当前位置和目标位置计算角速度和线速度？两点之间距离-&gt;线速度 当前朝向和目标朝向-&gt;角速度。</p><p><strong>1.定义控制小海龟的类</strong></p><p><strong>属性：</strong></p><ul><li>发布者的智能指针</li><li>订阅者的智能指针</li><li>目标坐标点、比例系数（用于控制运行速度）、最大速度</li></ul><p><strong>方法：</strong></p><ul><li>获取当前位置，并计算新位置发布出去的函数</li></ul><p><strong>【注】：</strong></p><ul><li>不同于python，C++在创建实例前需要声明。以下是发布者和订阅者声明的代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rclcpp::Publisher&lt;消息接口&gt;::SharedPtr publisher_; <span class="comment">//发布者的智能共享指针</span></span><br><span class="line">rclcpp::Subscription&lt;消息接口&gt;::SharedPtr subscriber_; <span class="comment">//订阅者的智能共享指针</span></span><br></pre></td></tr></table></figure><ul><li>发布者和订阅者创建代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;消息接口&gt;(<span class="string">&quot;话题名称&quot;</span>,qos); <span class="comment">//创建发布者</span></span><br><span class="line">subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;消息接口&gt;(<span class="string">&quot;话题名称&quot;</span>,qos,std::<span class="built_in">bind</span>(&amp;TurtleControlNode::on_pose_received,<span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1)); <span class="comment">//创建订阅者</span></span><br></pre></td></tr></table></figure><p>关于回调函数，这里采用的是将成员方法放入函数包装器中（其实用lambda函数更简单）。函数形式：std::bind(&amp;类节点实例化, 对象指针, 参数占位符))。”订阅者的话题名称”要与对应的发布者消息接口对应。</p><p><strong>2.完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_msgs/msg/twist.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/msg/pose.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurtleControlNode</span>: <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// rclcpp::TimerBase::SharedPtr timer_;</span></span><br><span class="line">    rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; <span class="comment">//发布者的智能共享指针</span></span><br><span class="line">    rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; <span class="comment">//订阅者的智能共享指针</span></span><br><span class="line">    <span class="type">double</span> target_x_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> target_y_&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> k_&#123;<span class="number">1.0</span>&#125;;  <span class="comment">//比例系数【间接控制速度】</span></span><br><span class="line">    <span class="type">double</span> max_speed_&#123;<span class="number">3.0</span>&#125;; <span class="comment">//最大速度</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TurtleControlNode</span><span class="params">(<span class="type">const</span> std::string&amp; node_name)</span>:Node(node_name)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>); <span class="comment">// 这里传入运动控制的消息接口，由其发布控制信息给小海龟</span></span><br><span class="line">        subscriber_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;turtlesim::msg::Pose&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>,<span class="number">10</span>,std::<span class="built_in">bind</span>(&amp;TurtleControlNode::on_pose_received,<span class="keyword">this</span>,</span><br><span class="line">        std::placeholders::_1)); </span><br><span class="line">        <span class="comment">// timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleControlNode::timer_callback,this));</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 获取当前位置，并计算新位置发布出去</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pose_received</span><span class="params">(<span class="type">const</span> turtlesim::msg::Pose::SharedPtr pose)</span></span>&#123; <span class="comment">//参数：收到数据的共享指针</span></span><br><span class="line">        <span class="comment">// 1.获取当前位置</span></span><br><span class="line">        <span class="keyword">auto</span> current_x = pose-&gt;x;</span><br><span class="line">        <span class="keyword">auto</span> current_y = pose-&gt;y; </span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(),<span class="string">&quot;获取当前位置:x=%f,y=%f&quot;</span>,current_x,current_y);</span><br><span class="line">        <span class="comment">// 2.计算当前海龟位置跟目标位置之间的距离差和角度差。</span></span><br><span class="line">        <span class="keyword">auto</span> distanc  e = std::<span class="built_in">sqrt</span>((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y));</span><br><span class="line">        <span class="comment">// 目标角度和当前角度的差值</span></span><br><span class="line">        <span class="keyword">auto</span> angle = std::<span class="built_in">atan2</span>((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta;</span><br><span class="line">        <span class="comment">// 3.控制策略</span></span><br><span class="line">        <span class="keyword">auto</span> msg = geometry_msgs::msg::<span class="built_in">Twist</span>();</span><br><span class="line">        <span class="keyword">if</span>(distance&gt;<span class="number">0.1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(angle)&gt;<span class="number">0.2</span>)&#123;</span><br><span class="line">                msg.angular.z = <span class="built_in">fabs</span>(angle);  <span class="comment">//如果角度差大于0.2则改变角度(进行旋转)       </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                msg.linear.x = k_*distance; <span class="comment">//如果角度差不大，则提高速度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//限制最大线速度</span></span><br><span class="line">        <span class="keyword">if</span>(msg.linear.x &gt; max_speed_)&#123;</span><br><span class="line">            msg.linear.x = max_speed_;</span><br><span class="line">        &#125;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TurtleControlNode&gt;(<span class="string">&quot;turtle_control&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>学习收获：</strong></p><ol><li><p>学会了C++版本的发布者和订阅者的声明和创建。</p></li><li><p>在小海龟程序中，可以通过”urtlesim&#x2F;msg&#x2F;pose”接口来获取当前海龟位置，通过”geometry_msgs&#x2F;msg&#x2F;twist”接口来控制海龟的运动。</p></li><li><p>在关键字前添加”explicit”：防止类进行单参数隐式转换。即类的构造函数只有一个参数时，可以通过唯一的参数值来构造该类。</p></li><li><p>c++中的”::”：访问命名空间内的标识符，避免不同命名空间的同名冲突。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;话题通信实训-订阅pose实现闭环控制&quot;&gt;&lt;a href=&quot;#话题通信实训-订阅pose实现闭环控制&quot; class=&quot;headerlink&quot; title=&quot;话题通信实训-订阅pose实现闭环控制&quot;&gt;&lt;/a&gt;话题通信实训-订阅pose实现闭环控制&lt;/h1&gt;&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="ROS2" scheme="http://example.com/categories/ROS2/"/>
    
    
    <category term="ROS2" scheme="http://example.com/tags/ROS2/"/>
    
    <category term="Topic_communication" scheme="http://example.com/tags/Topic-communication/"/>
    
  </entry>
  
</feed>

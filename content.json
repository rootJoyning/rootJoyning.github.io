[{"title":"git命令基础入门","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_git入门/","text":"git命令基础入门 克隆仓库 12git clone 地址cd repo 创建新分支 1git checkout -b new-feature 暂存文件：将修改过的文件添加到暂存区 12git add 文件名git add . # 添加所有修改的文件 提交更改：将暂存区的更改提交到本地仓库 1git commit -m &quot;附加信息&quot; 拉取最新更改：在推送本地之前，最好从远程仓库拉取最新的更改，以免冲突 12git pull origin maingit pull origin new-feature #添加在新的分支上 合并更改：在PR审核过合并后，可以将远程仓库的主分支合并在本地分支 123git checkout maingit pull origin maingit merge new-feature 删除分支 12git branch -d new-featuregit push origin --delete new-feature [接下来是基础但较有用的功能] git status：查看仓库当前状态，显示有变更的文件。 git diff：比较文件的不同，即暂存区和工作区的差异。 git difftool：使用外部工具比较文件差异。 git reset：回退版本（即把暂存区的文件撤出）。 git rm：将文件从暂存区和工作区删除。 git mv：移动或者重命名工作区文件。 git notes：添加注释。 git checkout：分支切换。|git switch：更清晰的分支切换。 git restore：恢复或撤销文件更改。 git show：显示git对象详细信息。 git log：查看历史提交记录。 git blame ：以列表形式查看指定文件的历史修改记录。 关于远程操作： git remove：远程仓库操作。 git fetch：从远程获得代码。 git pull：下载远程代码并合并。 git push：上传远程代码并合并。 git submodule：管理包含其他Git仓库的项目。 关于git忽略文件的命令 123git add .gitinore (在gitinore文件中添加不需要加入缓冲区的文件)git commit -m &quot;注释&quot;：添加忽略文件；rm -rf .git ：删除 .git目录。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战_自定义实现实时状态信息查询小工具","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_自定义实现实时状态信息查询小工具/","text":"话题通信实战_自定义实现实时状态信息查询小工具需求： 通过该工具可以看到系统的实时状态信息，包括记录信息的时间、主机名称、cpu使用率、内存使用率、内存总大小、剩余内存、网络接收数据量和网络发送数据量。 要有一个简单的界面，可以将系统信息显示出来。 要能在局域网内其他主机上查看数据。 分析： 要能获取系统状态信息–&gt;python库psutils; 要有一个展示界面–&gt;QT; 要能共享数据–&gt;ROS2话题。总体架构：&#x2F;sys_status_pub—-&gt;&#x2F;sys_status—&gt;&#x2F;sys_status_display 步骤： 1. 自定义通信接口【注】： builtin_interfaces()：提供时间戳； 按照需求编写一个.msg的接口文件。注意：msg文件的命名必须使用驼峰命名法。 需要在对应的CMakeList.txt文件中添加rosidl_generate_interfaces()，其为cmake函数，用于将msg消息接口定义文件转化为库或者头文件类。 具体实现： 123rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/SystemStatus.msg&quot; DEPENDENCIES builtin_interfaces 代码实现： 1234567builtin_interfaces/Time stamp #记录时间戳string host_name #主机名float32 memory_percent #主存使用率float32 cpu_percent #CPU使用率float32 memory_available #主存剩余率float64 net_send #网络发送率float64 net_recv #网络接收率 2. 系统信息获取和发布【注】：使用psutils和platform两个库主要用于获取信息；其中psutil库可以查询cpu利用率、内存情况和网络输出输入情况等。platform库用于查询主机名字等。 代码实现： 1234567891011121314151617181920212223242526272829303132333435import rclpyfrom rclpy.node import Nodefrom status_interfaces.msg import SystemStatusimport psutilimport platformclass SystemStatusPub(Node): def __init__(self, node_name): super().__init__(node_name) self.status_publisher_ = self.create_publisher(SystemStatus, &#x27;sys_status&#x27;, 10) self.time_ = self.create_timer(1.0, self.timer_callback) def timer_callback(self): cup_percent = psutil.cpu_percent() memory_info = psutil.virtual_memory() # 查看当前内存情况 net_io_counters = psutil.net_io_counters() # 查看网络输入输出情况 msg = SystemStatus() # 自定义的通信接口经过一系列操作变成了类 msg.stamp = self.get_clock().now().to_msg() # 获取当前时间戳并转化为信息 msg.host_name = platform.node() # 返回主机名字 msg.cpu_percent = cup_percent msg.memory_percent = memory_info.percent msg.memory_available = memory_info.available /1024/1024# 有效内存 msg.net_send = net_io_counters.packets_sent /1024/1024 # 将字节转换为兆字节 msg.net_recv = net_io_counters.packets_recv /1024/1024 self.get_logger().info(f&quot;发布相关信息：&#123;msg&#125;&quot;) self.status_publisher_.publish(msg)def main(): rclpy.init() sys_status_pub = SystemStatusPub(&quot;status_publish&quot;) rclpy.spin(sys_status_pub) rclpy.shutdown() 3.订阅数据并用QT显示【注】 使用new()创建类后需要手动释放内存，只有遇到”delete()”时才会调用析构函数 使用”类名 创建的类”这种类定义声明的方式使用后不需要手动释放，这种类中的析构函数会自动执行。 关于类对象的三种创建方法： 第一：Test test1; 栈中分配，由os进行内存分配和管理。 第二：Test test2 &#x3D; Test(); 栈中分配，由os进行内存分配和管理。 第三：Test *test3 &#x3D; new Test(); 堆中分配，由管理者进行内存分配和管理，显式使用delete()释放内存空间。 “.”:是结构体引用，”-&gt;”:是指针引用。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;QApplication&gt;#include &lt;QLabel&gt;#include &lt;QString&gt;#include &lt;rclcpp/rclcpp.hpp&gt;#include &quot;status_interfaces/msg/system_status.hpp&quot;using SystemStatus = status_interfaces::msg::SystemStatus; // 将包名进行改名class SystemStatusDisplay : public rclcpp::Node&#123;private:/*data*/ rclcpp::Subscription&lt;SystemStatus&gt;::SharedPtr subscriber_;public: QLabel *label_ = new QLabel(); SystemStatusDisplay():Node(&quot;sys_status_display&quot;)&#123; // 使用lambda函数作为回调函数,接收的函数为共享指针 subscriber_ = this-&gt;create_subscription&lt;SystemStatus&gt;(&quot;sys_status&quot;,10,[&amp;](const SystemStatus::SharedPtr msg)-&gt;void&#123; label_-&gt;setText(get_qstr_from_msg(msg)); &#125;); label_-&gt;setText(get_qstr_from_msg(std::make_shared&lt;SystemStatus&gt;())); // 初始给label传一个空的共享指针，这样有表头没有具体内容。 label_-&gt;show(); &#125;; QString get_qstr_from_msg(const SystemStatus::SharedPtr msg)&#123; // 将获取到的msg内容进行拆分组装 std::stringstream show_str; show_str &lt;&lt; &quot;==========状态可视化显示工具============\\n&quot; &lt;&lt; &quot;数 据 时 间:\\t&quot; &lt;&lt; msg-&gt;stamp.sec &lt;&lt; &quot;\\ts\\n&quot; &lt;&lt; &quot;主 机 名:\\t&quot; &lt;&lt; msg-&gt;host_name &lt;&lt; &quot;\\t\\n&quot; &lt;&lt; &quot;cpu 利 用 率:\\t&quot; &lt;&lt; msg-&gt;cpu_percent &lt;&lt; &quot;\\t%\\n&quot; &lt;&lt; &quot;内 存 利 用 率:\\t&quot; &lt;&lt; msg-&gt;memory_percent &lt;&lt; &quot;\\t%\\n&quot; &lt;&lt; &quot;剩 余 有 效 内 存:\\t&quot; &lt;&lt; msg-&gt;memory_available &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;网 络 发 送 量:\\t&quot; &lt;&lt; msg-&gt;net_send &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;网 络 接 收 量:\\t&quot; &lt;&lt; msg-&gt;net_recv &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;=======================================&quot;; return QString::fromStdString(show_str.str()); &#125;;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc, argv); QApplication app(argc, argv); //类对象的声明 auto node = std::make_shared&lt;SystemStatusDisplay&gt;(); // 创建一个模板为SystemStatusDisplay的共享指针 std::thread spin_thread([&amp;]()-&gt;void&#123; rclcpp::spin(node); // 为其单独开一个线程 &#125;); spin_thread.detach(); app.exec(); rclcpp::shutdown(); return 0;&#125; 关于rclcpp::spin()：会阻塞调用它的线程，直到与它关联的节点被销毁。函数执行期间，它执行以下操作： 处理回调：调用所有已注册的回调，包括订阅者的消息回调、服务的请求回调、定时器回调。 事件循环：处理所有ROS通信相关的事件，确保节点能够响应外部消息和服务请求。 阻塞执行：该函数会一直运行，直到调用其的节点被销毁或者显示地调用rclcpp::shutdown()。 学习收获： 如何根据需求自定义.msg文件 ； 如何获取电脑基本参数信息； 如何进行字符串流输出。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战-通过话题发布小说","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战-通过话题发布小说/","text":"话题通信实战-通过话题发布小说需求：下载小说并通过话题间隔5s发布一行核心问题： 1. 怎么下载小说？ 使用requests; 2. 怎么发布？确定名字和接口; 3. 怎么间隔5s发布？Timer定时器。 1. 定义一个继承rclpy.node的节点 属性： 存放小说的队列 发布者 定时器 方法： 判断队列大小的回调函数 下载函数 【注】： 创建发布者代码： 1self.create_publisher(消息接口,&#x27;自定义话题名字&#x27;,服务质量配置) 关于服务质量配置是给一个表示队列大小的数字。create_publisher()的返回值为 一个发布者。 创建定时器代码： 1self.create_timer(时间间隔周期,自定义回调函数) create_timer()没有返回值，其会按照传入的间隔周期去调用回调函数。 2. 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041import rclpyfrom rclpy.node import Nodeimport requestsfrom example_interfaces.msg import Stringfrom queue import Queueclass pubNode(Node): def __init__(self, node_name): super().__init__(node_name) self.get_logger().info(f&quot;&#123;node_name&#125;,启动！&quot;) self.novels_queue = Queue() # 创建队列 # 参数依次为：消息接口，话题的名字(自定义)，服务质量配置（给一个表示队列大小的数字;返回值为发布者 self.novel_publisher_ = self.create_publisher(String,&#x27;novel&#x27;,100) self.create_timer(5,self.timer_callback) # 参数：时间间隔周期，回调函数 # 判断队列大小-&gt;若大于0则从队列里面取一行数据-&gt;组装成消息-&gt;发布消息 def timer_callback(self): # 设置一个回调函数 if self.novels_queue.qsize() &gt; 0: line = self.novels_queue.get() msg = String() # 组装数据 msg.data = line self.novel_publisher_.publish(msg) self.get_logger().info(f&quot;发布了：&#123;msg&#125;&quot;) # 下载：获取请求-&gt;按行分割-&gt;放到队列里面 def download(self, url): res = requests.get(url) res.encoding = &#x27;utf-8&#x27; text = res.text # text.splitlines() #把下载的内容按行分割 self.get_logger().info(f&quot;下载&#123;url&#125;,&#123;len(text)&#125;&quot;) for line in text.splitlines(): self.novels_queue.put(line) def main(): rclpy.init() node = pubNode(&quot;novel_pub&quot;) node.download(&quot;http://0.0.0.0:8000/novel1.txt&quot;) rclpy.spin(node) rclpy.shutdown() 【笔记】： example_interface：样例消息类。 回调函数依赖的成员变量容器要提前初始化。 “python -m http.server”：在当前目录启动一个HTTP服务器，默认监听端口为8000。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战-订阅小说并合成语音","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_订阅小说并合成语音/","text":"话题通信实战-订阅小说并合成语音核心要求： 1. 怎么订阅？ 2. 用什么朗读文本？ Espeak 3. 小说来的快，读得慢怎么办？使用队列 1. 定义一个继承rclpy.node的节点类 属性： 存放小说的队列 订阅者 线程对象 方法： 回调函数：用于不断将小说放入队列中。 线程函数：检测到队列中存在小说就开始朗读。 下载小说的函数。 【注】： 创建订阅者的代码： 1self.create_subscription(消息接口, &quot;自定义话题名称&quot;, 回调函数, qos) 这里的qos就是前文提到的ros2中的通信服务质量，通常是一个数字；函数返回值为一个订阅者实例。还要注意的是，这里的**”自定义话题名称”需要与话题发布者的名称相同**，这样才能订阅到话题。 创建线程的代码： 12self.speech_thread_=threading.Thread(target=线程函数,传给线程函数的tuple类型参数) self.speech_thread_.start() # 注意python的线程不会自己启动，需要手动开始 “传给线程函数的tuple类型参数”有默认值，可以不传参数。 2. 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import espeakng import rclpyfrom rclpy.node import Nodeimport requestsfrom example_interfaces.msg import Stringfrom queue import Queueimport threadingimport timeclass Novel_sub_Node(Node): def __init__(self, node_name): super().__init__(node_name) self.novel_queue = Queue() self.get_logger().info(f&quot;&#123;node_name&#125;,启动！&quot;) # 创建订阅者 参数：信息类型，话题名称（这里一定要与发布者取的名字一致），回调函数,qos self.novel_sub_ = self.create_subscription(String, &quot;novel&quot;, self.novel_callback, 10) self.speech_thread_ = threading.Thread(target=self.speak_thread) self.speech_thread_.start() # 注意python的线程不会自己启动，需要手动开始 def novel_callback(self, msg): self.novel_queue.put(msg.data) def speak_thread(self): speaker = espeakng.Speaker() speaker.voice = &#x27;zh&#x27; while rclpy.ok(): # 检测当前ROS上下文是否ok；用于检查ROS2系统的运行状态，通常用于控制循环的执行，确保在系统关闭时能够优雅地退出。 if self.novel_queue.qsize() &gt; 0: text = self.novel_queue.get() self.get_logger().info(f&quot;朗读：&#123;text&#125;&quot;) speaker.say(text) speaker.wait() else: # 当朗读队列为空时 time.sleep(1) # 让该线程休眠1s def download(self, url): res = requests.get(url) res.encoding = &#x27;utf-8&#x27; text = res.text self.get_logger().info(f&quot;&#123;url&#125;,&#123;len(text)&#125;&quot;)def main(): rclpy.init() node = Novel_sub_Node(&quot;novel_sub&quot;) node.download(&quot;http://0.0.0.0:8000/novel1.txt&quot;) rclpy.spin(node) rclpy.shutdown() 学习收获： 认识了python中可以获取文字并朗读的库”espeakng”，使用”espeakng.Speaker()”可以创建一个espeakng实例。 学会创建订阅者和线程。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战_发布控制速度海龟画圈","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_发布控制速度海龟画圈/","text":"话题通信实战_发布控制速度海龟画圈核心要求： 如何让小海龟按着我的指令？话题 怎么画圆？线速度&#x2F;角速度&#x3D;半径 发一下就停，如何循环发？定时器 1.创建类 属性： 定时器 发布者的智能指针 方法： 定时发布控制信息的函数 【注】： 定时器声明代码： 1rclcpp::Publisher&lt;消息接口&gt;::SharedPtr 发布者实例名; 定时器创建代码： 1timer_ = this-&gt;create_wall_timer(间隔时长, 回调函数); “create_wall_timer()”也称为墙钟函数，它与一般的定时器函数相比使用的不是ros时间，而是系统时间。 2.完整代码： 123456789101112131415161718192021222324252627282930313233#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &lt;chrono&gt;using namespace std::chrono_literals;class TurtleCircleNode: public rclcpp::Node&#123;private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能指针public: explicit TurtleCircleNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleCircleNode::timer_callback,this)); &#125; void timer_callback()&#123; auto msg = geometry_msgs::msg::Twist(); msg.linear.x = 1.0; msg.angular.z = 0.5; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleCircleNode&gt;(&quot;turtleCircle&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 学习收获： 学会了墙钟定时器的声明和创建","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实训-订阅pose实现闭环控制","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_订阅pose实现闭环控制/","text":"话题通信实训-订阅pose实现闭环控制核心任务： 1. 小海龟怎么听我的？发布话题； 2. 小海龟现在在哪里？订阅话题； 3. 怎么根据当前位置和目标位置计算角速度和线速度？两点之间距离-&gt;线速度 当前朝向和目标朝向-&gt;角速度。 1.定义控制小海龟的类 属性： 发布者的智能指针 订阅者的智能指针 目标坐标点、比例系数（用于控制运行速度）、最大速度 方法： 获取当前位置，并计算新位置发布出去的函数 【注】： 不同于python，C++在创建实例前需要声明。以下是发布者和订阅者声明的代码： 12rclcpp::Publisher&lt;消息接口&gt;::SharedPtr publisher_; //发布者的智能共享指针rclcpp::Subscription&lt;消息接口&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 发布者和订阅者创建代码： 123publisher_ = this-&gt;create_publisher&lt;消息接口&gt;(&quot;话题名称&quot;,qos); //创建发布者subscriber_ = this-&gt;create_subscription&lt;消息接口&gt;(&quot;话题名称&quot;,qos,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); //创建订阅者 关于回调函数，这里采用的是将成员方法放入函数包装器中（其实用lambda函数更简单）。函数形式：std::bind(&amp;类节点实例化, 对象指针, 参数占位符))。”订阅者的话题名称”要与对应的发布者消息接口对应。 2.完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &quot;turtlesim/msg/pose.hpp&quot;#include &lt;chrono&gt;using namespace std::chrono_literals;class TurtleControlNode: public rclcpp::Node&#123;private: // rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能共享指针 rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 double target_x_&#123;1.0&#125;; double target_y_&#123;1.0&#125;; double k_&#123;1.0&#125;; //比例系数【间接控制速度】 double max_speed_&#123;3.0&#125;; //最大速度 public: explicit TurtleControlNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); // 这里传入运动控制的消息接口，由其发布控制信息给小海龟 subscriber_ = this-&gt;create_subscription&lt;turtlesim::msg::Pose&gt;(&quot;/turtle1/pose&quot;,10,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); // timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleControlNode::timer_callback,this)); &#125; // 获取当前位置，并计算新位置发布出去 void on_pose_received(const turtlesim::msg::Pose::SharedPtr pose)&#123; //参数：收到数据的共享指针 // 1.获取当前位置 auto current_x = pose-&gt;x; auto current_y = pose-&gt;y; RCLCPP_INFO(get_logger(),&quot;获取当前位置:x=%f,y=%f&quot;,current_x,current_y); // 2.计算当前海龟位置跟目标位置之间的距离差和角度差。 auto distanc e = std::sqrt((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y)); // 目标角度和当前角度的差值 auto angle = std::atan2((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta; // 3.控制策略 auto msg = geometry_msgs::msg::Twist(); if(distance&gt;0.1)&#123; if(fabs(angle)&gt;0.2)&#123; msg.angular.z = fabs(angle); //如果角度差大于0.2则改变角度(进行旋转) &#125;else&#123; msg.linear.x = k_*distance; //如果角度差不大，则提高速度 &#125; &#125; //限制最大线速度 if(msg.linear.x &gt; max_speed_)&#123; msg.linear.x = max_speed_; &#125; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleControlNode&gt;(&quot;turtle_control&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 学习收获： 学会了C++版本的发布者和订阅者的声明和创建。 在小海龟程序中，可以通过”urtlesim&#x2F;msg&#x2F;pose”接口来获取当前海龟位置，通过”geometry_msgs&#x2F;msg&#x2F;twist”接口来控制海龟的运动。 在关键字前添加”explicit”：防止类进行单参数隐式转换。即类的构造函数只有一个参数时，可以通过唯一的参数值来构造该类。 c++中的”::”：访问命名空间内的标识符，避免不同命名空间的同名冲突。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"Linux基础之环境变量","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_Linux环境变量/","text":"Linux基础之环境变量 ros2 命令就是通过环境变量来寻找功能包的。 printenv:可以用来打印环境变量。 printenv | grep 筛选内容：可以查找所选取的环境变量。 当出现报错“Package xx not found”时，可以检查AMENT_PREFIX_PATH下的lib是否有这个包。 AMENT_PREFIX_PATH（路径）的初始值是由默认脚本设置的，该默认脚本位置为:~&#x2F;.bashrc[该文件为隐藏文件]。 使用 ls -a可以查看当前目录下的隐藏文件。 “source &#x2F;opt&#x2F;ros&#x2F;jazzy&#x2F;setup.bash”语句用于设置环境变量。后面经常会用”source install&#x2F;setup.bash”来将colcon build生成的可执行文件写入Install文件中。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"使用功能包组织节点","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_使用功能包组织节点/","text":"使用功能包组织节点💖基本流程：命令行创建功能包-&gt;在功能包中创建节点-&gt;在set.up文件中进行配置-&gt;在xml文件中添加依赖信息（但是如果创建功能包时添加了–dependencies就不需要这步）-&gt;colcon build进行构建-&gt;source install&#x2F;setup.bash-&gt;“ros2 run 包名 文件名”运行文件 使用”ros2 pkg create demo_python_pkg –build-type ament_python –license Apache-2.0”可以创建Python功能包，如果不指定build-type，默认为C++类型功能包。【有时候还会有–dependencies等选项】 可以在第二级demo_python_pkg目录下新建节点文件。 在功能包中注册节点。[即在setup.py文件中添加节点函数在那一层] 打开功能包中的xml文件添加依赖信息。[添加“rclpy”] “colcon build”:功能包的构建。[支持软链接，会把原来的包复制一份，然后执行复制的那份，即在install里面的python3.12&#x2F;site-packages中最里面那个python_node.py] [注]：colcon build一般在工作空间的根目录下进行，可以使用“colcon build-packages-select 包名”对特定的包进行构建。 “source install&#x2F;setup.bash”：生成环境变量。[setup.bash脚本用于修改环境变量] [补]:”ros2 功能包名 节点名”：运行节点 7.export PYTHONPATH&#x3D;新位置:$PYTHONPATH”:临时修改参数的环境变量。[使用6就可以不用这个方法] 8.修改环境变量的几种方法： 手动修改，即使用第7点 自动修改，即使用第6点 9.如果希望节点能以”ros2 run 包名 节点名”的形式运行，创建类的时候需要对rclcpp&#x2F;rclpy中的Node进行继承。 关于C++和Python继承Node后，在main函数中的代码主要框架： C++： 1234567int main(int argc, char* argv)&#123; rclcpp::init(argc,argv); ... rclcpp::spin(创建的节点); rclcpp::shutdown(); return 0;&#125; Python： 12345def main: rclpy.init() ... rclpy.spin(节点) rclpy.shutdown()","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"多线程与回调函数","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_多线程与回调函数(Python版)/","text":"多线程与回调函数┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w 回调函数：把统计函数当作参数传递给下载函数，下载完成自己第一时间调用。 “threading.get_ident()”：可以得到线程编号(python中)；”this_thread.get_id()”：可以得到线程编号(c++中)。 “echo “文字” “&gt; 文件名,可生成对应文件,并将文字写入。 “python3 -m http.server”：启动python3的内置服务器。 一个程序默认是在一个线程中完成的，如果需要多个线程并行，则需要使用thread。 与python中的多线程不同，c++中的线程一旦创建就立刻运行，并阻塞当前进程，所以需要用”thread.detach()”将其与当前进程进行分离。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"编写第一个ROS节点","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_编写第一个C++节点&Python节点/","text":"编写第一个ROS节点ros中编写C++节点 当项目较小时，可以在终端中使用”g++ cpp文件名”，得到一个可执行文件，再使用“.&#x2F;可执行文件名”运行程序。 当项目较大时，使用CMake得到生成指令。过程：编写一个CMakeList.txt文件(文件名不能改)-&gt;使用cmake指令转化为Makefile文件-&gt;使用make指令转化为exe文件。 ros中编写Python节点1.直接编写后就可以使用”run 文件名”进行运行。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"有用的C++特性","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_常用的C++特性/","text":"有用的C++特性1.auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名字”) node的类型是自动推导的。 2.智能指针&#x2F;共享指针:专治占着内存不使用的程序。 指针.use_count()：得到指针引用次数。 指针.get():得到指向的内存地址。 指针-&gt;c_str():得到指针指向内存地址数据。 对象.函数(参数):直接通过对象访问成员 指针-&gt;函数(参数):通过指向对象的指针访问成员。 具体使用哪一个要看“访问者是对象本身，还是指向对象的指针”。 CPP的”colcon build”会添加到环境变量，所以没有source也能运行。(但最好还是build一下好) 💥3.lambda表达式(放在函数里面用)即换个语法写函数：capture list-(parameter list)&gt;return type{function body} 注:常用[&amp;](输入列表)-&gt;void{函数体}，其中void表示不返回 捕获列表可以为空，也可以使用默认捕获模式&amp;或者&#x3D;表示按引用或者值捕获所有外部变量。 💥4.函数包装器：统一自由函数、成员方法和Lambda函数 对于自由函数：std::function&lt;函数返回值(函数传入参数)&gt; 给该函数一个新名字 &#x3D; 原自由函数名; 对于lambda函数: 同自由函数; 对于成员方法【较复杂】： std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应函数的指针&#x2F;模板地址,对象的指针,参数数量占位符); or std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应创造的对象,类中要调用的方法,参数数量占位符); 注：关于绑定bind很好解决了调用成员函数必须要先创造一个成员函数的问题，它直接绑定了一个对象。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"补充一些基础编程知识","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/编程基础补充/","text":"补充一些基础编程知识1.每次修改代码文件后，需要重新colcon build构建再运行。 2.面向对象编程都可以创建类，类是对事物的封装。 3.对于继承：python： “from 父类所在文件 import 父类”; class 子类(父类): ; “.super().init(父类构造需要的参数)” :调用父类的init方法。 c++: class 子类 : public 父类 【例如】： 1Class PersonNode : public rclcpp::Node - 子类(const 参数类型 &amp;参数1,…):父类(const 参数类型 &amp;父类构造所需参数); 注：创建共享指针，”auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名”)” 注： 使用共享指针需要头文件 RCLCPP_INFO(节点名字-&gt;get_logger(),”要打印出来的文字信息”); 注意这个函数的参数形式。 传入时格式为”string”,输出时为”%s”,则可以在输出时加上”.c_str()进行强制转换”。【c_str():将str类型转换为c语言格式的字符串】 CPP文件中，有时候构造函数时会在传入参数前加上”const”（加在类型前）和”&amp;”（加在变量名前），加上前者是希望用户不要对传入的数据进行修改，加上后者(称为拷贝指针)是为了避免不必要的数据拷贝，以提高运行效率。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"话题通信介绍","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信介绍/","text":"话题通信介绍1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。 2.”ros2 node info &#x2F;节点名字”：查看接口定义。（有发布者以及订阅者等相关信息）【发布者下的内容格式：话题：消息接口】 3.”ros2 topic echo &#x2F;话题名字”：查看话题内容。 4.”ros2 topic info &#x2F;话题名字”：查看消息接口。 5.”ros2 interface show 消息接口”：找到消息接口的定义。 6.”ros2 topic pub &#x2F;话题名字 消息接口 消息接口样本格式的数据填充”:使用话题控制机器人。【使用订阅者话题】 注：消息接口样本格式的数据填充可以在”消息接口的定义”处查看，每下一个级别，需要加”{}”，参数名称后的”:”和自定义参数值之间需要加一个空格。 当自定义消息接口或者调用话题接口时常见步骤： “ros2 topic list -t”：返回话题及对应的消息接口。 “ros2 interface show 消息接口”：查消息接口的详细内容 | “ros2 interface proto 消息接口”：显示消息模板。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"","date":"2025-09-18T10:43:02.063Z","path":"2025/09/18/记录杂七杂八小问题/实现Ubuntu与主机之间复制粘贴/","text":"1.方法一：虚拟机顶部工具栏点击”虚拟机设置”-&gt;”选项”-&gt;”客户机隔离”勾选，再次启动Ubuntu。 2.方法二：使用Ubuntu命令 在终端中依次运行： 123sudo su- //进入管理员模式sudo apt-get install open-vm-tools open-vm-tools-desktop //安装命令vmware-user //开启服务 最后，重启虚拟机就可以实现跨平台复制粘贴。 3.方法三：（永久开启该服务） 编写service配置文件 1234567891011# /etc/systemd/system/vmware-user.service [Unit] Description=开机启动一次vmware-user After=network.target [Service] Type=oneshot ExecStart=vmware-user [Install] WantedBy=multi-user.target 重新加载systemd配置 1systemctl daemon-reload 设置开机自启动 1systemctl enable vmware-user 重启虚拟机后基本成功","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:26:06.144Z","path":"2025/09/18/ros2/工具/ros_git进阶/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:22:22.046Z","path":"2025/09/18/ros2/工具/ros_TF关系的查询/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:22:22.046Z","path":"2025/09/18/ros2/工具/ros_数据记录工具ros2 bag/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:22:22.046Z","path":"2025/09/18/ros2/工具/ros_动态TF的发布/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:22:22.046Z","path":"2025/09/18/ros2/工具/ros_TF相关命令及原理探究/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:22:22.046Z","path":"2025/09/18/ros2/工具/ros_常用可视化工具rqt&Rviz/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:22:22.046Z","path":"2025/09/18/ros2/工具/ros_静态TF的发布/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:19:04.986Z","path":"2025/09/18/ros2/服务通信/ros_launch进阶使用/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:19:04.986Z","path":"2025/09/18/ros2/服务通信/ros_使用launch启动多个节点/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:17:29.266Z","path":"2025/09/18/ros2/服务通信/ros_服务通信实训_人脸识别/","text":"","categories":[],"tags":[]},{"title":"","date":"2025-09-18T10:08:33.609Z","path":"2025/09/18/ros2/服务通信/ros_服务通信介绍/","text":"","categories":[],"tags":[]},{"title":"基本格式","date":"2025-09-18T08:28:11.787Z","path":"2025/09/18/基础相关/format/","text":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]},{"title":"Hello Hexo","date":"2025-09-18T08:02:00.000Z","path":"2025/09/18/基础相关/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Typora的基础使用方法","date":"2025-09-18T07:39:00.000Z","path":"2025/09/18/基础相关/Typora_use/","text":"注：在文件最前面输入”[“TOC”]”，自动生成可跳转的文件目录 [TOC] 一.关于标题这是二级标题笔记：关于快捷键【但我的电脑不知道为啥用不了】 1.Ctrl+数字1-6对应将选中文本调节至对应级别的标题。 2.Ctrl+0可以快速将选中的文本调成普通文本。 3.Ctrl+加号&#x2F;减号对标题级别进行调整。 4.“#”数量控制字体级别，注意”#”与标题间有一个空格。 二.关于换行1.“Shift”+“Enter”可以进行比”Shift”更小的换行。 2.“分割线”：“—”按回车或者”***”按回车。 三.文字显示1.关于字体（1）粗体：用一对双星号包裹 e.g：这是粗体 （2）剔除线：用一对双飘号包裹 e.g:这是剔除线 （3）下划线：用一对u标签(html)包裹 e.g:这是下划线 （4）斜体：用一对单星号包裹 e.g:这是斜体 （5）高亮：用一对双等号包裹 e.g：&#x3D;&#x3D;这是高亮&#x3D;&#x3D; 快捷键：(按双数次取消效果) 加粗：Ctrl+B删除线：Shift+Alt+5下划线：Ctrl+u斜体：Ctrl+i 注：反斜杠+星：解决星号不显示的问题 * 2.上下标(1)一对”^”：表示上标。 x^2^ (2)一对”“：表示下标。 H2~O 四.列表1.无序列表（1）同级序号 ctrl+Shift+”]”：进入序列，两次回车退出序列。 （2）子集序列:Ctrl+”]”：列表右缩进。 这是一级序列 这是二级序列 又变一级 2.有序列表（1）同级序号 ctrl+Shift+”[“：进入序列，两次回车退出序列。 (2) 子集序列：子集序列:Ctrl+”]”：列表右缩进。 3.任务列表 :无序列表符+”[ ]” 五.区块显示 :”英文箭头加回车”。 六.代码显示1.行内代码 int a =2;:用一对“&#96;”包裹。 2.代码块：Ctrl+Shift+K 123int a = 2;int b =3; 1#include &lt;iostream&gt; 七.链接哔哩哔哩：Ctrl+K [一.关于标题](# 一.关于标题)：关于文件内标题跳转，前面括号写显示内容，后面括号写入跳转标题(记得加上对应格式)；跳转的时候Ctrl+点击。 八.脚注文字^1 ：“[”+”^”想要脚注的文字+”]” 上面的实现：“[”+”^”想要脚注的文字+”]”:解释说明。 ​ 注意：上下想要脚注的文字的文字需要一致才能有脚注； ​ 冒号要用英文格式的； ​ “&lt;”br”&gt;”：可以实现回车。 九.图片插入![不显示只给写文件的人提醒的一段文字](图片路径 “图片标题”) 还可以拖拽进行添加图片 十.表格快捷键：Ctrl+T id name score 23 张三 99 3 李四 100 十一.表情符号:happy: 、:cry: 两个冒号间加对应英文；（win+. ：可以快速打开表情面板） 十二.数学公式输入$$x^2+(y+1)^2&#x3D;5$$","categories":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/categories/Typora/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"},{"name":"basic-Usage","slug":"basic-Usage","permalink":"http://example.com/tags/basic-Usage/"}]}]
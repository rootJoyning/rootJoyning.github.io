[{"title":"服务通信介绍","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_服务通信介绍/","text":"服务通信介绍1.”ros2 service list -t”：查看ros2的服务列表，返回内容具体格式:服务名称 消息接口&#x2F;服务接口类型。 2.”ros2 interface show 消息接口”：查看消息接口具体定义（消息填充）。 3.”ros2 service call 服务名称 消息接口 ‘{消息接口具体填充}’：调用具体服务。 【注】：消息接口的具体填充，”{参数1: 数值,参数2: 数值,…}”。冒号数值间有一个空格。4.可以使用ros2中的可视化工具rqt选取服务。（plugins-&gt;services-&gt;service caller中可以配置）。 5.参数被视为节点的设置，是基于服务通信实现的。 6.”ros2 param list”：查看ros2的参数列表。 7.”ros2 param describe 包名 参数名称”：查看参数的具体信息。 8.”ros2 param get 包名 参数名称”：获得参数的值。 9.”ros2 param set 包名 修改的参数名称 修改数值”：修改参数的值。 10.”ros2 param dump 包名 &gt; 配置文件(.yaml)”：将包现在的参数写入配置文件。 11.”ros2 run 包名 节点名 –ros-args –params-file 配置文件”：运行节点时就根据配置文件将节点配置。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_使用launch启动多个节点（基础版）","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_使用launch启动多个节点/","text":"使用launch启动多个节点1.使用launch启动多个节点： “generate_launch_description()”：产生launch描述【注意该函数名字是固定的】；其返回值也是固定的，返回actions动作(是一个数组)。 关于c++版本将launch文件写到install&#x2F;lib下，使用”install(DIRECTORY launch DESTINATION share&#x2F;${PROJECT_NAME})”。【更方便】 关于python版本将launch文件写到install&#x2F;lib下，使用” ‘share&#x2F;‘+package_name+’&#x2F;launch’,glob(‘launch&#x2F;*.launch.py’)” [注意]：上述操作需要引入globe包[from glob import glob]。 python中的glob函数：用于查找符合特定规则的文件，需要传入指定匹配的路径字符串，返回值为当前目录下满足条件的文件(不包含子目录下的)。 launch脚本的启动，”ros2 launch 包名 launch文件名”。 “source 路径”：将路径加入到系统环境变量中，相当于激活该区域。 2.使用launch传递参数： 声明一个launch参数：launch.actions.DeclareLaunchArgument(‘参数名字’,default_value&#x3D;”默认参数值”,(可选)description&#x3D;”给该参数一个备注”) 把launch的参数手动传给某节点： “launch.substitutions.LaunchConfiguration(‘参数名称’,”默认参数值”)”:对参数值进行替换。 在需要传入参数的节点处添加属性parameters&#x3D;[{节点参数名:launch.substitutions.LaunchConfiguration(‘参数名称’,default&#x3D;”默认参数值”)}]。3.运行的时候可以使用：ros2 launch 包名 launch文件名 自定义参数名:&#x3D;参数值。 3.launch三大组件(4.6.3) 动作：一个节点、一句打印、一段终端指令、另一个终端文件等 替换：使用launch的参数替换节点的参数值(未学) 条件：可以决定哪些节点启动，哪些不启动，相当于if(未学) 代码实例： 12345678910111213141516171819202122232425262728293031323334import launchimport launch_rosdef generate_launch_description(): # 生成launch描述【注意该函数名字是固定的】 # 1.声明一个launch函数 action_declare_arg_background_g = launch.actions.DeclareLaunchArgument(&#x27;bg_param&#x27;, default_value=&quot;150&quot;) action_node_turtle_client = launch_ros.actions.Node( # 传入包，可执行文件和日志输出的位置 package = &#x27;demo_cpp_service&#x27;, executable = &#x27;turtle_client&#x27;, output = &#x27;screen&#x27; ) action_node_turtle_control = launch_ros.actions.Node( # 传入包，可执行文件和日志输出的位置 package = &#x27;demo_cpp_service&#x27;, executable = &#x27;turtle_control&#x27;, output = &#x27;screen&#x27; ) # 2.把launch的参数手动传递给某个参数 &#x27;&#x27;&#x27;产生launch描述&#x27;&#x27;&#x27; action_node_turtle_node = launch_ros.actions.Node( # 传入包，可执行文件和日志输出的位置 package = &#x27;turtlesim&#x27;, executable = &#x27;turtlesim_node&#x27;, parameters =[&#123;&#x27;background_g&#x27;:launch.substitutions.LaunchConfiguration(&#x27;bg_param&#x27;,default=&quot;150&quot;)&#125;], output = &#x27;screen&#x27;, ) return launch.LaunchDescription([ action_node_turtle_client, action_node_turtle_control, action_node_turtle_node, ]) 【补充】： DeclareLaunchArgument(参数名称,default_name&#x3D;”默认取值”,description&#x3D;”参数的描述”)：声明launch文件可以修改的参数。【声明一个参数】 LaunchConfiguration(“在DeclareLaunchArgument中声明过的动态参数名称”)：在启动文件中用于动态配置参数、节点选项等的一种机制。可以在运行或者启动文件时灵活调整参数。一般与”DeclareLaunchArgument()”配套使用。【引用一个参数】 启动两个小海龟模拟器的例子： 12345678910111213141516171819202122232425262728293031import launchimport launch_rosfrom ament_index_python.packages import get_package_share_directory&quot;&quot;&quot;&quot;太诡异了这个代码OTZ&quot;&quot;&quot;def generate_launch_description(): # 这个动作实际上就是启动两个小海龟模拟器 # 动作1：启动其它launch action_launch_path = [get_package_share_directory(&#x27;turtlesim&#x27;),&#x27;/launch/&#x27;,&#x27;multisim.launch.py&#x27;] # 因为该launch文件在不同场景均需要启动，故可将其包含到不同的父launch文件中。 action_include_launch = launch.actions.IncludeLaunchDescription(launch.launch_description_sources.PythonLaunchDescriptionSource(action_launch_path)) # 动作2：打印这个路径 action_launch_info = launch.actions.LogInfo(msg=str(action_launch_path)) # 动作3：执行进程，即执行一个命令行 action_topic_list = launch.actions.ExecuteProcess(cmd=[&#x27;ros2&#x27;,&#x27;topic&#x27;,&#x27;list&#x27;]) # 动作4：组织动作成组，把多个动作放一个组 action_group = launch.actions.GroupAction([ # 动作5：定时器 launch.actions.TimerAction(period=2.0,actions=[action_include_launch]), launch.actions.TimerAction(period=4.0,actions=[action_topic_list]) ]) return launch.LaunchDescription([ # 执行顺序：打印路径--&gt;(执行动作组中的)启动两个小海龟模拟器--&gt;(执行动作组中的)执行一个命令行 action_launch_info, action_group ]) IncludeLaunchDescription()： 主要作用是包含其他Launch文件。 它是一个动作(launch.actions模块中的类)。 PythonLaunchDescriptionSource()： 是IncludeLaunchDescription()一个来源类，它指定所包含的launch文件是python格式的。 其它来源还包括XML和YAML格式。 上述两个函数一般结合使用：IncludeLaunchDescription(PythonLaunchDescriptionSource(…))，其应用场景有： 模块化启动：在大型项目中，可将不同功能节点拆分到多个launch文件中。使用IncludeLaunchDescription()将这些launch文件组合在一起。 复用已有launch文件：若某个launch文件在多个场景中均需要启动，可以将其包含在不同的父launch文件中。 传递函数：父launch文件通过launch_argument传递给子launch文件。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_C++服务通信实现小海龟巡逻","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_C++服务通信实现小海龟巡逻/","text":"C++服务通信实现小海龟巡逻需求：让小海龟在模拟器中随机游走进行巡逻。分析： 怎么让小海龟动态接收目标点？服务 用什么接口？自定义的 随机游走的实现？客户端来产生随机点，请求巡逻服务 整体框架图：客户端生成目标点，请求巡逻—（服务）–&gt;服务端规划路线，驾驶小海龟到达目标点—（话题）–&gt;小海龟【注】：一般编写程序，可以先把服务端程序完成。 注意： 自定义的接口上半部分请求是针对客户端；下半部分响应是针对服务端的。 srv接口文件对于未赋值变量要求小写，已赋值变量要求大写。【大概率是这样的了】 创建服务时传入的回调函数一般使用lambda表达式，比较方便。其中lambda表达式传入参数有两请求和响应两部分， 请求可以设置为const常量，而响应一般还需要进行后续修改故不设置成”const”。 python中的回调函数需要有返回值，因为python中传入的值是通过拷贝实现的；而c++中的回调函数不需要返回值，因为c++中传入的是指针。 1.自定义服务接口文件： 123456float32 target_xfloat32 target_y---int8 SUCCESS = 1int8 FAIL = 0int8 result # 结果在SUCCESS和FAIL中取其一 srv文件的上半部分为请求参数，下半部分为响应(返回)参数。 2.客户端实现步骤： 创建客户端和定时器; 定时产生目标点并请求服务端巡逻。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;chapt4_interfaces/srv/patrol.hpp&quot;#include &lt;chrono&gt;#include &lt;ctime&gt;// 将类重命名using Patrol = chapt4_interfaces::srv::Patrol;using namespace std::chrono_literals; // 使用命名空间std::chrono_literals[可以使用10s,100ms来表示时间]class TurtleClient: public rclcpp::Node&#123;private: // 声明定时器 rclcpp::TimerBase::SharedPtr timer_; // 声明客户端 rclcpp::Client&lt;Patrol&gt;::SharedPtr turtle_client; public: TurtleClient():Node(&quot;turtle_client&quot;)&#123; srand(time(NULL)); // 初始化随机种子 // 创建客户端 turtle_client = this-&gt;create_client&lt;Patrol&gt;(&quot;Patrol&quot;); // 创建定时器 timer_ = this-&gt;create_wall_timer(10s, [&amp;]()-&gt;void&#123; // 1.检测服务端是否上线 while(!this-&gt;turtle_client-&gt;wait_for_service(1s))&#123; // 服务端没有上线 if(!rclcpp::ok())&#123; // rclcpp没有准备好 RCLCPP_ERROR(this-&gt;get_logger(),&quot;等待服务上线中,rclcpp挂了&quot;); &#125; RCLCPP_INFO(this-&gt;get_logger(),&quot;等待服务上线中&quot;); &#125; // 2.构造请求对象 auto request = std::make_shared&lt;Patrol::Request&gt;(); request-&gt;target_x = rand()%15; request-&gt;target_y = rand()%15; // 3.发送请求 // 发送异步请求[请求 回调函数] this -&gt; turtle_client -&gt; async_send_request(request, [&amp;](rclcpp::Client&lt;Patrol&gt;::SharedFuture result_future)-&gt;void&#123; auto response = result_future.get(); if(response-&gt;result==Patrol::Response::SUCCESS)&#123; RCLCPP_INFO(this-&gt;get_logger(),&quot;请求成功！&quot;); &#125;if(response-&gt;result==Patrol::Response::FAIL)&#123; RCLCPP_INFO(this-&gt;get_logger(),&quot;请求失败！&quot;); &#125; &#125;); &#125;); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleClient&gt;(); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 3.服务端实现步骤： 定义基于Patrol类的服务共享指针、发布者的共享指针、订阅者的共享指针； 获取当前位置，并计算新位置发布出去。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &quot;turtlesim/msg/pose.hpp&quot;#include &quot;chapt4_interfaces/srv/patrol.hpp&quot;/*服务端编写：使小海龟到达具体点*/// 将类重命名using Patrol = chapt4_interfaces::srv::Patrol;class TurtleControlNode: public rclcpp::Node&#123;private: rclcpp::Service&lt;Patrol&gt;::SharedPtr patrol_service; // 定义基于Patrol类的服务共享指针 rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能共享指针 rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 double target_x_&#123;1.0&#125;; double target_y_&#123;1.0&#125;; double k_&#123;1.0&#125;; //比例系数【间接控制速度】 double max_speed_&#123;3.0&#125;; //最大速度public: explicit TurtleControlNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); subscriber_ = this-&gt;create_subscription&lt;turtlesim::msg::Pose&gt;(&quot;/turtle1/pose&quot;,10,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); // 服务智能指针的构造[服务名，回调函数(用lambda表达式实现)] patrol_service = this-&gt;create_service&lt;Patrol&gt;(&quot;Patrol&quot;,[&amp;](const Patrol::Request::SharedPtr request, Patrol::Response::SharedPtr response)-&gt;void&#123; // 进行请求值合法性判断 if((0 &lt; request-&gt;target_x &amp;&amp; request-&gt;target_x &lt; 12.0)&amp;&amp;(0 &lt; request-&gt;target_y &amp;&amp; request-&gt;target_y &lt; 12.0))&#123; target_x_ = request-&gt;target_x; target_y_ = request-&gt;target_y; response-&gt;result = Patrol::Response::SUCCESS; &#125;else&#123; response-&gt;result = Patrol::Response::FAIL; &#125; &#125;); // 作为服务的参数有两请求和响应两部分 &#125; // 获取当前位置，并计算新位置发布出去 void on_pose_received(const turtlesim::msg::Pose::SharedPtr pose)&#123; //参数：收到数据的共享指针 // 1.获取当前位置 auto current_x = pose-&gt;x; auto current_y = pose-&gt;y; RCLCPP_INFO(get_logger(),&quot;获取当前位置:x=%f,y=%f&quot;,current_x,current_y); // 2.计算当前海龟位置跟目标位置之间的距离差和角度差。 auto distance = std::sqrt((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y)); // 目标角度和当前角度的差值 auto angle = std::atan2((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta; // 3.控制策略 auto msg = geometry_msgs::msg::Twist(); if(distance&gt;0.1)&#123; if(fabs(angle)&gt;0.2)&#123; msg.angular.z = fabs(angle); //如果角度差大于0.2则改变角度(进行旋转) &#125;else&#123; msg.linear.x = k_*distance; //如果角度差不大，则提高速度 &#125; &#125; //限制最大线速度 if(msg.linear.x &gt; max_speed_)&#123; msg.linear.x = max_speed_; &#125; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleControlNode&gt;(&quot;turtle_control&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 这里还是需要回顾一下发布者（服务端）、订阅者（客户端）和服务的创建（声明就不讲了）。 发布者的创建： create_publisher&lt;模板类&gt;(): 参数列表：服务名称、qos； 返回值：发布者实例。 订阅者的创建： create_subscription&lt;模板类&gt;(): 参数列表：服务名称（这里应该与对应发布者中的服务名称对应）、qos、回调函数。 返回值：订阅者实例。 服务的创建： create_service&lt;模板类&gt;(): 参数列表：服务名称、回调函数。 返回值：服务实例。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_服务通信实训_人脸识别","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_服务通信实训_人脸识别/","text":"服务通信实训_人脸识别需求：使用python实现，创建一个人脸检测服务，提供图像，返回人脸数量位置信息。 难点分析： 人脸怎么识别？使用face_recognition 图片数据和结果怎么传递？使用服务通信 没有合适的消息接口？自定义一个 【分为请求和响应两部分】 1.自定义服务接口 消息接口文件命名不要使用”_”，而应该使用驼峰命名法； “os.path.join(路径1,路经2)“：将两个路径拼接起来，会自动加上”&#x2F;“； 使用”CV BRIDGE”将opencv下图片格式与ROS消息接口中的sensor_msgs&#x2F;Image文件互相转化； Facedetectors.srv文件的编写： 12345678sensor_msgs/Image image---int16 numberfloat32 use_time int32[] topint32[] rightint32[] bottomint32[] left 2.服务实现步骤： 创建服务，接受请求Request； 调用face_recognition来识别人脸; 处理响应结果合成Response返回。 服务器代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import rclpyfrom rclpy.node import Nodefrom chapt4_interfaces.srv import Facedetectorimport cv2 import face_recognitionfrom ament_index_python.packages import get_package_share_directory # 获得功能包share目录绝对路径import osfrom cv_bridge import CvBridgeimport time&#x27;&#x27;&#x27;人脸识别服务端&#x27;&#x27;&#x27;class FaceService(Node): def __init__(self): super().__init__(&#x27;face_service&#x27;) # 创建服务 参数：(服务类型，服务名称，回调函数) self.service = self.create_service(Facedetector,&#x27;face_detect&#x27;, self.detect_face_callback) self.cvbridge = CvBridge() # 主要用于ROS图像消息和opencv图像之间进行转换 self.declare_parameter(&#x27;upsample_flu&#x27;,3) self.declare_parameter(&#x27;model&#x27;,&#x27;hog&#x27;) self.default_path = os.path.join(get_package_share_directory(&quot;demo_python_service&quot;),&quot;resource/test/.png&quot;) self.upsample_flu = self.get_parameter(&#x27;upsample_flu&#x27;).value self.model= self.get_parameter(&#x27;model&#x27;).value self.get_logger().info(&quot;人脸识别！启动！！&quot;) # 服务器对用户上传的图片进行处理，以下为逻辑处理代码 def detect_face_callback(self, request, response): if(request.image.data): # 请求中有图像时 cv_img = self.cvbridge.imgmsg_to_cv2(request.image) # 将消息接口格式的图像文件转化为cv2能识别的图像文件 else: # 请求中没有图像时 cv_img = cv2.imread(self.default_path) # 此时的cv_img已经是opencv格式的图像了 self.get_logger().info(f&quot;默认图像位置：&#123;self.default_path&#125;&quot;) self.get_logger().info(f&quot;并未找到图片，已经加载到默认图像&quot;) start_time = time.time() # 获得人脸位置(即检测人脸)，传入参数(图像，上采样次数，使用模型)【关于上采样，其次数越高，图像精度也越高】 face_locations = face_recognition.face_locations(cv_img,self.upsample_flu,self.model) # 绘制人脸框 for top,bottom,right,left in face_locations: # 这里的top,bottom,right,left就是消息文件里定义的四个消息接口 response.top.append(top) response.bottom.append(bottom) response.right.append(right) response.left.append(left) response.use_time = time.time()-start_time # 消息接口里定义的use_time response.number = len(face_locations) #诶，这里face_locations数组的长度就是人脸的个数 return response # 因为传入的不是指针类型，故需要return一下def main(): rclpy.init() node = FaceService() rclpy.spin(node) rclpy.shutdown() 3.客户端实现步骤： 创建客户端； 构造Request,发送请求； 处理返回的Response,绘制人脸显示。 客户端代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import rclpyfrom rclpy.node import Nodefrom chapt4_interfaces.srv import Facedetectorimport cv2 import face_recognitionfrom ament_index_python.packages import get_package_share_directory # 获得功能包share目录绝对路径import osfrom cv_bridge import CvBridgeimport timeclass FaceClient(Node): def __init__(self): super().__init__(&#x27;face_client&#x27;) # 创建服务 参数：(消息接口，服务名称，回调函数) # self.service = self.create_service(Facedetector,&#x27;face_detect&#x27;, self.detect_face_callback) self.cvbridge = CvBridge() self.default_path = os.path.join(get_package_share_directory(&quot;demo_python_service&quot;),&quot;resource/test2.png&quot;) self.get_logger().info(&quot;人脸识别客户端！启动！！&quot;) # 创建客户端 参数：(服务类型，服务名称，回调函数)，注意这里传入的服务名称必须要与服务端一致 self.face_client = self.create_client(Facedetector,&#x27;face_detect&#x27;) self.image = cv2.imread(self.default_path) # 发送请求 def send_request(self): # 1.判断服务端是否上线 while self.face_client.wait_for_service(timeout_sec=0.1) is False: # 每隔0.1s就请求一下服务端 self.get_logger().info(&quot;服务端还未上线，请等待！&quot;) # 2.构造request request = Facedetector.Request() request.image = self.cvbridge.cv2_to_imgmsg(self.image) # 将opencv格式图像转化为消息接口可接受的图像格式 # 3.发送请求并等待完成 future = self.face_client.call_async(request) #(异步获取结果)现在的future中不包含响应结果，需要等待服务端处理完成才会把结果放到future中 # while not future.done(): # time.sleep(1.0) # 休眠当前进程，等待服务处理完成.会造成当前线程无法再接收服务端的返回，这样永远也不会得到future.done()--&gt;True # self可以相当于自定义类的一个对象 # rclpy.spin_until_future_complete(self,future) # 一边查看future是否完成，一边接收结果【等待服务端返回响应】 # 使用回调函数代替上面的方法 def result_callback(result_future): response = result_future.result() # 获取响应 self.get_logger().info(f&quot;已经收到响应，共收到&#123;response.number&#125;张人脸，耗时&#123;response.use_time&#125;秒&quot;) self.show_response(response) future.add_done_callback(result_callback) # 显示服务端的响应结果 def show_response(self, response): # 绘制人脸 for i in range(response.number): top = response.top[i] right= response.right[i] bottom = response.bottom[i] left = response.left[i] cv2.rectangle(self.image,(left,top),(right,bottom),(255,0,0),5) # 显示图片 cv2.imshow(&#x27;face_result&#x27;,self.image) cv2.waitKey(0) # 也是会阻塞spin的，使其无法正常运行def main(): rclpy.init() node = FaceClient() node.send_request() rclpy.spin(node) rclpy.shutdown() [注意]： ​ 1.python中不使用”!”取反，而直接使用”is False”or”not”。​ 2.发送请求并等待结果的过程处理，不要使用while进行简单处理，最好使用rclpy.spin_until_future_complete(参数) # 一边查看future是否完成，一边接收结果。​ 其中参数为调用call_async()返回的结果。​ 3.对于解决客户端发送请求响应更好的解决办法，可以采用回调函数（具体见face_client.py）​ 即让call_async()返回的结果调用add_done_callback()，里面放入回调函数，回调函数负责获取响应和显示响应。 一些关于在python的同步代码中调用异步函数： 当需要在同步函数中调用异步函数时，可以使用”asyncio.get_event_loop()”：来获取当前时间的循环； “asyncio.run_coroutine_threadsafe(异步函数，当前时间循环)”：将异步函数包装成一个可调用的线程安全的协程对象； “result()”：获取异步函数的返回值。 示例代码： 1234567891011import asyncio# 异步函数async def async_function(): await asyncio.sleep(1) # 模拟异步操作 return &quot;hello ros2&quot;#同步函数def sync_function(): loop = asyncio.get_event_loop() # 获取当前时间循环 future = asyncio.run_coroutine_threadsafe(async_function,loop) # 将异步函数包装成一个可调用的协程对象 result = future.result() 但在处理异步函数时，可能会出现异常情况。以下是应对措施： 常在”asyncio.run_coroutine_threadsafe()”的返回值上调用”add_done_callback(回调函数)”，该回调函数会在异步函数处理完后被调用，可以在里面处理异常。 1234567891011121314151617import asyncio# 异步函数async def async_function(): await asyncio.sleep(1) # 模拟异步操作 return &quot;hello ros2&quot;#同步函数def sync_function(): loop = asyncio.get_event_loop() # 获取当前时间循环 future = asyncio.run_coroutine_threadsafe(async_function,loop) # 将异步函数包装成一个可调用的协程对象 def callback(f): try: result = f.result() except Exception as e: print(f&quot;An Exception error:&#123;e&#125;&quot;) future.add_done_callback(callback) [补充]： 关于python中的异常捕获，常用如下结构： try: ​ … except Exception as e: ​ … 关于C++中的异常捕获，常用如下结构： try{ ​ … }catch(Exception e){ ​ … } python语言编写项目时，resource下的文件不会由”colcon build”拷贝到install下的share目录中，需要在setup.py文件的data_files中添加。添加语句：**(“share&#x2F;“ + package_name+”&#x2F;resource”,[“文件名”])**。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_TF关系的查询","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_TF关系的查询/","text":"ros_TF关系的查询1.原理：订阅话题&#x2F;tf &#x2F;tf_static 收集所有坐标系关系，进行计算。 2.核心代码： self.buffer_ &#x3D; Buffer() self.listener_ &#x3D; TransformListener(self.buffer_,self) self.timer_ &#x3D; self.create_timer(1,self.get_transform) [注]：其中self.get_transform是自定义的用于实时查询坐标关系的函数（因为可能会查询失败，故使用try…except）。 3.代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/transform_stamped.hpp&quot; // 消息接口#include &quot;tf2/LinearMath/Quaternion.hpp&quot; // 提供Quaternion类#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot; // 消息类型转换函数#include &quot;tf2_ros/transform_listener.h&quot; //坐标监听类#include &lt;chrono&gt;#include &quot;tf2_ros/buffer.h&quot; // 提供buffer#include &quot;tf2/utils.h&quot; //提供四元数转欧拉角的函数 // map到base_link之间的坐标关系using namespace std::chrono_literals;using dynamic_tf = tf2_ros::TransformListener;using bf = tf2_ros::Buffer;class DynamicTfListener : public rclcpp::Node&#123;private: std::shared_ptr&lt;dynamic_tf&gt; listener_; // 声明一个广播器类的共享指针 rclcpp::TimerBase::SharedPtr timer_; std::shared_ptr&lt;bf&gt; buffer_;public: DynamicTfListener() : Node(&quot;listener_node&quot;)&#123; // 定时获取坐标变换 this-&gt;timer_ = this-&gt;create_wall_timer(1s,std::bind(&amp;DynamicTfListener::get_transform,this)); this-&gt;buffer_ = std::make_shared&lt;bf&gt;(this-&gt;get_clock()); this-&gt;listener_= std::make_shared&lt;dynamic_tf&gt;(*buffer_, this); // 在dynamic_tf里面创建一个发布者来发布tf_static的话题 &#125; void get_transform()&#123; // 到buffer_里查询坐标关系 try&#123; // 查询坐标关系[从&quot;target_point&quot;到&quot;base_link&quot;] const auto result = buffer_-&gt;lookupTransform(&quot;base_link&quot;,&quot;target_point&quot;, this-&gt;get_clock()-&gt;now(),rclcpp::Duration::from_seconds(2.0f)); // 获取查询结果 auto transform = result.transform.translation; auto rotation = result.transform.rotation; // 这个rotation是四元数格式 double y, p, r; tf2::getEulerYPR(rotation, y, p, r); RCLCPP_INFO(get_logger(),&quot;平移:%f,%f,%f&quot;,transform.x, transform.y, transform.z); RCLCPP_INFO(get_logger(),&quot;旋转:y:%f,p:%f,r:%f&quot;, y, p, r); &#125; catch(const std::exception&amp; e)&#123; RCLCPP_WARN(get_logger(),&quot;%s&quot;,e.what()); &#125; &#125;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc,argv); auto stb = std::make_shared&lt;DynamicTfListener&gt;(); rclcpp::spin(stb); rclcpp::shutdown();&#125;","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_git进阶","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_git进阶/","text":"ros_git进阶 “git status”:可以查看修改的文件名。 “git diff” or “git diff 文件名”:可以查看具体修改内容。 还可以在vscode中的”源代码管理”下可视化查看修改的文件和内容。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_动态TF的发布","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_动态TF的发布/","text":"动态TF的发布原理：不停发布 &#x2F;tf 话题 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/transform_stamped.hpp&quot; // 消息接口#include &quot;tf2/LinearMath/Quaternion.hpp&quot; // 提供Quaternion类#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot; // 消息类型转换函数#include &quot;tf2_ros/transform_broadcaster.h&quot; //坐标广播器#include &lt;chrono&gt;// map到base_link之间的坐标关系using namespace std::chrono_literals;using dynamic_tf = tf2_ros::TransformBroadcaster;class DynamicTfBc : public rclcpp::Node&#123;private: std::shared_ptr&lt;dynamic_tf&gt; broadcaster_; // 声明一个广播器类的共享指针 rclcpp::TimerBase::SharedPtr timer_;public: DynamicTfBc() : Node(&quot;dynamic_node&quot;)&#123; // ??????这里为啥一个有this-&gt; ,一个没有this-&gt;（哦哦，是因为create_wall_timer是在rclcpp::Node节点里的，而我们创建的类刚好继承了Node） this-&gt;broadcaster_ = std::make_shared&lt;dynamic_tf&gt;(this); // 在dynamic_tf里面创建一个发布者来发布tf_static的话题 // this-&gt;publish_tf(); //静态发布，只能发布一次 //参数： (类模板，对象指针) this-&gt;timer_ = this-&gt;create_wall_timer(100ms,std::bind(&amp;DynamicTfBc::publish_tf,this)); &#125; void publish_tf()&#123; // 创建消息接口 geometry_msgs::msg::TransformStamped tf; tf.header.stamp = this-&gt;get_clock()-&gt;now(); tf.header.frame_id = &quot;map&quot;; tf.child_frame_id = &quot;base_link&quot;; // 给平移部分赋值 tf.transform.translation.x = 2.0; tf.transform.translation.y = 3.0; tf.transform.translation.z = 0.0; // 定义一个四元数类 tf2::Quaternion q; // 把已知欧拉角度转成四元数 q.setRPY(0.0, 0.0, 30*M_PI/180); // 给旋转部分赋值 tf.transform.rotation = tf2::toMsg(q); // 把消息发布出去 this-&gt;broadcaster_-&gt;sendTransform(tf); &#125;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc,argv); auto stb = std::make_shared&lt;DynamicTfBc&gt;(); rclcpp::spin(stb); rclcpp::shutdown();&#125; 不同于静态坐标只用发布一次，动态坐标需要一个定时器，不断的发送坐标。 静态和动态坐标的发布，核心逻辑都是先创建消息接口，再填充消息接口，最后把消息发布出去。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_TF相关命令及原理探究","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_TF相关命令及原理探究/","text":"ros_TF相关命令及原理探究以下均是终端内输入的命令 1.TF工具的简单介绍 通过命令行使用TF：（e.g） 发布base_link到base_laser之间的变换:ros2 run tf2_ros static_transform_publisher –x 值 –y 值 -z 值 –roll 值 –pitch 值 –yaw 值 –frame-id id值 –child-frame-id id值。 ​ **[注]**：roll:翻滚 pitch:俯仰 yaw:偏航 发布base_laser到wall_point之间的变换:ros2 run2 tf2_ros static_transform_publisher –x 值 –y 值 -z 值–roll 值 –pitch 值 –yaw 值 –frame-id id值 –child-frame-id id值。 查询base_link到wall_point之间的关系：ros2 run tf2_ros tf2_echo id值1 id值2。 “3d-rotation-converter”：可以对坐标变化过程进行可视化。 “ros2 run tf2_tools view_frames”:查看TF树。 2. TF原理探究 ros2 topic list -t：查询话题及其对应接口。 ros2 interface show 接口：接口详细填充展示。 static_transform_publisher适合于查询雷达这种固定物件相较于机器人的位置关系。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_静态TF的发布","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_静态TF的发布/","text":"ros_静态TF的发布从机械臂底座到相机–&gt;使用静态TF发布 原理：发布 &#x2F;tf_static话题。 使用transform3d库可以让四元数和欧拉坐标相互转换。 [注]：关于为什么静态TF只发布一次，但之后再去订阅还有消息？原因就在于tf_static每发布一次就会永久保留当前最新数据，当下次有订阅者订阅时还可以有内容发布。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/transform_stamped.hpp&quot; // 消息接口#include &quot;tf2/LinearMath/Quaternion.hpp&quot; // 提供Quaternion类#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot; // 消息类型转换函数#include &quot;tf2_ros/static_transform_broadcaster.h&quot; //静态坐标广播器// map到target_point之间的坐标关系using static_tf = tf2_ros::StaticTransformBroadcaster;class StaticTfBc : public rclcpp::Node&#123;private: std::shared_ptr&lt;static_tf&gt; broadcaster_; // 声明一个广播器类的共享指针public: StaticTfBc() : Node(&quot;static_node&quot;)&#123; this-&gt;broadcaster_ = std::make_shared&lt;static_tf&gt;(this); // 在static_tf里面创建一个发布者来发布tf_static的话题 this-&gt;publish_tf(); //静态发布，只能发布一次 &#125; void publish_tf()&#123; // 创建消息接口 geometry_msgs::msg::TransformStamped tf; tf.header.stamp = this-&gt;get_clock()-&gt;now(); tf.header.frame_id = &quot;map&quot;; tf.child_frame_id = &quot;target_point&quot;; // 给平移部分赋值 tf.transform.translation.x = 5.0; tf.transform.translation.y = 3.0; tf.transform.translation.z = 0.0; // 定义一个四元数类 tf2::Quaternion q; // 把已知欧拉角度转成四元数 q.setRPY(0.0, 0.0, 60*M_PI/180); // 给旋转部分赋值 tf.transform.rotation = tf2::toMsg(q); // 把消息发布出去 this-&gt;broadcaster_-&gt;sendTransform(tf); &#125;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc,argv); auto stb = std::make_shared&lt;StaticTfBc&gt;(); rclcpp::spin(stb); rclcpp::shutdown();&#125; “四元数.setRPY(x,y,z)”：将传入的欧拉角度(弧度制)转换为四元数。 静态坐标的发布用到了静态坐标广播器。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_常用可视化工具rqt&Rviz和数据记录工具ros2 bag","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_常用可视化工具rqt&Rviz和数据记录工具ros2 bag/","text":"常用可视化工具rqt&amp;Rviz和数据记录工具ros2 bag 在终端中输入”rviz2”可以启动该工具。 “ros2 bag record 订阅的话题名字”：可以记录下话题，方便下次重播。 “ros2 bag play 记录的文件名”：可以播放记录的文件。 【未成功实践版】","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"","date":"2025-09-19T13:17:16.591Z","path":"2025/09/19/ros2/仿真/ros_使用URDF创建机器人/","text":"1.帮机器人创建一个身体 URDF使用XML来描述机器人的几何结构、传感器和执行器等信息。 e.g：下述代码定义了一个名为first_robot的机器人，该机器人有一个base_link的部件。 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;robot name=&quot;first_robot&quot;&gt; &lt;!--XML注释--&gt; &lt;link name=&quot;base_link&quot;&gt;&lt;/link&gt;&lt;/robot&gt;","categories":[],"tags":[]},{"title":"Linux基础之环境变量","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_Linux环境变量/","text":"Linux基础之环境变量 ros2 命令就是通过环境变量来寻找功能包的。 printenv:可以用来打印环境变量。 printenv | grep 筛选内容：可以查找所选取的环境变量。 当出现报错“Package xx not found”时，可以检查AMENT_PREFIX_PATH下的lib是否有这个包。 AMENT_PREFIX_PATH（路径）的初始值是由默认脚本设置的，该默认脚本位置为:~&#x2F;.bashrc[该文件为隐藏文件]。 使用 ls -a可以查看当前目录下的隐藏文件。 “source &#x2F;opt&#x2F;ros&#x2F;jazzy&#x2F;setup.bash”语句用于设置环境变量。后面经常会用”source install&#x2F;setup.bash”来将colcon build生成的可执行文件写入Install文件中。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"使用功能包组织节点","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_使用功能包组织节点/","text":"使用功能包组织节点💖基本流程：命令行创建功能包-&gt;在功能包中创建节点-&gt;在set.up文件中进行配置-&gt;在xml文件中添加依赖信息（但是如果创建功能包时添加了–dependencies就不需要这步）-&gt;colcon build进行构建-&gt;source install&#x2F;setup.bash-&gt;“ros2 run 包名 文件名”运行文件 使用”ros2 pkg create demo_python_pkg –build-type ament_python –license Apache-2.0”可以创建Python功能包，如果不指定build-type，默认为C++类型功能包。【有时候还会有–dependencies等选项】 可以在第二级demo_python_pkg目录下新建节点文件。 在功能包中注册节点。[即在setup.py文件中添加节点函数在那一层] 打开功能包中的xml文件添加依赖信息。[添加“rclpy”] “colcon build”:功能包的构建。[支持软链接，会把原来的包复制一份，然后执行复制的那份，即在install里面的python3.12&#x2F;site-packages中最里面那个python_node.py] [注]：colcon build一般在工作空间的根目录下进行，可以使用“colcon build-packages-select 包名”对特定的包进行构建。 “source install&#x2F;setup.bash”：生成环境变量。[setup.bash脚本用于修改环境变量] [补]:”ros2 功能包名 节点名”：运行节点 7.export PYTHONPATH&#x3D;新位置:$PYTHONPATH”:临时修改参数的环境变量。[使用6就可以不用这个方法] 8.修改环境变量的几种方法： 手动修改，即使用第7点 自动修改，即使用第6点 9.如果希望节点能以”ros2 run 包名 节点名”的形式运行，创建类的时候需要对rclcpp&#x2F;rclpy中的Node进行继承。 关于C++和Python继承Node后，在main函数中的代码主要框架： C++： 1234567int main(int argc, char* argv)&#123; rclcpp::init(argc,argv); ... rclcpp::spin(创建的节点); rclcpp::shutdown(); return 0;&#125; Python： 12345def main: rclpy.init() ... rclpy.spin(节点) rclpy.shutdown()","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"多线程与回调函数","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_多线程与回调函数(Python版)/","text":"多线程与回调函数┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w 回调函数：把统计函数当作参数传递给下载函数，下载完成自己第一时间调用。 “threading.get_ident()”：可以得到线程编号(python中)；”this_thread.get_id()”：可以得到线程编号(c++中)。 “echo “文字” “&gt; 文件名,可生成对应文件,并将文字写入。 “python3 -m http.server”：启动python3的内置服务器。 一个程序默认是在一个线程中完成的，如果需要多个线程并行，则需要使用thread。 与python中的多线程不同，c++中的线程一旦创建就立刻运行，并阻塞当前进程，所以需要用”thread.detach()”将其与当前进程进行分离。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"有用的C++特性","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_常用的C++特性/","text":"有用的C++特性1.auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名字”) node的类型是自动推导的。 2.智能指针&#x2F;共享指针:专治占着内存不使用的程序。 指针.use_count()：得到指针引用次数。 指针.get():得到指向的内存地址。 指针-&gt;c_str():得到指针指向内存地址数据。 对象.函数(参数):直接通过对象访问成员 指针-&gt;函数(参数):通过指向对象的指针访问成员。 具体使用哪一个要看“访问者是对象本身，还是指向对象的指针”。 CPP的”colcon build”会添加到环境变量，所以没有source也能运行。(但最好还是build一下好) 💥3.lambda表达式(放在函数里面用)即换个语法写函数：capture list-(parameter list)&gt;return type{function body} 注:常用[&amp;](输入列表)-&gt;void{函数体}，其中void表示不返回 捕获列表可以为空，也可以使用默认捕获模式&amp;或者&#x3D;表示按引用或者值捕获所有外部变量。 💥4.函数包装器：统一自由函数、成员方法和Lambda函数 对于自由函数：std::function&lt;函数返回值(函数传入参数)&gt; 给该函数一个新名字 &#x3D; 原自由函数名; 对于lambda函数: 同自由函数; 对于成员方法【较复杂】： std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应函数的指针&#x2F;模板地址,对象的指针,参数数量占位符); or std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应创造的对象,类中要调用的方法,参数数量占位符); 注：关于绑定bind很好解决了调用成员函数必须要先创造一个成员函数的问题，它直接绑定了一个对象。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"补充一些基础编程知识","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/编程基础补充/","text":"补充一些基础编程知识1.每次修改代码文件后，需要重新colcon build构建再运行。 2.面向对象编程都可以创建类，类是对事物的封装。 3.对于继承：python： “from 父类所在文件 import 父类”; class 子类(父类): ; “.super().init(父类构造需要的参数)” :调用父类的init方法。 c++: class 子类 : public 父类 【例如】： 1Class PersonNode : public rclcpp::Node - 子类(const 参数类型 &amp;参数1,…):父类(const 参数类型 &amp;父类构造所需参数); 注：创建共享指针，”auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名”)” 注： 使用共享指针需要头文件 RCLCPP_INFO(节点名字-&gt;get_logger(),”要打印出来的文字信息”); 注意这个函数的参数形式。 传入时格式为”string”,输出时为”%s”,则可以在输出时加上”.c_str()进行强制转换”。【c_str():将str类型转换为c语言格式的字符串】 CPP文件中，有时候构造函数时会在传入参数前加上”const”（加在类型前）和”&amp;”（加在变量名前），加上前者是希望用户不要对传入的数据进行修改，加上后者(称为拷贝指针)是为了避免不必要的数据拷贝，以提高运行效率。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"git命令基础入门","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_git入门/","text":"git命令基础入门 克隆仓库 12git clone 地址cd repo 创建新分支 1git checkout -b new-feature 暂存文件：将修改过的文件添加到暂存区 12git add 文件名git add . # 添加所有修改的文件 提交更改：将暂存区的更改提交到本地仓库 1git commit -m &quot;附加信息&quot; 拉取最新更改：在推送本地之前，最好从远程仓库拉取最新的更改，以免冲突 12git pull origin maingit pull origin new-feature #添加在新的分支上 合并更改：在PR审核过合并后，可以将远程仓库的主分支合并在本地分支 123git checkout maingit pull origin maingit merge new-feature 删除分支 12git branch -d new-featuregit push origin --delete new-feature [接下来是基础但较有用的功能] git status：查看仓库当前状态，显示有变更的文件。 git diff：比较文件的不同，即暂存区和工作区的差异。 git difftool：使用外部工具比较文件差异。 git reset：回退版本（即把暂存区的文件撤出）。 git rm：将文件从暂存区和工作区删除。 git mv：移动或者重命名工作区文件。 git notes：添加注释。 git checkout：分支切换。|git switch：更清晰的分支切换。 git restore：恢复或撤销文件更改。 git show：显示git对象详细信息。 git log：查看历史提交记录。 git blame ：以列表形式查看指定文件的历史修改记录。 关于远程操作： git remove：远程仓库操作。 git fetch：从远程获得代码。 git pull：下载远程代码并合并。 git push：上传远程代码并合并。 git submodule：管理包含其他Git仓库的项目。 关于git忽略文件的命令 123git add .gitinore (在gitinore文件中添加不需要加入缓冲区的文件)git commit -m &quot;注释&quot;：添加忽略文件；rm -rf .git ：删除 .git目录。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信介绍","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信介绍/","text":"话题通信介绍1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。 2.”ros2 node info &#x2F;节点名字”：查看接口定义。（有发布者以及订阅者等相关信息）【发布者下的内容格式：话题：消息接口】 3.”ros2 topic echo &#x2F;话题名字”：查看话题内容。 4.”ros2 topic info &#x2F;话题名字”：查看消息接口。 5.”ros2 interface show 消息接口”：找到消息接口的定义。 6.”ros2 topic pub &#x2F;话题名字 消息接口 消息接口样本格式的数据填充”:使用话题控制机器人。【使用订阅者话题】 注：消息接口样本格式的数据填充可以在”消息接口的定义”处查看，每下一个级别，需要加”{}”，参数名称后的”:”和自定义参数值之间需要加一个空格。 当自定义消息接口或者调用话题接口时常见步骤： “ros2 topic list -t”：返回话题及对应的消息接口。 “ros2 interface show 消息接口”：查消息接口的详细内容 | “ros2 interface proto 消息接口”：显示消息模板。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"编写第一个ROS节点","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_编写第一个C++节点&Python节点/","text":"编写第一个ROS节点ros中编写C++节点 当项目较小时，可以在终端中使用”g++ cpp文件名”，得到一个可执行文件，再使用“.&#x2F;可执行文件名”运行程序。 当项目较大时，使用CMake得到生成指令。过程：编写一个CMakeList.txt文件(文件名不能改)-&gt;使用cmake指令转化为Makefile文件-&gt;使用make指令转化为exe文件。 ros中编写Python节点1.直接编写后就可以使用”run 文件名”进行运行。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"话题通信实训-订阅pose实现闭环控制","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_订阅pose实现闭环控制/","text":"话题通信实训-订阅pose实现闭环控制核心任务： 1. 小海龟怎么听我的？发布话题； 2. 小海龟现在在哪里？订阅话题； 3. 怎么根据当前位置和目标位置计算角速度和线速度？两点之间距离-&gt;线速度 当前朝向和目标朝向-&gt;角速度。 1.定义控制小海龟的类 属性： 发布者的智能指针 订阅者的智能指针 目标坐标点、比例系数（用于控制运行速度）、最大速度 方法： 获取当前位置，并计算新位置发布出去的函数 【注】： 不同于python，C++在创建实例前需要声明。以下是发布者和订阅者声明的代码： 12rclcpp::Publisher&lt;消息接口&gt;::SharedPtr publisher_; //发布者的智能共享指针rclcpp::Subscription&lt;消息接口&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 发布者和订阅者创建代码： 123publisher_ = this-&gt;create_publisher&lt;消息接口&gt;(&quot;话题名称&quot;,qos); //创建发布者subscriber_ = this-&gt;create_subscription&lt;消息接口&gt;(&quot;话题名称&quot;,qos,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); //创建订阅者 关于回调函数，这里采用的是将成员方法放入函数包装器中（其实用lambda函数更简单）。函数形式：std::bind(&amp;类节点实例化, 对象指针, 参数占位符))。”订阅者的话题名称”要与对应的发布者消息接口对应。 2.完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &quot;turtlesim/msg/pose.hpp&quot;#include &lt;chrono&gt;using namespace std::chrono_literals;class TurtleControlNode: public rclcpp::Node&#123;private: // rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能共享指针 rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 double target_x_&#123;1.0&#125;; double target_y_&#123;1.0&#125;; double k_&#123;1.0&#125;; //比例系数【间接控制速度】 double max_speed_&#123;3.0&#125;; //最大速度 public: explicit TurtleControlNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); // 这里传入运动控制的消息接口，由其发布控制信息给小海龟 subscriber_ = this-&gt;create_subscription&lt;turtlesim::msg::Pose&gt;(&quot;/turtle1/pose&quot;,10,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); // timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleControlNode::timer_callback,this)); &#125; // 获取当前位置，并计算新位置发布出去 void on_pose_received(const turtlesim::msg::Pose::SharedPtr pose)&#123; //参数：收到数据的共享指针 // 1.获取当前位置 auto current_x = pose-&gt;x; auto current_y = pose-&gt;y; RCLCPP_INFO(get_logger(),&quot;获取当前位置:x=%f,y=%f&quot;,current_x,current_y); // 2.计算当前海龟位置跟目标位置之间的距离差和角度差。 auto distanc e = std::sqrt((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y)); // 目标角度和当前角度的差值 auto angle = std::atan2((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta; // 3.控制策略 auto msg = geometry_msgs::msg::Twist(); if(distance&gt;0.1)&#123; if(fabs(angle)&gt;0.2)&#123; msg.angular.z = fabs(angle); //如果角度差大于0.2则改变角度(进行旋转) &#125;else&#123; msg.linear.x = k_*distance; //如果角度差不大，则提高速度 &#125; &#125; //限制最大线速度 if(msg.linear.x &gt; max_speed_)&#123; msg.linear.x = max_speed_; &#125; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleControlNode&gt;(&quot;turtle_control&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 学习收获： 学会了C++版本的发布者和订阅者的声明和创建。 在小海龟程序中，可以通过”urtlesim&#x2F;msg&#x2F;pose”接口来获取当前海龟位置，通过”geometry_msgs&#x2F;msg&#x2F;twist”接口来控制海龟的运动。 在关键字前添加”explicit”：防止类进行单参数隐式转换。即类的构造函数只有一个参数时，可以通过唯一的参数值来构造该类。 c++中的”::”：访问命名空间内的标识符，避免不同命名空间的同名冲突。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战_自定义实现实时状态信息查询小工具","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_自定义实现实时状态信息查询小工具/","text":"话题通信实战_自定义实现实时状态信息查询小工具需求： 通过该工具可以看到系统的实时状态信息，包括记录信息的时间、主机名称、cpu使用率、内存使用率、内存总大小、剩余内存、网络接收数据量和网络发送数据量。 要有一个简单的界面，可以将系统信息显示出来。 要能在局域网内其他主机上查看数据。 分析： 要能获取系统状态信息–&gt;python库psutils; 要有一个展示界面–&gt;QT; 要能共享数据–&gt;ROS2话题。总体架构：&#x2F;sys_status_pub—-&gt;&#x2F;sys_status—&gt;&#x2F;sys_status_display 步骤： 1. 自定义通信接口【注】： builtin_interfaces()：提供时间戳； 按照需求编写一个.msg的接口文件。注意：msg文件的命名必须使用驼峰命名法。 需要在对应的CMakeList.txt文件中添加rosidl_generate_interfaces()，其为cmake函数，用于将msg消息接口定义文件转化为库或者头文件类。 具体实现： 123rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/SystemStatus.msg&quot; DEPENDENCIES builtin_interfaces 代码实现： 1234567builtin_interfaces/Time stamp #记录时间戳string host_name #主机名float32 memory_percent #主存使用率float32 cpu_percent #CPU使用率float32 memory_available #主存剩余率float64 net_send #网络发送率float64 net_recv #网络接收率 2. 系统信息获取和发布【注】：使用psutils和platform两个库主要用于获取信息；其中psutil库可以查询cpu利用率、内存情况和网络输出输入情况等。platform库用于查询主机名字等。 代码实现： 1234567891011121314151617181920212223242526272829303132333435import rclpyfrom rclpy.node import Nodefrom status_interfaces.msg import SystemStatusimport psutilimport platformclass SystemStatusPub(Node): def __init__(self, node_name): super().__init__(node_name) self.status_publisher_ = self.create_publisher(SystemStatus, &#x27;sys_status&#x27;, 10) self.time_ = self.create_timer(1.0, self.timer_callback) def timer_callback(self): cup_percent = psutil.cpu_percent() memory_info = psutil.virtual_memory() # 查看当前内存情况 net_io_counters = psutil.net_io_counters() # 查看网络输入输出情况 msg = SystemStatus() # 自定义的通信接口经过一系列操作变成了类 msg.stamp = self.get_clock().now().to_msg() # 获取当前时间戳并转化为信息 msg.host_name = platform.node() # 返回主机名字 msg.cpu_percent = cup_percent msg.memory_percent = memory_info.percent msg.memory_available = memory_info.available /1024/1024# 有效内存 msg.net_send = net_io_counters.packets_sent /1024/1024 # 将字节转换为兆字节 msg.net_recv = net_io_counters.packets_recv /1024/1024 self.get_logger().info(f&quot;发布相关信息：&#123;msg&#125;&quot;) self.status_publisher_.publish(msg)def main(): rclpy.init() sys_status_pub = SystemStatusPub(&quot;status_publish&quot;) rclpy.spin(sys_status_pub) rclpy.shutdown() 3.订阅数据并用QT显示【注】 使用new()创建类后需要手动释放内存，只有遇到”delete()”时才会调用析构函数 使用”类名 创建的类”这种类定义声明的方式使用后不需要手动释放，这种类中的析构函数会自动执行。 关于类对象的三种创建方法： 第一：Test test1; 栈中分配，由os进行内存分配和管理。 第二：Test test2 &#x3D; Test(); 栈中分配，由os进行内存分配和管理。 第三：Test *test3 &#x3D; new Test(); 堆中分配，由管理者进行内存分配和管理，显式使用delete()释放内存空间。 “.”:是结构体引用，”-&gt;”:是指针引用。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;QApplication&gt;#include &lt;QLabel&gt;#include &lt;QString&gt;#include &lt;rclcpp/rclcpp.hpp&gt;#include &quot;status_interfaces/msg/system_status.hpp&quot;using SystemStatus = status_interfaces::msg::SystemStatus; // 将包名进行改名class SystemStatusDisplay : public rclcpp::Node&#123;private:/*data*/ rclcpp::Subscription&lt;SystemStatus&gt;::SharedPtr subscriber_;public: QLabel *label_ = new QLabel(); SystemStatusDisplay():Node(&quot;sys_status_display&quot;)&#123; // 使用lambda函数作为回调函数,接收的函数为共享指针 subscriber_ = this-&gt;create_subscription&lt;SystemStatus&gt;(&quot;sys_status&quot;,10,[&amp;](const SystemStatus::SharedPtr msg)-&gt;void&#123; label_-&gt;setText(get_qstr_from_msg(msg)); &#125;); label_-&gt;setText(get_qstr_from_msg(std::make_shared&lt;SystemStatus&gt;())); // 初始给label传一个空的共享指针，这样有表头没有具体内容。 label_-&gt;show(); &#125;; QString get_qstr_from_msg(const SystemStatus::SharedPtr msg)&#123; // 将获取到的msg内容进行拆分组装 std::stringstream show_str; show_str &lt;&lt; &quot;==========状态可视化显示工具============\\n&quot; &lt;&lt; &quot;数 据 时 间:\\t&quot; &lt;&lt; msg-&gt;stamp.sec &lt;&lt; &quot;\\ts\\n&quot; &lt;&lt; &quot;主 机 名:\\t&quot; &lt;&lt; msg-&gt;host_name &lt;&lt; &quot;\\t\\n&quot; &lt;&lt; &quot;cpu 利 用 率:\\t&quot; &lt;&lt; msg-&gt;cpu_percent &lt;&lt; &quot;\\t%\\n&quot; &lt;&lt; &quot;内 存 利 用 率:\\t&quot; &lt;&lt; msg-&gt;memory_percent &lt;&lt; &quot;\\t%\\n&quot; &lt;&lt; &quot;剩 余 有 效 内 存:\\t&quot; &lt;&lt; msg-&gt;memory_available &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;网 络 发 送 量:\\t&quot; &lt;&lt; msg-&gt;net_send &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;网 络 接 收 量:\\t&quot; &lt;&lt; msg-&gt;net_recv &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;=======================================&quot;; return QString::fromStdString(show_str.str()); &#125;;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc, argv); QApplication app(argc, argv); //类对象的声明 auto node = std::make_shared&lt;SystemStatusDisplay&gt;(); // 创建一个模板为SystemStatusDisplay的共享指针 std::thread spin_thread([&amp;]()-&gt;void&#123; rclcpp::spin(node); // 为其单独开一个线程 &#125;); spin_thread.detach(); app.exec(); rclcpp::shutdown(); return 0;&#125; 关于rclcpp::spin()：会阻塞调用它的线程，直到与它关联的节点被销毁。函数执行期间，它执行以下操作： 处理回调：调用所有已注册的回调，包括订阅者的消息回调、服务的请求回调、定时器回调。 事件循环：处理所有ROS通信相关的事件，确保节点能够响应外部消息和服务请求。 阻塞执行：该函数会一直运行，直到调用其的节点被销毁或者显示地调用rclcpp::shutdown()。 学习收获： 如何根据需求自定义.msg文件 ； 如何获取电脑基本参数信息； 如何进行字符串流输出。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战_发布控制速度海龟画圈","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_发布控制速度海龟画圈/","text":"话题通信实战_发布控制速度海龟画圈核心要求： 如何让小海龟按着我的指令？话题 怎么画圆？线速度&#x2F;角速度&#x3D;半径 发一下就停，如何循环发？定时器 1.创建类 属性： 定时器 发布者的智能指针 方法： 定时发布控制信息的函数 【注】： 定时器声明代码： 1rclcpp::Publisher&lt;消息接口&gt;::SharedPtr 发布者实例名; 定时器创建代码： 1timer_ = this-&gt;create_wall_timer(间隔时长, 回调函数); “create_wall_timer()”也称为墙钟函数，它与一般的定时器函数相比使用的不是ros时间，而是系统时间。 2.完整代码： 123456789101112131415161718192021222324252627282930313233#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &lt;chrono&gt;using namespace std::chrono_literals;class TurtleCircleNode: public rclcpp::Node&#123;private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能指针public: explicit TurtleCircleNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleCircleNode::timer_callback,this)); &#125; void timer_callback()&#123; auto msg = geometry_msgs::msg::Twist(); msg.linear.x = 1.0; msg.angular.z = 0.5; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleCircleNode&gt;(&quot;turtleCircle&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 学习收获： 学会了墙钟定时器的声明和创建","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战-订阅小说并合成语音","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_订阅小说并合成语音/","text":"话题通信实战-订阅小说并合成语音核心要求： 1. 怎么订阅？ 2. 用什么朗读文本？ Espeak 3. 小说来的快，读得慢怎么办？使用队列 1. 定义一个继承rclpy.node的节点类 属性： 存放小说的队列 订阅者 线程对象 方法： 回调函数：用于不断将小说放入队列中。 线程函数：检测到队列中存在小说就开始朗读。 下载小说的函数。 【注】： 创建订阅者的代码： 1self.create_subscription(消息接口, &quot;自定义话题名称&quot;, 回调函数, qos) 这里的qos就是前文提到的ros2中的通信服务质量，通常是一个数字；函数返回值为一个订阅者实例。还要注意的是，这里的**”自定义话题名称”需要与话题发布者的名称相同**，这样才能订阅到话题。 创建线程的代码： 12self.speech_thread_=threading.Thread(target=线程函数,传给线程函数的tuple类型参数) self.speech_thread_.start() # 注意python的线程不会自己启动，需要手动开始 “传给线程函数的tuple类型参数”有默认值，可以不传参数。 2. 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import espeakng import rclpyfrom rclpy.node import Nodeimport requestsfrom example_interfaces.msg import Stringfrom queue import Queueimport threadingimport timeclass Novel_sub_Node(Node): def __init__(self, node_name): super().__init__(node_name) self.novel_queue = Queue() self.get_logger().info(f&quot;&#123;node_name&#125;,启动！&quot;) # 创建订阅者 参数：信息类型，话题名称（这里一定要与发布者取的名字一致），回调函数,qos self.novel_sub_ = self.create_subscription(String, &quot;novel&quot;, self.novel_callback, 10) self.speech_thread_ = threading.Thread(target=self.speak_thread) self.speech_thread_.start() # 注意python的线程不会自己启动，需要手动开始 def novel_callback(self, msg): self.novel_queue.put(msg.data) def speak_thread(self): speaker = espeakng.Speaker() speaker.voice = &#x27;zh&#x27; while rclpy.ok(): # 检测当前ROS上下文是否ok；用于检查ROS2系统的运行状态，通常用于控制循环的执行，确保在系统关闭时能够优雅地退出。 if self.novel_queue.qsize() &gt; 0: text = self.novel_queue.get() self.get_logger().info(f&quot;朗读：&#123;text&#125;&quot;) speaker.say(text) speaker.wait() else: # 当朗读队列为空时 time.sleep(1) # 让该线程休眠1s def download(self, url): res = requests.get(url) res.encoding = &#x27;utf-8&#x27; text = res.text self.get_logger().info(f&quot;&#123;url&#125;,&#123;len(text)&#125;&quot;)def main(): rclpy.init() node = Novel_sub_Node(&quot;novel_sub&quot;) node.download(&quot;http://0.0.0.0:8000/novel1.txt&quot;) rclpy.spin(node) rclpy.shutdown() 学习收获： 认识了python中可以获取文字并朗读的库”espeakng”，使用”espeakng.Speaker()”可以创建一个espeakng实例。 学会创建订阅者和线程。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战-通过话题发布小说","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战-通过话题发布小说/","text":"话题通信实战-通过话题发布小说需求：下载小说并通过话题间隔5s发布一行核心问题： 1. 怎么下载小说？ 使用requests; 2. 怎么发布？确定名字和接口; 3. 怎么间隔5s发布？Timer定时器。 1. 定义一个继承rclpy.node的节点 属性： 存放小说的队列 发布者 定时器 方法： 判断队列大小的回调函数 下载函数 【注】： 创建发布者代码： 1self.create_publisher(消息接口,&#x27;自定义话题名字&#x27;,服务质量配置) 关于服务质量配置是给一个表示队列大小的数字。create_publisher()的返回值为 一个发布者。 创建定时器代码： 1self.create_timer(时间间隔周期,自定义回调函数) create_timer()没有返回值，其会按照传入的间隔周期去调用回调函数。 2. 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041import rclpyfrom rclpy.node import Nodeimport requestsfrom example_interfaces.msg import Stringfrom queue import Queueclass pubNode(Node): def __init__(self, node_name): super().__init__(node_name) self.get_logger().info(f&quot;&#123;node_name&#125;,启动！&quot;) self.novels_queue = Queue() # 创建队列 # 参数依次为：消息接口，话题的名字(自定义)，服务质量配置（给一个表示队列大小的数字;返回值为发布者 self.novel_publisher_ = self.create_publisher(String,&#x27;novel&#x27;,100) self.create_timer(5,self.timer_callback) # 参数：时间间隔周期，回调函数 # 判断队列大小-&gt;若大于0则从队列里面取一行数据-&gt;组装成消息-&gt;发布消息 def timer_callback(self): # 设置一个回调函数 if self.novels_queue.qsize() &gt; 0: line = self.novels_queue.get() msg = String() # 组装数据 msg.data = line self.novel_publisher_.publish(msg) self.get_logger().info(f&quot;发布了：&#123;msg&#125;&quot;) # 下载：获取请求-&gt;按行分割-&gt;放到队列里面 def download(self, url): res = requests.get(url) res.encoding = &#x27;utf-8&#x27; text = res.text # text.splitlines() #把下载的内容按行分割 self.get_logger().info(f&quot;下载&#123;url&#125;,&#123;len(text)&#125;&quot;) for line in text.splitlines(): self.novels_queue.put(line) def main(): rclpy.init() node = pubNode(&quot;novel_pub&quot;) node.download(&quot;http://0.0.0.0:8000/novel1.txt&quot;) rclpy.spin(node) rclpy.shutdown() 【笔记】： example_interface：样例消息类。 回调函数依赖的成员变量容器要提前初始化。 “python -m http.server”：在当前目录启动一个HTTP服务器，默认监听端口为8000。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"","date":"2025-09-18T10:43:02.063Z","path":"2025/09/18/记录杂七杂八小问题/实现Ubuntu与主机之间复制粘贴/","text":"1.方法一：虚拟机顶部工具栏点击”虚拟机设置”-&gt;”选项”-&gt;”客户机隔离”勾选，再次启动Ubuntu。 2.方法二：使用Ubuntu命令 在终端中依次运行： 123sudo su- //进入管理员模式sudo apt-get install open-vm-tools open-vm-tools-desktop //安装命令vmware-user //开启服务 最后，重启虚拟机就可以实现跨平台复制粘贴。 3.方法三：（永久开启该服务） 编写service配置文件 1234567891011# /etc/systemd/system/vmware-user.service [Unit] Description=开机启动一次vmware-user After=network.target [Service] Type=oneshot ExecStart=vmware-user [Install] WantedBy=multi-user.target 重新加载systemd配置 1systemctl daemon-reload 设置开机自启动 1systemctl enable vmware-user 重启虚拟机后基本成功","categories":[],"tags":[]},{"title":"基本格式","date":"2025-09-18T08:28:11.787Z","path":"2025/09/18/基础相关/format/","text":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]},{"title":"Hello Hexo","date":"2025-09-18T08:02:00.000Z","path":"2025/09/18/基础相关/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Typora的基础使用方法","date":"2025-09-18T07:39:00.000Z","path":"2025/09/18/基础相关/Typora_use/","text":"注：在文件最前面输入”[“TOC”]”，自动生成可跳转的文件目录 [TOC] 一.关于标题这是二级标题笔记：关于快捷键【但我的电脑不知道为啥用不了】 1.Ctrl+数字1-6对应将选中文本调节至对应级别的标题。 2.Ctrl+0可以快速将选中的文本调成普通文本。 3.Ctrl+加号&#x2F;减号对标题级别进行调整。 4.“#”数量控制字体级别，注意”#”与标题间有一个空格。 二.关于换行1.“Shift”+“Enter”可以进行比”Shift”更小的换行。 2.“分割线”：“—”按回车或者”***”按回车。 三.文字显示1.关于字体（1）粗体：用一对双星号包裹 e.g：这是粗体 （2）剔除线：用一对双飘号包裹 e.g:这是剔除线 （3）下划线：用一对u标签(html)包裹 e.g:这是下划线 （4）斜体：用一对单星号包裹 e.g:这是斜体 （5）高亮：用一对双等号包裹 e.g：&#x3D;&#x3D;这是高亮&#x3D;&#x3D; 快捷键：(按双数次取消效果) 加粗：Ctrl+B删除线：Shift+Alt+5下划线：Ctrl+u斜体：Ctrl+i 注：反斜杠+星：解决星号不显示的问题 * 2.上下标(1)一对”^”：表示上标。 x^2^ (2)一对”“：表示下标。 H2~O 四.列表1.无序列表（1）同级序号 ctrl+Shift+”]”：进入序列，两次回车退出序列。 （2）子集序列:Ctrl+”]”：列表右缩进。 这是一级序列 这是二级序列 又变一级 2.有序列表（1）同级序号 ctrl+Shift+”[“：进入序列，两次回车退出序列。 (2) 子集序列：子集序列:Ctrl+”]”：列表右缩进。 3.任务列表 :无序列表符+”[ ]” 五.区块显示 :”英文箭头加回车”。 六.代码显示1.行内代码 int a =2;:用一对“&#96;”包裹。 2.代码块：Ctrl+Shift+K 123int a = 2;int b =3; 1#include &lt;iostream&gt; 七.链接哔哩哔哩：Ctrl+K [一.关于标题](# 一.关于标题)：关于文件内标题跳转，前面括号写显示内容，后面括号写入跳转标题(记得加上对应格式)；跳转的时候Ctrl+点击。 八.脚注文字^1 ：“[”+”^”想要脚注的文字+”]” 上面的实现：“[”+”^”想要脚注的文字+”]”:解释说明。 ​ 注意：上下想要脚注的文字的文字需要一致才能有脚注； ​ 冒号要用英文格式的； ​ “&lt;”br”&gt;”：可以实现回车。 九.图片插入![不显示只给写文件的人提醒的一段文字](图片路径 “图片标题”) 还可以拖拽进行添加图片 十.表格快捷键：Ctrl+T id name score 23 张三 99 3 李四 100 十一.表情符号:happy: 、:cry: 两个冒号间加对应英文；（win+. ：可以快速打开表情面板） 十二.数学公式输入$$x^2+(y+1)^2&#x3D;5$$","categories":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/categories/Typora/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"},{"name":"basic-Usage","slug":"basic-Usage","permalink":"http://example.com/tags/basic-Usage/"}]}]
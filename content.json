[{"title":"","date":"2025-09-24T14:23:39.976Z","path":"2025/09/24/记录杂七杂八小问题/关于yaml文件的编写遇到的一些小坑点/","text":"开头第一行需要：—，对，就是三个横杠隔开 每一行后面都不要偷偷加空格 最后一行需要顶头换行 可以使用”yamllint yaml文件的路径”，可以查看yaml文件是否编写正确。","categories":[],"tags":[]},{"title":"ros_参数","date":"2025-09-23T16:00:00.000Z","path":"2025/09/24/ros2/ros_参数/","text":"ros_参数 特点：全局共享字典、由键值对组成、可实现动态监控 查看&#x2F;修改参数常用命令： ros2 param describe 节点 参数：获得参数描述 ros2 param get 节点 参数：获得参数当前值 ros2 param set 节点 参数 参数值：设置参数值 ros2 param dump 节点 &gt;&gt; 文件名(一般以.yaml结尾)：将节点中所有参数写到指定文件中(这样可以在文件中直接对参数进行批量修改) ros2 param load 节点 文件名 ：读取指定文件中的参数 使用代码创建类继承rclpy节点，实现参数创建、读取、修改： declare_parameter(‘参数名’,’参数值’)：创建一个参数，并设置参数的默认值 get_parameter(‘参数名’).get_parameter_value().string_value：获得字符串类型的参数值 get_parameter_value()：获取参数值的具体信息【？？？感觉这个函数和上面那个一样】 rclpy.parameter.Parameter(‘参数名’,值的类型,’新的参数值’)：重新设置参数的值【值的类型，e.g:字符串类型：rclpy.Parameter.Type.STRING】 set_parameters(新的键值对)：给参数设置新的值","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"parameter","slug":"parameter","permalink":"http://example.com/tags/parameter/"}]},{"title":"ros_动作通信","date":"2025-09-23T16:00:00.000Z","path":"2025/09/24/ros2/ros_动作通信/","text":"ros_动作通信 动作通信是一种应用层的通信机制，基于客户端&#x2F;服务器(c&#x2F;s)模型。实际上动作通信是由两个服务通信和一个话题通信构成的。如下为动作通信结构： 动作通信有一个持续时间，并且在持续时间内一直有Feedback反馈。 接口.Goal()：创建一个目标消息 接口.Result()：创建一个结果消息 接口.Feedback()：创建一个动作反馈消息","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"action_communication","slug":"action-communication","permalink":"http://example.com/tags/action-communication/"}]},{"title":"ros_DDS机器人的神经网络","date":"2025-09-23T16:00:00.000Z","path":"2025/09/24/ros2/ros_DDS机器人的神经网络/","text":"DDS机器人的神经网络 常用通信模型 点对点模型 Broker模式 广播模式 数据为中心模式 ![4d89ea5a88ab54b0112ffebab46e3751_720](N:&#x2F;qq_massage&#x2F;Tencent Files&#x2F;2454428604&#x2F;nt_qq&#x2F;nt_data&#x2F;Pic&#x2F;2025-09&#x2F;Thumb&#x2F;4d89ea5a88ab54b0112ffebab46e3751_720.jpg) DDS，即数据分发服务，专门为实时系统设计的数据分发&#x2F;订阅标准。DDS强调以数据为中心，提供丰富的服务质量策略(QoS)，以保障数据进行高效、实时、灵活地分发，可满足各种分布式实时通信应用需求。 ![470955445bacc91c498c2637bb5c6fc4_720](N:&#x2F;qq_massage&#x2F;Tencent Files&#x2F;2454428604&#x2F;nt_qq&#x2F;nt_data&#x2F;Pic&#x2F;2025-09&#x2F;Thumb&#x2F;470955445bacc91c498c2637bb5c6fc4_720.jpg) 【注意】：如果DDS中qos通信名称相同，但传输模式不同，依旧不可以进行通信。 “ros2 topic info 话题名称 –verbose”可以查到更为详尽的信息。 如下为QoS的一些配置","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"DDS","slug":"DDS","permalink":"http://example.com/tags/DDS/"}]},{"title":"ros_通信接口【总结版】","date":"2025-09-23T16:00:00.000Z","path":"2025/09/24/ros2/基础/ros_通信接口【总结版】/","text":"ros_通信接口【总结版】 关于话题通信（单向传输，发布者一直反馈结果）、服务通信（一问一答，服务端请求一次反馈一次）和动作通信的框架图 不同通信方式对应的接口文件 话题—-&gt;.msg文件【由通信数据构成】 服务—&gt;.srv文件【由请求数据和应答数据两部分构成】 动作—&gt;.action文件【由目标、结果和反馈三部分构成】 查看常用的通信接口 话题通信&#x2F;服务通信&#x2F;动作通信接口具体定义查看：ros2 interface show 消息接口 查看某功能包定义的所有通信接口：ros2 interface package 功能包名 **[注]**： 定义好通信接口文件后，需要去CMakeList.txt和package.xml文件中进行配置。 调用接口文件时，要在文件开始时引用接口文件。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"Linux常用命令","date":"2025-09-22T16:00:00.000Z","path":"2025/09/23/基础相关/Linux常用命令/","text":"Linux常用命令 pwd：查看当前路径 ls：查看当前目录下的文件 |ls -a：查看当前目录下的文件(包括隐藏文件) mkdir 文件夹名：创建文件夹 cd 路径：进入某个路径 touch 文件名：创建文件 rm 文件名：删除文件 rm -r 文件夹：删除文件夹 sudo apt install 应用名：安装应用 关于ros2 node的可选项： ​ 关于ros2 topic的可选项： 关于ros2 service的可选项： 关于ros2 bag的可选项：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"basic-Usage","slug":"basic-Usage","permalink":"http://example.com/tags/basic-Usage/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux中相机驱动节点的复用","date":"2025-09-22T16:00:00.000Z","path":"2025/09/23/记录杂七杂八小问题/Linux中相机驱动节点的复用/","text":"Linux中相机驱动节点的复用在终端中输入如下命令： sudo apt install ros-${ROS_DISTRO}-usb-cam # 安装相机的标准驱动 ros2 run usb_cam usb_cam_node_exe #使用ros下面一个标准的功能包来驱动 此时再运行需要启动相机的节点","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"Ubuntu Linux","slug":"Ubuntu-Linux","permalink":"http://example.com/tags/Ubuntu-Linux/"}]},{"title":"ros_使用URDF创建机器人","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_使用URDF创建机器人/","text":"使用URDF创建机器人1.帮机器人创建一个身体 URDF使用XML来描述机器人的几何结构、传感器和执行器等信息。 e.g：下述代码定义了一个名为first_robot的机器人，该机器人有一个base_link的部件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!-- 使用urdf_to_graphviz可以将定义的机器人进行可视化（在urdf目录下进行启动）--&gt;&lt;robot name=&quot;joyning_robot&quot;&gt; &lt;!-- 机器人的身体部分 --&gt; &lt;link name=&quot;bask_link&quot;&gt; &lt;!-- 部件的外观描述 --&gt; &lt;visual&gt; &lt;!-- 沿着自己几何中心的偏移和旋转量 --&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- 机器人的几何形状 --&gt; &lt;geometry&gt; &lt;!-- 设置了一个半径为0.10m,高度为0.5m的圆柱体 --&gt; &lt;cylinder radius=&quot;0.10&quot; length=&quot;0.5&quot;/&gt; &lt;/geometry&gt; &lt;!-- 材质颜色描述 --&gt; &lt;material name=&quot;white&quot;&gt; &lt;!-- 红、绿、蓝、透明度（半透明） --&gt; &lt;color rgba=&quot;1.0 1.0 1.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 第二个部件：机器人的IMU部件，惯性测量传感器 --&gt; &lt;link name=&quot;imu_link&quot;&gt; &lt;!-- 部件的外观描述 --&gt; &lt;visual&gt; &lt;!-- 沿着自己几何中心的偏移和旋转量 --&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- 机器人的几何形状 --&gt; &lt;geometry&gt; &lt;!-- 设置了一个长宽高均为2cm的正方体 --&gt; &lt;box size=&quot;0.02 0.02 0.02&quot;/&gt; &lt;/geometry&gt; &lt;!-- 材质颜色描述 --&gt; &lt;material name=&quot;black&quot;&gt; &lt;!-- 红、绿、蓝、透明度（半透明） --&gt; &lt;color rgba=&quot;0.0 0.0 0.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 机器人的关节，用于组合机器人的部件（例如：本次将把imu固定在机器人的身体上）--&gt; &lt;joint name=&quot;imu_joint&quot; type=&quot;fixed&quot;&gt; &lt;!-- 表示把imu部件固定在base_link部件上 --&gt; &lt;parent link=&quot;bask_link&quot;/&gt; &lt;child link=&quot;imu_link&quot;/&gt; &lt;!-- 表示固定的位置 --&gt; &lt;origin xyz=&quot;0.0 0.0 0.03&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- 旋转轴和限制 --&gt; &lt;!-- &lt;axis xyz=&quot;0.0 0.0 0.0&quot;/&gt; &lt;limit lower=&quot;0.0&quot; upper=&quot;0.0&quot; effort=&quot;0.0&quot; velocity=&quot;0.0&quot;/&gt; --&gt; &lt;/joint&gt;&lt;/robot&gt; 关于joint中的type属性，分别有如下六种类型： continuous：一个不受限制的，绕着一根轴的转动副； revolute：一个转动角度受限制，绕着一根轴的转动副； prismatic：一个沿着一根轴的滑动副，并且有限位； fixed：固定关节； floating：这个关节允许六个自由度的运动，浮动关节； planar：该关节允许在垂直于轴的一个平面内进行平移旋转等动作。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"}]},{"title":"ros_使用Xacro简化URDF","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_使用Xacro简化URDF/","text":"使用Xacro简化URDF Xacro(XML Macro)是基于XML的宏语言，用于简化URDF文件的创建和维护。使用它可以将部件定义为宏，在需要使用的时候进行调用即可。[宏可以反复调用，但link name不能重复] &lt;xacro:macro name&#x3D;”AAA”&gt;：这个名字主要用于宏定义给参数赋值时使用；params&#x3D;”参数1 参数2 … “：用于定义参数，中间用空格分隔开。 ：这个名字主要用于其它声明内部调用，例如joint部件写parent link和child link时使用。 传递参数调用已定义模块：&lt;xacro:模块名称 参数1&#x3D;”xx” 参数2&#x3D;”xx” &#x2F;&gt;。 特别注意：xacro中link name不允许重名，解决办法一般是将link name也作为参数传入。 xacro文件需要使用命令”xacro 文件绝对路径”转成urdf文件才能使用，可以在launch文件中通过如下命令执行xacro-&gt;urdf的转换(需要安装xacro)。 1substitutions_command_result = launch.substitutions.Command([&#x27;xacro &#x27;,launch.substitutions.LaunchConfiguration(&#x27;model&#x27;)]) 其中’xacro’后面有一个空格，launch.substitutions.LaunchConfiguration(‘model’)存储的模型文件的路径。 base_link的Xacro版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot; name=&quot;MyFirstRobot&quot;&gt;&lt;!-- 声明base_link模块 --&gt; &lt;!-- 注意：这里params的参数以空格隔开 --&gt; &lt;xacro:macro name=&quot;base_link&quot; params=&quot;length radius&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;$&#123;radius&#125;&quot; length=&quot;$&#123;length&#125;&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;white&quot;&gt; &lt;color rgba=&quot;1.0 1.0 1.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;/xacro:macro&gt; &lt;!-- 声明imu_link部件--&gt; &lt;xacro:macro name=&quot;imu_link&quot; params=&quot;imu_name xyz&quot;&gt; &lt;link name=&quot;$&#123;imu_name&#125;_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;box size=&quot;0.02 0.02 0.02&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;black&quot;&gt; &lt;color rgba=&quot;1.0 1.0 1.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 机器人的关节，用于组合机器人的部件（例如：本次将把imu固定在机器人的身体上）--&gt; &lt;joint name=&quot;$&#123;imu_name&#125;_joint&quot; type=&quot;fixed&quot;&gt; &lt;!--type中的revolute表示可活动的；fixed表示螺丝固定死的，不可以活动的--&gt; &lt;!-- 表示把imu部件固定在base_link部件上 --&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;$&#123;imu_name&#125;_link&quot;/&gt; &lt;!-- 表示固定的位置 --&gt; &lt;origin xyz=&quot;$&#123;xyz&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- 旋转轴和限制 --&gt; &lt;!-- &lt;axis xyz=&quot;0.0 0.0 0.0&quot;/&gt; &lt;limit lower=&quot;0.0&quot; upper=&quot;0.0&quot; effort=&quot;0.0&quot; velocity=&quot;0.0&quot;/&gt; --&gt; &lt;/joint&gt; &lt;/xacro:macro&gt; &lt;!-- 给参数赋值 --&gt; &lt;xacro:base_link length=&quot;0.12&quot; radius=&quot;0.2&quot;/&gt; &lt;xacro:imu_link imu_name=&quot;imu_up&quot; xyz=&quot;0.0 0.0 0.03&quot;/&gt; &lt;xacro:imu_link imu_name=&quot;imu_down&quot; xyz=&quot;0.0 0.0 -0.03&quot;/&gt;&lt;/robot&gt;&lt;!-- 注意：xacro文件需要使用命令&quot;xacro 文件路径&quot;转成urdf文件才能使用 --&gt;","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"}]},{"title":"ros_创建传感器和执行器部件","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_创建传感器和执行器部件/","text":"创建传感器和执行器部件 传感器部件的创建 camera_link 1234567891011121314151617181920212223242526272829&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt; &lt;!-- 声明camera_link部件--&gt; &lt;xacro:macro name=&quot;camera_link&quot; params=&quot;xyz&quot;&gt; &lt;link name=&quot;camera_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;box size=&quot;0.02 0.10 0.02&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;black&quot;&gt; &lt;color rgba=&quot;0.0 0.0 0.0 0.8&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 机器人的关节，用于组合机器人的部件（例如：本次将把imu固定在机器人的身体上）--&gt; &lt;joint name=&quot;camera_joint&quot; type=&quot;fixed&quot;&gt; &lt;!--type中的revolute表示可活动的；fixed表示螺丝固定死的，不可以活动的--&gt; &lt;!-- 表示把imu部件固定在base_link部件上 --&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;camera_link&quot;/&gt; &lt;!-- 表示固定的位置 --&gt; &lt;origin xyz=&quot;$&#123;xyz&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- 旋转轴和限制 --&gt; &lt;!-- &lt;axis xyz=&quot;0.0 0.0 0.0&quot;/&gt; &lt;limit lower=&quot;0.0&quot; upper=&quot;0.0&quot; effort=&quot;0.0&quot; velocity=&quot;0.0&quot;/&gt; --&gt; &lt;/joint&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 定义机器人的照相机部分--&gt; imu_link 1234567891011121314151617181920212223242526&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt; &lt;!-- 声明imu_link部件--&gt; &lt;xacro:macro name=&quot;imu_xacro&quot; params=&quot;xyz&quot;&gt; &lt;link name=&quot;imu_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;box size=&quot;0.02 0.02 0.02&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;black&quot;&gt; &lt;color rgba=&quot;1.0 1.0 1.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 机器人的关节，用于组合机器人的部件（例如：本次将把imu固定在机器人的身体上）--&gt; &lt;joint name=&quot;imu_joint&quot; type=&quot;fixed&quot;&gt; &lt;!--type中的revolute表示可活动的；fixed表示螺丝固定死的，不可以活动的--&gt; &lt;!-- 表示把imu部件固定在base_link部件上 --&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;imu_link&quot;/&gt; &lt;!-- 表示固定的位置 --&gt; &lt;origin xyz=&quot;$&#123;xyz&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;/joint&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 定义机器人的传感器部分--&gt; laser_link 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt; &lt;!-- 声明laser_link部件--&gt; &lt;xacro:macro name=&quot;laser_link&quot; params=&quot;xyz&quot;&gt; &lt;!-- 雷达支撑管 --&gt; &lt;link name=&quot;laser_cylinder_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;0.01&quot; length=&quot;0.10&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;green&quot;&gt; &lt;color rgba=&quot;0.0 1.0 0.0 1.0&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name=&quot;laser_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;0.02&quot; length=&quot;0.02&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;black&quot;&gt; &lt;color rgba=&quot;1.0 1.0 1.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- 机器人的关节，用于组合机器人的部件（例如：本次将把imu固定在机器人的身体上）--&gt; &lt;joint name=&quot;laser_joint&quot; type=&quot;fixed&quot;&gt; &lt;!-- 将雷达固定到雷达支撑管上 --&gt; &lt;parent link=&quot;laser_cylinder_link&quot;/&gt; &lt;child link=&quot;laser_link&quot;/&gt; &lt;origin xyz=&quot;0.0 0.0 0.05&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;/joint&gt; &lt;joint name=&quot;laser_cylinder_joint&quot; type=&quot;fixed&quot;&gt; &lt;!-- 将雷达支撑管固定到base_link(即机器人)上 --&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;laser_cylinder_link&quot;/&gt; &lt;origin xyz=&quot;$&#123;xyz&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;/joint&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 定义雷达部分 --&gt; 执行器部件的创建 caster_link 123456789101112131415161718192021222324252627282930&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt; &lt;!-- 声明caster部件--&gt; &lt;xacro:macro name=&quot;caster_xacro&quot; params=&quot;caster_name xyz&quot;&gt; &lt;link name=&quot;$&#123;caster_name&#125;_link&quot;&gt; &lt;visual&gt; &lt;!-- 旋转90度(使用弧度制)，让轮子立起来 --&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;1.57079 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;sphere radius=&quot;0.016&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;red&quot;&gt; &lt;color rgba=&quot;1.0 0.0 0.0 0.8&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- type=&quot;continuous&quot;表示可转动的 --&gt; &lt;joint name=&quot;$&#123;caster_name&#125;_joint&quot; type=&quot;fixed&quot;&gt; &lt;!--type中的revolute表示可活动的；fixed表示螺丝固定死的，不可以活动的--&gt; &lt;!-- 表示把imu部件固定在base_link部件上 --&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;$&#123;caster_name&#125;_link&quot;/&gt; &lt;!-- 表示固定的位置 --&gt; &lt;origin xyz=&quot;$&#123;xyz&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- &lt;limit lower=&quot;0.0&quot; upper=&quot;0.0&quot; effort=&quot;0.0&quot; velocity=&quot;0.0&quot;/&gt; --&gt; &lt;/joint&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 定义执行器部分 --&gt; wheel_link 123456789101112131415161718192021222324252627282930313233&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt; &lt;!-- 声明camera_link部件--&gt; &lt;!-- 将wheel_name放入参数中，因为机器人往往不止一个轮子，需要传入参数进行修改 --&gt; &lt;xacro:macro name=&quot;wheel_xacro&quot; params=&quot;wheel_name xyz&quot;&gt; &lt;!-- 加上link_name方便机器人组件中的调用 --&gt; &lt;link name=&quot;$&#123;wheel_name&#125;_link&quot;&gt; &lt;visual&gt; &lt;!-- 旋转90度(使用弧度制)，让轮子立起来 --&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;1.57079 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;0.032&quot; length=&quot;0.04&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;blue&quot;&gt; &lt;color rgba=&quot;0.0 0.0 1.0 0.8&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;!-- type=&quot;continuous&quot;表示可转动的 --&gt; &lt;joint name=&quot;$&#123;wheel_name&#125;_joint&quot; type=&quot;continuous&quot;&gt; &lt;!--type中的revolute表示可活动的；fixed表示螺丝固定死的，不可以活动的--&gt; &lt;!-- 表示把imu部件固定在base_link部件上 --&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;$&#123;wheel_name&#125;_link&quot;/&gt; &lt;!-- 表示固定的位置 --&gt; &lt;origin xyz=&quot;$&#123;xyz&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;!-- 绕y轴旋转 --&gt; &lt;axis xyz=&quot;0.0 1.0 0.0&quot;/&gt; &lt;!-- &lt;limit lower=&quot;0.0&quot; upper=&quot;0.0&quot; effort=&quot;0.0&quot; velocity=&quot;0.0&quot;/&gt; --&gt; &lt;/joint&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 定义轮子部分 --&gt; base_xacro 1234567891011121314151617181920212223&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt;&lt;!-- 当本文件作为一个子文件被引入时，不需要为该机器人命名 --&gt;&lt;!-- &lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot; name=&quot;MyFirstRobot&quot;&gt; --&gt;&lt;!-- 声明base_link模块 --&gt; &lt;!-- 注意：这里params的参数以空格隔开 --&gt; &lt;xacro:macro name=&quot;base_xacro&quot; params=&quot;length radius&quot;&gt; &lt;!-- 添加一个虚拟部件,到时候以其为基准，能保证整个小车都在base_footprint(即地面)以上--&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;$&#123;radius&#125;&quot; length=&quot;$&#123;length&#125;&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;white&quot;&gt; &lt;color rgba=&quot;0 0 0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 注意：定义机器人身体 --&gt; 将机器人进行组装的文件(相当于main函数) 1234567891011121314151617181920212223242526272829&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot; name=&quot;MyFirstRobot&quot;&gt;&lt;!-- filename = &quot;$&#123;find 功能包名&#125;&quot; ,代码功能：找到功能包的share目录--&gt;&lt;!-- 调用base_link部分 --&gt;&lt;xacro:include filename=&quot;$(find robot_description)/urdf/base.urdf.xacro&quot;/&gt;&lt;!-- 调用传感器部分 --&gt;&lt;xacro:include filename=&quot;$(find robot_description)/urdf/sensor/camera.urdf.xacro&quot;/&gt;&lt;xacro:include filename=&quot;$(find robot_description)/urdf/sensor/imu.urdf.xacro&quot;/&gt;&lt;xacro:include filename=&quot;$(find robot_description)/urdf/sensor/laser.urdf.xacro&quot;/&gt;&lt;!-- 执行器部分 --&gt;&lt;xacro:include filename=&quot;$(find robot_description)/urdf/actuatir/wheel.urdf.xacro&quot;/&gt;&lt;!-- 万象轮部分 --&gt;&lt;xacro:include filename=&quot;$(find robot_description)/urdf/actuatir/caster.urdf.xacro&quot;/&gt;&lt;!-- 使用宏，生成机器人的身体 --&gt;&lt;xacro:base_xacro length=&quot;0.12&quot; radius=&quot;0.1&quot;/&gt;&lt;!-- 使用宏，生成imu --&gt;&lt;xacro:imu_xacro xyz=&quot;0.0 0.0 0.05&quot; /&gt;&lt;!-- 使用宏，生成camera,放在机器人最前面 --&gt;&lt;xacro:camera_link xyz=&quot;0.10 0.0 0.075&quot; /&gt;&lt;!-- 使用宏，生成laser --&gt;&lt;xacro:laser_link xyz=&quot;0.0 0.0 0.10&quot; /&gt;&lt;!-- 使用宏，生成执行器 --&gt;&lt;xacro:wheel_xacro wheel_name=&quot;right_wheel&quot; xyz=&quot;0.0 0.1 -0.06&quot; /&gt;&lt;xacro:wheel_xacro wheel_name=&quot;left_wheel&quot; xyz=&quot;0.0 -0.1 -0.06&quot; /&gt;&lt;!-- 使用宏，生成万象轮 --&gt;&lt;xacro:caster_xacro caster_name=&quot;front_caster&quot; xyz=&quot;0.08 0.0 -0.06&quot; /&gt;&lt;xacro:caster_xacro caster_name=&quot;rear_caster&quot; xyz=&quot;-0.08 0.0 -0.06&quot; /&gt;&lt;/robot&gt; 注意：定义每个小部件时，可以不用给name属性赋值，等到最后宏定义组装赋值时再给整个机器人命名。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"}]},{"title":"ros_在Gazebo中完成机器人仿真","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_在Gazebo中完成机器人仿真/","text":"在Gazebo中完成机器人仿真 安装gazebo sudo apt install ros-${ROS_DISTRO}-ros-gz：安装对应版本的Gazebo Harmonic。 安装好后可以通过命令”gz sim”打开软件。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"},{"name":"gazebo学习","slug":"gazebo学习","permalink":"http://example.com/tags/gazebo%E5%AD%A6%E4%B9%A0/"}]},{"title":"ros_添加物理属性让机器人更真实","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_添加物理属性让机器人更真实/","text":"添加物理属性让机器人更真实 碰撞 在link标签下添加子标签，其与视觉标签处于同一层次；碰撞包含和两个子标签，标签描述了碰撞的几何姿态，描述了碰撞几何的形状。 碰撞元素与视觉元素定义形状的方式相同，即用”几何体”标签来定义其形状，格式与视觉元素中的完全相同； 一般情况下碰撞几何体及其原点与视觉几何体及其原点完全相同。但下面两种情况会出现不同：第一，需要更快速处理，此时往往会在碰撞元素中用更简单的几何体来代替网络。第二，希望限制机器人在敏感设备附近移动。例如，不想物体与ROS2机器人的头部发生碰撞，则可以将碰撞几何体定义为一个包围该机器人头部的圆柱体。 添加完collision标签后，打开rviz2，取消”Visual Enable”的勾选，勾选上”Collision Enable”，就可以看到效果了。 效果图如下： 物理属性 添加了惯性表文件”common_inertia.xacro”，里面有长方体、圆柱体和球体的旋转惯性表的计算公式。 在link属性下添加如下代码，可以增加其质量和惯性。 1&lt;xacro:cylinder_inertia m=&quot;1.0&quot; r=&quot;$&#123;radius&#125;&quot; h=&quot;$&#123;length&#125;&quot; /&gt; 增加完后启动rviz2，在RobotModel-&gt;Mass Properties中勾选Mass和Inertia属性，即可以显示出机器人的质量和惯性。 效果图如下：","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"}]},{"title":"ros_在RViz中显示机器人","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_在RViz中显示机器人/","text":"在RViz中显示机器人 使用命令rviz2可以打开应用。 Fixed_Frame可以调换基准目标。使用”Add”添加”RobotModel”和”TF”模块，可以把机器人模型和坐标轴相关信息输入。 RViz默认不会加载urdf文件中部件之间的关系(即：joint name开头的标签)，需要安装joint-state-publisher和robot-state-publisher两个模块，然后手动读出urdf中的内容放到启动参数里。 &#x2F;robot_state_publisher会根据joint的type而选择动态发布&#x2F;tf还是静态发布&#x2F;tf_static给listener，还会发布&#x2F;robot_description给&#x2F;joint_state_publisher。最后&#x2F;joint_state_publisher会返回一个&#x2F;joint_states给&#x2F;robot_state_publisher。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"}]},{"title":"ros_添加虚拟部件让机器人更贴合地面","date":"2025-09-21T16:00:00.000Z","path":"2025/09/22/ros2/仿真/ros_添加虚拟部件，让机器人更贴合地面/","text":"添加虚拟部件让机器人更贴合地面 为了解决把”base_link固定到原点时轮子会陷到地面以下”的问题，使用虚拟部件作为固定点，可以让机器人在地面以上。 虚拟部件存在link和joint，但是它没有实体。 在base_link中添加虚拟部件代码： 12345678910111213141516171819202122232425262728293031&lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&gt;&lt;!-- 当本文件作为一个子文件被引入时，不需要为该机器人命名 --&gt;&lt;!-- &lt;robot xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot; name=&quot;MyFirstRobot&quot;&gt; --&gt;&lt;!-- 声明base_link模块 --&gt; &lt;!-- 注意：这里params的参数以空格隔开 --&gt; &lt;xacro:macro name=&quot;base_xacro&quot; params=&quot;length radius&quot;&gt; &lt;!-- 添加一个虚拟部件,到时候以其为基准，能保证整个小车都在base_footprint(即地面)以上--&gt; &lt;link name=&quot;base_footprint&quot; /&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.0 0.0 0.0&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;geometry&gt; &lt;cylinder radius=&quot;$&#123;radius&#125;&quot; length=&quot;$&#123;length&#125;&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;white&quot;&gt; &lt;color rgba=&quot;1.0 1.0 1.0 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;joint name=&quot;$joint_name&quot; type=&quot;fixed&quot;&gt; &lt;parent link=&quot;base_footprint&quot;/&gt; &lt;child link=&quot;base_link&quot;/&gt; &lt;origin xyz=&quot;0 0 $&#123;length/2+0.032-0.001&#125;&quot; rpy=&quot;0.0 0.0 0.0&quot;/&gt; &lt;limit lower=&quot;0.0&quot; upper=&quot;0.0&quot; effort=&quot;0.0&quot; velocity=&quot;0.0&quot;/&gt; &lt;/joint&gt; &lt;/xacro:macro&gt;&lt;/robot&gt;&lt;!-- 注意：定义机器人身体 --&gt;","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"simulation","slug":"simulation","permalink":"http://example.com/tags/simulation/"}]},{"title":"服务通信介绍","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_服务通信介绍/","text":"服务通信介绍 “ros2 service list -t”：查看ros2的服务列表，返回内容具体格式:服务名称 消息接口&#x2F;服务接口类型。 “ros2 interface show 消息接口”：查看消息接口具体定义（消息填充）。 “ros2 service call 服务名称 消息接口 ‘{消息接口具体填充}’：调用具体服务。 【注】：消息接口的具体填充，”{参数1: 数值,参数2: 数值,…}”。冒号数值间有一个空格。 可以使用ros2中的可视化工具rqt选取服务。（plugins-&gt;services-&gt;service caller中可以配置）。 参数被视为节点的设置，是基于服务通信实现的。 “ros2 param list”：查看ros2的参数列表。 “ros2 param describe 包名 参数名称”：查看参数的具体信息。 “ros2 param get 包名 参数名称”：获得参数的值。 “ros2 param set 包名 修改的参数名称 修改数值”：修改参数的值。 “ros2 param dump 包名 &gt; 配置文件(.yaml)”：将包现在的参数写入配置文件。 “ros2 run 包名 节点名 –ros-args –params-file 配置文件”：运行节点时就根据配置文件将节点配置。 &#x3D;&#x3D;服务通信的特点&#x3D;&#x3D; 基于客户端&#x2F;服务器(c&#x2F;s)模型 同步通信机制 服务器端唯一，客户端可以不唯一 .srv文件定义请求和应答数据结构 【补充】：关于.srv文件，需要在package.xml文件中做如下配置： 在CMakeLists.txt中做如下配置： &#x3D;&#x3D;创建服务客户端的程序流程&#x3D;&#x3D; 编程接口初始化-&gt;创建节点并初始化-&gt;创建客户端对象-&gt;创建并发送请求数据-&gt;等待服务器端应答数据-&gt;销毁节点并关闭接口。 &#x3D;&#x3D;创建服务服务端的程序流程&#x3D;&#x3D; 编程接口初始化-&gt;创建节点并初始化-&gt;创建服务端对象-&gt;通过回调函数处进行服务-&gt;向客户端反馈应答结果-&gt;销毁节点并关闭接口。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_C++服务通信实现小海龟巡逻","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_C++服务通信实现小海龟巡逻/","text":"C++服务通信实现小海龟巡逻需求：让小海龟在模拟器中随机游走进行巡逻。分析： 怎么让小海龟动态接收目标点？服务 用什么接口？自定义的 随机游走的实现？客户端来产生随机点，请求巡逻服务 整体框架图：客户端生成目标点，请求巡逻—（服务）–&gt;服务端规划路线，驾驶小海龟到达目标点—（话题）–&gt;小海龟【注】：一般编写程序，可以先把服务端程序完成。 注意： 自定义的接口上半部分请求是针对客户端；下半部分响应是针对服务端的。 srv接口文件对于未赋值变量要求小写，已赋值变量要求大写。【大概率是这样的了】 创建服务时传入的回调函数一般使用lambda表达式，比较方便。其中lambda表达式传入参数有两请求和响应两部分， 请求可以设置为const常量，而响应一般还需要进行后续修改故不设置成”const”。 python中的回调函数需要有返回值，因为python中传入的值是通过拷贝实现的；而c++中的回调函数不需要返回值，因为c++中传入的是指针。 1.自定义服务接口文件： 123456float32 target_xfloat32 target_y---int8 SUCCESS = 1int8 FAIL = 0int8 result # 结果在SUCCESS和FAIL中取其一 srv文件的上半部分为请求参数，下半部分为响应(返回)参数。 2.客户端实现步骤： 创建客户端和定时器; 定时产生目标点并请求服务端巡逻。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;chapt4_interfaces/srv/patrol.hpp&quot;#include &lt;chrono&gt;#include &lt;ctime&gt;// 将类重命名using Patrol = chapt4_interfaces::srv::Patrol;using namespace std::chrono_literals; // 使用命名空间std::chrono_literals[可以使用10s,100ms来表示时间]class TurtleClient: public rclcpp::Node&#123;private: // 声明定时器 rclcpp::TimerBase::SharedPtr timer_; // 声明客户端 rclcpp::Client&lt;Patrol&gt;::SharedPtr turtle_client; public: TurtleClient():Node(&quot;turtle_client&quot;)&#123; srand(time(NULL)); // 初始化随机种子 // 创建客户端 turtle_client = this-&gt;create_client&lt;Patrol&gt;(&quot;Patrol&quot;); // 创建定时器 timer_ = this-&gt;create_wall_timer(10s, [&amp;]()-&gt;void&#123; // 1.检测服务端是否上线 while(!this-&gt;turtle_client-&gt;wait_for_service(1s))&#123; // 服务端没有上线 if(!rclcpp::ok())&#123; // rclcpp没有准备好 RCLCPP_ERROR(this-&gt;get_logger(),&quot;等待服务上线中,rclcpp挂了&quot;); &#125; RCLCPP_INFO(this-&gt;get_logger(),&quot;等待服务上线中&quot;); &#125; // 2.构造请求对象 auto request = std::make_shared&lt;Patrol::Request&gt;(); request-&gt;target_x = rand()%15; request-&gt;target_y = rand()%15; // 3.发送请求 // 发送异步请求[请求 回调函数] this -&gt; turtle_client -&gt; async_send_request(request, [&amp;](rclcpp::Client&lt;Patrol&gt;::SharedFuture result_future)-&gt;void&#123; auto response = result_future.get(); if(response-&gt;result==Patrol::Response::SUCCESS)&#123; RCLCPP_INFO(this-&gt;get_logger(),&quot;请求成功！&quot;); &#125;if(response-&gt;result==Patrol::Response::FAIL)&#123; RCLCPP_INFO(this-&gt;get_logger(),&quot;请求失败！&quot;); &#125; &#125;); &#125;); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleClient&gt;(); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 3.服务端实现步骤： 定义基于Patrol类的服务共享指针、发布者的共享指针、订阅者的共享指针； 获取当前位置，并计算新位置发布出去。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &quot;turtlesim/msg/pose.hpp&quot;#include &quot;chapt4_interfaces/srv/patrol.hpp&quot;/*服务端编写：使小海龟到达具体点*/// 将类重命名using Patrol = chapt4_interfaces::srv::Patrol;class TurtleControlNode: public rclcpp::Node&#123;private: rclcpp::Service&lt;Patrol&gt;::SharedPtr patrol_service; // 定义基于Patrol类的服务共享指针 rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能共享指针 rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 double target_x_&#123;1.0&#125;; double target_y_&#123;1.0&#125;; double k_&#123;1.0&#125;; //比例系数【间接控制速度】 double max_speed_&#123;3.0&#125;; //最大速度public: explicit TurtleControlNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); subscriber_ = this-&gt;create_subscription&lt;turtlesim::msg::Pose&gt;(&quot;/turtle1/pose&quot;,10,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); // 服务智能指针的构造[服务名，回调函数(用lambda表达式实现)] patrol_service = this-&gt;create_service&lt;Patrol&gt;(&quot;Patrol&quot;,[&amp;](const Patrol::Request::SharedPtr request, Patrol::Response::SharedPtr response)-&gt;void&#123; // 进行请求值合法性判断 if((0 &lt; request-&gt;target_x &amp;&amp; request-&gt;target_x &lt; 12.0)&amp;&amp;(0 &lt; request-&gt;target_y &amp;&amp; request-&gt;target_y &lt; 12.0))&#123; target_x_ = request-&gt;target_x; target_y_ = request-&gt;target_y; response-&gt;result = Patrol::Response::SUCCESS; &#125;else&#123; response-&gt;result = Patrol::Response::FAIL; &#125; &#125;); // 作为服务的参数有两请求和响应两部分 &#125; // 获取当前位置，并计算新位置发布出去 void on_pose_received(const turtlesim::msg::Pose::SharedPtr pose)&#123; //参数：收到数据的共享指针 // 1.获取当前位置 auto current_x = pose-&gt;x; auto current_y = pose-&gt;y; RCLCPP_INFO(get_logger(),&quot;获取当前位置:x=%f,y=%f&quot;,current_x,current_y); // 2.计算当前海龟位置跟目标位置之间的距离差和角度差。 auto distance = std::sqrt((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y)); // 目标角度和当前角度的差值 auto angle = std::atan2((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta; // 3.控制策略 auto msg = geometry_msgs::msg::Twist(); if(distance&gt;0.1)&#123; if(fabs(angle)&gt;0.2)&#123; msg.angular.z = fabs(angle); //如果角度差大于0.2则改变角度(进行旋转) &#125;else&#123; msg.linear.x = k_*distance; //如果角度差不大，则提高速度 &#125; &#125; //限制最大线速度 if(msg.linear.x &gt; max_speed_)&#123; msg.linear.x = max_speed_; &#125; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleControlNode&gt;(&quot;turtle_control&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 这里还是需要回顾一下发布者（服务端）、订阅者（客户端）和服务的创建（声明就不讲了）。 发布者的创建： create_publisher&lt;模板类&gt;(): 参数列表：服务名称、qos； 返回值：发布者实例。 订阅者的创建： create_subscription&lt;模板类&gt;(): 参数列表：服务名称（这里应该与对应发布者中的服务名称对应）、qos、回调函数。 返回值：订阅者实例。 服务的创建： create_service&lt;模板类&gt;(): 参数列表：服务名称、回调函数。 返回值：服务实例。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_服务通信实训_人脸识别","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_服务通信实训_人脸识别/","text":"服务通信实训_人脸识别需求：使用python实现，创建一个人脸检测服务，提供图像，返回人脸数量位置信息。 难点分析： 人脸怎么识别？使用face_recognition 图片数据和结果怎么传递？使用服务通信 没有合适的消息接口？自定义一个 【分为请求和响应两部分】 1.自定义服务接口 消息接口文件命名不要使用”_”，而应该使用驼峰命名法； “os.path.join(路径1,路经2)“：将两个路径拼接起来，会自动加上”&#x2F;“； 使用”CV BRIDGE”将opencv下图片格式与ROS消息接口中的sensor_msgs&#x2F;Image文件互相转化； Facedetectors.srv文件的编写： 12345678sensor_msgs/Image image---int16 numberfloat32 use_time int32[] topint32[] rightint32[] bottomint32[] left 2.服务实现步骤： 创建服务，接受请求Request； 调用face_recognition来识别人脸; 处理响应结果合成Response返回。 服务器代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import rclpyfrom rclpy.node import Nodefrom chapt4_interfaces.srv import Facedetectorimport cv2 import face_recognitionfrom ament_index_python.packages import get_package_share_directory # 获得功能包share目录绝对路径import osfrom cv_bridge import CvBridgeimport time&#x27;&#x27;&#x27;人脸识别服务端&#x27;&#x27;&#x27;class FaceService(Node): def __init__(self): super().__init__(&#x27;face_service&#x27;) # 创建服务 参数：(服务类型，服务名称，回调函数) self.service = self.create_service(Facedetector,&#x27;face_detect&#x27;, self.detect_face_callback) self.cvbridge = CvBridge() # 主要用于ROS图像消息和opencv图像之间进行转换 self.declare_parameter(&#x27;upsample_flu&#x27;,3) self.declare_parameter(&#x27;model&#x27;,&#x27;hog&#x27;) self.default_path = os.path.join(get_package_share_directory(&quot;demo_python_service&quot;),&quot;resource/test/.png&quot;) self.upsample_flu = self.get_parameter(&#x27;upsample_flu&#x27;).value self.model= self.get_parameter(&#x27;model&#x27;).value self.get_logger().info(&quot;人脸识别！启动！！&quot;) # 服务器对用户上传的图片进行处理，以下为逻辑处理代码 def detect_face_callback(self, request, response): if(request.image.data): # 请求中有图像时 cv_img = self.cvbridge.imgmsg_to_cv2(request.image) # 将消息接口格式的图像文件转化为cv2能识别的图像文件 else: # 请求中没有图像时 cv_img = cv2.imread(self.default_path) # 此时的cv_img已经是opencv格式的图像了 self.get_logger().info(f&quot;默认图像位置：&#123;self.default_path&#125;&quot;) self.get_logger().info(f&quot;并未找到图片，已经加载到默认图像&quot;) start_time = time.time() # 获得人脸位置(即检测人脸)，传入参数(图像，上采样次数，使用模型)【关于上采样，其次数越高，图像精度也越高】 face_locations = face_recognition.face_locations(cv_img,self.upsample_flu,self.model) # 绘制人脸框 for top,bottom,right,left in face_locations: # 这里的top,bottom,right,left就是消息文件里定义的四个消息接口 response.top.append(top) response.bottom.append(bottom) response.right.append(right) response.left.append(left) response.use_time = time.time()-start_time # 消息接口里定义的use_time response.number = len(face_locations) #诶，这里face_locations数组的长度就是人脸的个数 return response # 因为传入的不是指针类型，故需要return一下def main(): rclpy.init() node = FaceService() rclpy.spin(node) rclpy.shutdown() 3.客户端实现步骤： 创建客户端； 构造Request,发送请求； 处理返回的Response,绘制人脸显示。 客户端代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import rclpyfrom rclpy.node import Nodefrom chapt4_interfaces.srv import Facedetectorimport cv2 import face_recognitionfrom ament_index_python.packages import get_package_share_directory # 获得功能包share目录绝对路径import osfrom cv_bridge import CvBridgeimport timeclass FaceClient(Node): def __init__(self): super().__init__(&#x27;face_client&#x27;) # 创建服务 参数：(消息接口，服务名称，回调函数) # self.service = self.create_service(Facedetector,&#x27;face_detect&#x27;, self.detect_face_callback) self.cvbridge = CvBridge() self.default_path = os.path.join(get_package_share_directory(&quot;demo_python_service&quot;),&quot;resource/test2.png&quot;) self.get_logger().info(&quot;人脸识别客户端！启动！！&quot;) # 创建客户端 参数：(服务类型，服务名称，回调函数)，注意这里传入的服务名称必须要与服务端一致 self.face_client = self.create_client(Facedetector,&#x27;face_detect&#x27;) self.image = cv2.imread(self.default_path) # 发送请求 def send_request(self): # 1.判断服务端是否上线 while self.face_client.wait_for_service(timeout_sec=0.1) is False: # 每隔0.1s就请求一下服务端 self.get_logger().info(&quot;服务端还未上线，请等待！&quot;) # 2.构造request request = Facedetector.Request() request.image = self.cvbridge.cv2_to_imgmsg(self.image) # 将opencv格式图像转化为消息接口可接受的图像格式 # 3.发送请求并等待完成 future = self.face_client.call_async(request) #(异步获取结果)现在的future中不包含响应结果，需要等待服务端处理完成才会把结果放到future中 # while not future.done(): # time.sleep(1.0) # 休眠当前进程，等待服务处理完成.会造成当前线程无法再接收服务端的返回，这样永远也不会得到future.done()--&gt;True # self可以相当于自定义类的一个对象 # rclpy.spin_until_future_complete(self,future) # 一边查看future是否完成，一边接收结果【等待服务端返回响应】 # 使用回调函数代替上面的方法 def result_callback(result_future): response = result_future.result() # 获取响应 self.get_logger().info(f&quot;已经收到响应，共收到&#123;response.number&#125;张人脸，耗时&#123;response.use_time&#125;秒&quot;) self.show_response(response) future.add_done_callback(result_callback) # 显示服务端的响应结果 def show_response(self, response): # 绘制人脸 for i in range(response.number): top = response.top[i] right= response.right[i] bottom = response.bottom[i] left = response.left[i] cv2.rectangle(self.image,(left,top),(right,bottom),(255,0,0),5) # 显示图片 cv2.imshow(&#x27;face_result&#x27;,self.image) cv2.waitKey(0) # 也是会阻塞spin的，使其无法正常运行def main(): rclpy.init() node = FaceClient() node.send_request() rclpy.spin(node) rclpy.shutdown() [注意]： ​ 1.python中不使用”!”取反，而直接使用”is False”or”not”。​ 2.发送请求并等待结果的过程处理，不要使用while进行简单处理，最好使用rclpy.spin_until_future_complete(参数) # 一边查看future是否完成，一边接收结果。​ 其中参数为调用call_async()返回的结果。​ 3.对于解决客户端发送请求响应更好的解决办法，可以采用回调函数（具体见face_client.py）​ 即让call_async()返回的结果调用add_done_callback()，里面放入回调函数，回调函数负责获取响应和显示响应。 一些关于在python的同步代码中调用异步函数： 当需要在同步函数中调用异步函数时，可以使用”asyncio.get_event_loop()”：来获取当前时间的循环； “asyncio.run_coroutine_threadsafe(异步函数，当前时间循环)”：将异步函数包装成一个可调用的线程安全的协程对象； “result()”：获取异步函数的返回值。 示例代码： 1234567891011import asyncio# 异步函数async def async_function(): await asyncio.sleep(1) # 模拟异步操作 return &quot;hello ros2&quot;#同步函数def sync_function(): loop = asyncio.get_event_loop() # 获取当前时间循环 future = asyncio.run_coroutine_threadsafe(async_function,loop) # 将异步函数包装成一个可调用的协程对象 result = future.result() 但在处理异步函数时，可能会出现异常情况。以下是应对措施： 常在”asyncio.run_coroutine_threadsafe()”的返回值上调用”add_done_callback(回调函数)”，该回调函数会在异步函数处理完后被调用，可以在里面处理异常。 1234567891011121314151617import asyncio# 异步函数async def async_function(): await asyncio.sleep(1) # 模拟异步操作 return &quot;hello ros2&quot;#同步函数def sync_function(): loop = asyncio.get_event_loop() # 获取当前时间循环 future = asyncio.run_coroutine_threadsafe(async_function,loop) # 将异步函数包装成一个可调用的协程对象 def callback(f): try: result = f.result() except Exception as e: print(f&quot;An Exception error:&#123;e&#125;&quot;) future.add_done_callback(callback) [补充]： 关于python中的异常捕获，常用如下结构： try: ​ … except Exception as e: ​ … 关于C++中的异常捕获，常用如下结构： try{ ​ … }catch(Exception e){ ​ … } python语言编写项目时，resource下的文件不会由”colcon build”拷贝到install下的share目录中，需要在setup.py文件的data_files中添加。添加语句：**(“share&#x2F;“ + package_name+”&#x2F;resource”,[“文件名”])**。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_TF关系的查询","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_TF关系的查询/","text":"ros_TF关系的查询1.原理：订阅话题&#x2F;tf &#x2F;tf_static 收集所有坐标系关系，进行计算。 2.核心代码： self.buffer_ &#x3D; Buffer() self.listener_ &#x3D; TransformListener(self.buffer_,self) self.timer_ &#x3D; self.create_timer(1,self.get_transform) [注]：其中self.get_transform是自定义的用于实时查询坐标关系的函数（因为可能会查询失败，故使用try…except）。 3.代码实现： （C++版） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/transform_stamped.hpp&quot; // 消息接口#include &quot;tf2/LinearMath/Quaternion.hpp&quot; // 提供Quaternion类#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot; // 消息类型转换函数#include &quot;tf2_ros/transform_listener.h&quot; //坐标监听类#include &lt;chrono&gt;#include &quot;tf2_ros/buffer.h&quot; // 提供buffer#include &quot;tf2/utils.h&quot; //提供四元数转欧拉角的函数 // map到base_link之间的坐标关系using namespace std::chrono_literals;using dynamic_tf = tf2_ros::TransformListener;using bf = tf2_ros::Buffer;class DynamicTfListener : public rclcpp::Node&#123;private: std::shared_ptr&lt;dynamic_tf&gt; listener_; // 声明一个广播器类的共享指针 rclcpp::TimerBase::SharedPtr timer_; std::shared_ptr&lt;bf&gt; buffer_;public: DynamicTfListener() : Node(&quot;listener_node&quot;)&#123; // 定时获取坐标变换 this-&gt;timer_ = this-&gt;create_wall_timer(1s,std::bind(&amp;DynamicTfListener::get_transform,this)); this-&gt;buffer_ = std::make_shared&lt;bf&gt;(this-&gt;get_clock()); this-&gt;listener_= std::make_shared&lt;dynamic_tf&gt;(*buffer_, this); // 在dynamic_tf里面创建一个发布者来发布tf_static的话题 &#125; void get_transform()&#123; // 到buffer_里查询坐标关系 try&#123; // 查询坐标关系[从&quot;target_point&quot;到&quot;base_link&quot;] const auto result = buffer_-&gt;lookupTransform(&quot;base_link&quot;,&quot;target_point&quot;, this-&gt;get_clock()-&gt;now(),rclcpp::Duration::from_seconds(2.0f)); // 获取查询结果 auto transform = result.transform.translation; auto rotation = result.transform.rotation; // 这个rotation是四元数格式 double y, p, r; tf2::getEulerYPR(rotation, y, p, r); RCLCPP_INFO(get_logger(),&quot;平移:%f,%f,%f&quot;,transform.x, transform.y, transform.z); RCLCPP_INFO(get_logger(),&quot;旋转:y:%f,p:%f,r:%f&quot;, y, p, r); &#125; catch(const std::exception&amp; e)&#123; RCLCPP_WARN(get_logger(),&quot;%s&quot;,e.what()); &#125; &#125;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc,argv); auto stb = std::make_shared&lt;DynamicTfListener&gt;(); rclcpp::spin(stb); rclcpp::shutdown();&#125; python版 1234567891011121314151617181920212223242526272829303132import rclpyfrom rclpy.node import Nodefrom geometry_msgs.msg import TransformStamped #消息接口from tf2_ros import TransformListener,Buffer #坐标监听器from tf_transformations import euler_from_quaternion# 四元数转欧拉坐标import math # 有角度转弧度函数class TfListener(Node): def __init__(self): super().__init__(&#x27;dynamic_listener&#x27;) self.buffer_ = Buffer() # 创建保存坐标变换信息的缓冲区 self.listener_ = TransformListener(self.buffer_,self) # 创建坐标变换的监听器 self.timer_ = self.create_timer(1,self.get_tf) # 创建一个固定周期的定时器，处理坐标信息 def get_tf(self): # 实时查询坐标关系 try: result = self.buffer_.lookup_transform(&#x27;base_link&#x27;,&#x27;bottle_link&#x27;,rclpy.time.Time(seconds=0.0),rclpy.time.Duration(seconds=5.0))#查询5s最新情况的坐标关系（这里的两个坐标系名可以作为参数传入）参数：[目标坐标系，源坐标系，当前时间] transform = result.transform self.get_logger().info(f&quot;平移:&#123;transform.translation&#125;&quot;) self.get_logger().info(f&quot;旋转：&#123;transform.rotation&#125;&quot;) # 四元数形式 rotation_eular = euler_from_quaternion([transform.rotation.x, transform.rotation.y,transform.rotation.z,transform.rotation.w]) self.get_logger().info(f&quot;旋转RPY:&#123;rotation_eular&#125;&quot;) # 欧拉角形式 except Exception as e: self.get_logger().warn(f&quot;获取坐标变换失败，原因&#123;e&#125;&quot;) def main(): rclpy.init() node = TfListener() rclpy.spin(node) rclpy.shutdown() 关于geometry_msgs.msg中Twist类(小海龟速度控制)的一些解读参考： https://www.cswamp.com/post/201 turtlesim.msg中的Pose类：管理小海龟位置消息","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_TF相关命令及原理探究","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_TF相关命令及原理探究/","text":"ros_TF相关命令及原理探究以下均是终端内输入的命令 1.TF工具的简单介绍 通过命令行使用TF：（e.g） 发布base_link到base_laser之间的变换:ros2 run tf2_ros static_transform_publisher –x 值 –y 值 -z 值 –roll 值 –pitch 值 –yaw 值 –frame-id id值 –child-frame-id id值。 ​ **[注]**：roll:翻滚 pitch:俯仰 yaw:偏航 发布base_laser到wall_point之间的变换:ros2 run2 tf2_ros static_transform_publisher –x 值 –y 值 -z 值–roll 值 –pitch 值 –yaw 值 –frame-id id值 –child-frame-id id值。 查询base_link到wall_point之间的关系：ros2 run tf2_ros tf2_echo id值1 id值2。 “3d-rotation-converter”：可以对坐标变化过程进行可视化。 “ros2 run tf2_tools view_frames”:查看TF树。 2. TF原理探究 ros2 topic list -t：查询话题及其对应接口。 ros2 interface show 接口：接口详细填充展示。 static_transform_publisher适合于查询雷达这种固定物件相较于机器人的位置关系。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_使用launch启动多个节点（基础版）","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/服务通信/ros_使用launch启动多个节点/","text":"使用launch启动多个节点1.使用launch启动多个节点： “generate_launch_description()”：产生launch描述【注意该函数名字是固定的】；其返回值也是固定的，返回actions动作(是一个数组)。 关于c++版本将launch文件写到install&#x2F;lib下，使用”install(DIRECTORY launch DESTINATION share&#x2F;${PROJECT_NAME})”。【更方便】 关于python版本将launch文件写到install&#x2F;lib下，使用” ‘share&#x2F;‘+package_name+’&#x2F;launch’,glob(‘launch&#x2F;*.launch.py’)” [注意]：上述操作需要引入globe包[from glob import glob]。 python中的glob函数：用于查找符合特定规则的文件，需要传入指定匹配的路径字符串，返回值为当前目录下满足条件的文件(不包含子目录下的)。 launch脚本的启动，”ros2 launch 包名 launch文件名”。 “source 路径”：将路径加入到系统环境变量中，相当于激活该区域。 2.使用launch传递参数： 声明一个launch参数：launch.actions.DeclareLaunchArgument(‘参数名字’,default_value&#x3D;”默认参数值”,(可选)description&#x3D;”给该参数一个备注”) 把launch的参数手动传给某节点： “launch.substitutions.LaunchConfiguration(‘参数名称’,”默认参数值”)”:对参数值进行替换。 在需要传入参数的节点处添加属性parameters&#x3D;[{节点参数名:launch.substitutions.LaunchConfiguration(‘参数名称’,default&#x3D;”默认参数值”)}]。3.运行的时候可以使用：ros2 launch 包名 launch文件名 自定义参数名:&#x3D;参数值。 3.launch三大组件(4.6.3) 动作：一个节点、一句打印、一段终端指令、另一个终端文件等 替换：使用launch的参数替换节点的参数值(未学) 条件：可以决定哪些节点启动，哪些不启动，相当于if(未学) 代码实例： 12345678910111213141516171819202122232425262728293031323334import launchimport launch_rosdef generate_launch_description(): # 生成launch描述【注意该函数名字是固定的】 # 1.声明一个launch函数 action_declare_arg_background_g = launch.actions.DeclareLaunchArgument(&#x27;bg_param&#x27;, default_value=&quot;150&quot;) action_node_turtle_client = launch_ros.actions.Node( # 传入包，可执行文件和日志输出的位置 package = &#x27;demo_cpp_service&#x27;, executable = &#x27;turtle_client&#x27;, output = &#x27;screen&#x27; ) action_node_turtle_control = launch_ros.actions.Node( # 传入包，可执行文件和日志输出的位置 package = &#x27;demo_cpp_service&#x27;, executable = &#x27;turtle_control&#x27;, output = &#x27;screen&#x27; ) # 2.把launch的参数手动传递给某个参数 &#x27;&#x27;&#x27;产生launch描述&#x27;&#x27;&#x27; action_node_turtle_node = launch_ros.actions.Node( # 传入包，可执行文件和日志输出的位置 package = &#x27;turtlesim&#x27;, executable = &#x27;turtlesim_node&#x27;, parameters =[&#123;&#x27;background_g&#x27;:launch.substitutions.LaunchConfiguration(&#x27;bg_param&#x27;,default=&quot;150&quot;)&#125;], output = &#x27;screen&#x27;, ) return launch.LaunchDescription([ action_node_turtle_client, action_node_turtle_control, action_node_turtle_node, ]) 【补充】： DeclareLaunchArgument(参数名称,default_name&#x3D;”默认取值”,description&#x3D;”参数的描述”)：声明launch文件可以修改的参数。【声明一个参数】 LaunchConfiguration(“在DeclareLaunchArgument中声明过的动态参数名称”)：在启动文件中用于动态配置参数、节点选项等的一种机制。可以在运行或者启动文件时灵活调整参数。一般与”DeclareLaunchArgument()”配套使用。【引用一个参数】 启动两个小海龟模拟器的例子： 12345678910111213141516171819202122232425262728293031import launchimport launch_rosfrom ament_index_python.packages import get_package_share_directory&quot;&quot;&quot;&quot;太诡异了这个代码OTZ&quot;&quot;&quot;def generate_launch_description(): # 这个动作实际上就是启动两个小海龟模拟器 # 动作1：启动其它launch action_launch_path = [get_package_share_directory(&#x27;turtlesim&#x27;),&#x27;/launch/&#x27;,&#x27;multisim.launch.py&#x27;] # 因为该launch文件在不同场景均需要启动，故可将其包含到不同的父launch文件中。 action_include_launch = launch.actions.IncludeLaunchDescription(launch.launch_description_sources.PythonLaunchDescriptionSource(action_launch_path)) # 动作2：打印这个路径 action_launch_info = launch.actions.LogInfo(msg=str(action_launch_path)) # 动作3：执行进程，即执行一个命令行 action_topic_list = launch.actions.ExecuteProcess(cmd=[&#x27;ros2&#x27;,&#x27;topic&#x27;,&#x27;list&#x27;]) # 动作4：组织动作成组，把多个动作放一个组 action_group = launch.actions.GroupAction([ # 动作5：定时器 launch.actions.TimerAction(period=2.0,actions=[action_include_launch]), launch.actions.TimerAction(period=4.0,actions=[action_topic_list]) ]) return launch.LaunchDescription([ # 执行顺序：打印路径--&gt;(执行动作组中的)启动两个小海龟模拟器--&gt;(执行动作组中的)执行一个命令行 action_launch_info, action_group ]) IncludeLaunchDescription()： 主要作用是包含其他Launch文件。 它是一个动作(launch.actions模块中的类)。 PythonLaunchDescriptionSource()： 是IncludeLaunchDescription()一个来源类，它指定所包含的launch文件是python格式的。 其它来源还包括XML和YAML格式。 上述两个函数一般结合使用：IncludeLaunchDescription(PythonLaunchDescriptionSource(…))，其应用场景有： 模块化启动：在大型项目中，可将不同功能节点拆分到多个launch文件中。使用IncludeLaunchDescription()将这些launch文件组合在一起。 复用已有launch文件：若某个launch文件在多个场景中均需要启动，可以将其包含在不同的父launch文件中。 传递函数：父launch文件通过launch_argument传递给子launch文件。 在配置文件中添加如下代码并运行colcon build可以将文件夹拷贝到install目录下。 1install(DIRECTORY launch urdf config DESTINATION share/$&#123;PROJECT_NAME&#125;) launch、urdf、config均为功能包下的文件夹。 只要节点可以通过”ros2 run 功能包 节点”运行的，就可以放在launch_ros.actions.Node()中进行launch批量运行。 【注】： &#x3D;&#x3D;Node常用参数：&#x3D;&#x3D; package(str)：包含节点的包名 executable(str)：可执行节点的名称 name(str)：节点名【用于覆盖默认节点名，默认为空】(ROS中不允许节点名相同) namespace(str)：节点的命名空间【默认为空，设置后会影响节点的话题、服务等前缀】 output(str)：节点输出位置【screen&#x2F;log】 parameters(list)：传递参数给节点【可以是字典或YAML文件路径列表】 remappings(list)：话题、服务或参数的重映射。格式为列表，元素是元组：(‘旧名称’，’新名称’) arguments(list)：额外的命令行参数，通常用于–ros-args传递日志级别等配置。[‘操作’,操作值] 关于launch_ros.actions.Node()中的参数parameters和arguments，parameters是将参数传递给节点的参数，即运行命令”ros2 run rviz2 rviz2 –ros-args -p xx&#x3D;xxxvalue”；而arguments传递参数其实是在命令行后面加东西，即相当于命令”ros2 run rviz2 rviz2 -d 需要加载的文件路径”。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Service_communication","slug":"Service-communication","permalink":"http://example.com/tags/Service-communication/"}]},{"title":"ros_动态TF的发布","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_动态TF的发布/","text":"动态TF的发布原理：不停发布 &#x2F;tf 话题 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/transform_stamped.hpp&quot; // 消息接口#include &quot;tf2/LinearMath/Quaternion.hpp&quot; // 提供Quaternion类#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot; // 消息类型转换函数#include &quot;tf2_ros/transform_broadcaster.h&quot; //坐标广播器#include &lt;chrono&gt;// map到base_link之间的坐标关系using namespace std::chrono_literals;using dynamic_tf = tf2_ros::TransformBroadcaster;class DynamicTfBc : public rclcpp::Node&#123;private: std::shared_ptr&lt;dynamic_tf&gt; broadcaster_; // 声明一个广播器类的共享指针 rclcpp::TimerBase::SharedPtr timer_;public: DynamicTfBc() : Node(&quot;dynamic_node&quot;)&#123; // ??????这里为啥一个有this-&gt; ,一个没有this-&gt;（哦哦，是因为create_wall_timer是在rclcpp::Node节点里的，而我们创建的类刚好继承了Node） this-&gt;broadcaster_ = std::make_shared&lt;dynamic_tf&gt;(this); // 在dynamic_tf里面创建一个发布者来发布tf_static的话题 // this-&gt;publish_tf(); //静态发布，只能发布一次 //参数： (类模板，对象指针) this-&gt;timer_ = this-&gt;create_wall_timer(100ms,std::bind(&amp;DynamicTfBc::publish_tf,this)); &#125; void publish_tf()&#123; // 创建消息接口 geometry_msgs::msg::TransformStamped tf; tf.header.stamp = this-&gt;get_clock()-&gt;now(); tf.header.frame_id = &quot;map&quot;; tf.child_frame_id = &quot;base_link&quot;; // 给平移部分赋值 tf.transform.translation.x = 2.0; tf.transform.translation.y = 3.0; tf.transform.translation.z = 0.0; // 定义一个四元数类 tf2::Quaternion q; // 把已知欧拉角度转成四元数 q.setRPY(0.0, 0.0, 30*M_PI/180); // 给旋转部分赋值 tf.transform.rotation = tf2::toMsg(q); // 把消息发布出去 this-&gt;broadcaster_-&gt;sendTransform(tf); &#125;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc,argv); auto stb = std::make_shared&lt;DynamicTfBc&gt;(); rclcpp::spin(stb); rclcpp::shutdown();&#125; 不同于静态坐标只用发布一次，动态坐标需要一个定时器，不断的发送坐标。 静态和动态坐标的发布，核心逻辑都是先创建消息接口，再填充消息接口，最后把消息发布出去。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_git进阶","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_git进阶/","text":"ros_git进阶 “git status”:可以查看修改的文件名。 “git diff” or “git diff 文件名”:可以查看具体修改内容。 还可以在vscode中的”源代码管理”下可视化查看修改的文件和内容。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_常用可视化工具rqt&Rviz和数据记录工具ros2 bag","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_常用可视化工具rqt&Rviz和数据记录工具ros2 bag/","text":"常用可视化工具rqt&amp;Rviz和数据记录工具ros2 bag 可以把安装时在终端中输入的固定版本换成”$ROS_DISTRO”，以动态获取ROS版本。 在终端中输入”rviz2”可以启动该工具。 “ros2 bag record 订阅的话题名字”：可以记录下话题，方便下次重播。 “ros2 bag play 记录的文件名”：可以播放记录的文件。 【未成功实践版】 【补充】：关于Rviz 是一款三维可视化工具，可以很好的兼容基于ROS软件框架的机器人平台。 在Rviz中可以使用可扩展标记语言XML对机器人、周围物体等任何实物进行尺寸、质量、位置、材质、关节等属性的描述，并且在界面中呈现出来。 还可以通过图形化的方式，实时显示机器人传感器的信息、机器人的运动状态、周围环境变化等信息。 总的说来，Gazebo用来创造数据，Rviz用来显示数据。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"ros_静态TF的发布","date":"2025-09-20T16:00:00.000Z","path":"2025/09/21/ros2/工具/ros_静态TF的发布/","text":"ros_静态TF的发布从机械臂底座到相机–&gt;使用静态TF发布 原理：发布 &#x2F;tf_static话题。 使用transform3d库可以让四元数和欧拉坐标相互转换。 [注]：关于为什么静态TF只发布一次，但之后再去订阅还有消息？原因就在于tf_static每发布一次就会永久保留当前最新数据，当下次有订阅者订阅时还可以有内容发布。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/transform_stamped.hpp&quot; // 消息接口#include &quot;tf2/LinearMath/Quaternion.hpp&quot; // 提供Quaternion类#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.hpp&quot; // 消息类型转换函数#include &quot;tf2_ros/static_transform_broadcaster.h&quot; //静态坐标广播器// map到target_point之间的坐标关系using static_tf = tf2_ros::StaticTransformBroadcaster;class StaticTfBc : public rclcpp::Node&#123;private: std::shared_ptr&lt;static_tf&gt; broadcaster_; // 声明一个广播器类的共享指针public: StaticTfBc() : Node(&quot;static_node&quot;)&#123; this-&gt;broadcaster_ = std::make_shared&lt;static_tf&gt;(this); // 在static_tf里面创建一个发布者来发布tf_static的话题 this-&gt;publish_tf(); //静态发布，只能发布一次 &#125; void publish_tf()&#123; // 创建消息接口 geometry_msgs::msg::TransformStamped tf; tf.header.stamp = this-&gt;get_clock()-&gt;now(); tf.header.frame_id = &quot;map&quot;; tf.child_frame_id = &quot;target_point&quot;; // 给平移部分赋值 tf.transform.translation.x = 5.0; tf.transform.translation.y = 3.0; tf.transform.translation.z = 0.0; // 定义一个四元数类 tf2::Quaternion q; // 把已知欧拉角度转成四元数 q.setRPY(0.0, 0.0, 60*M_PI/180); // 给旋转部分赋值 tf.transform.rotation = tf2::toMsg(q); // 把消息发布出去 this-&gt;broadcaster_-&gt;sendTransform(tf); &#125;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc,argv); auto stb = std::make_shared&lt;StaticTfBc&gt;(); rclcpp::spin(stb); rclcpp::shutdown();&#125; “四元数.setRPY(x,y,z)”：将传入的欧拉角度(弧度制)转换为四元数。 静态坐标的发布用到了静态坐标广播器。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"Linux基础之环境变量","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_Linux环境变量/","text":"Linux基础之环境变量 ros2 命令就是通过环境变量来寻找功能包的。 printenv:可以用来打印环境变量。 printenv | grep 筛选内容：可以查找所选取的环境变量。 当出现报错“Package xx not found”时，可以检查AMENT_PREFIX_PATH下的lib是否有这个包。 AMENT_PREFIX_PATH（路径）的初始值是由默认脚本设置的，该默认脚本位置为:~&#x2F;.bashrc[该文件为隐藏文件]。 使用 ls -a可以查看当前目录下的隐藏文件。 “source &#x2F;opt&#x2F;ros&#x2F;jazzy&#x2F;setup.bash”语句用于设置环境变量。后面经常会用”source install&#x2F;setup.bash”来将colcon build生成的可执行文件写入Install文件中。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"多线程与回调函数","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_多线程与回调函数(Python版)/","text":"多线程与回调函数┗|｀O′|┛ 嗷~🍖 ~w(ﾟДﾟ)w 回调函数：把统计函数当作参数传递给下载函数，下载完成自己第一时间调用。 “threading.get_ident()”：可以得到线程编号(python中)；”this_thread.get_id()”：可以得到线程编号(c++中)。 “echo “文字” “&gt; 文件名,可生成对应文件,并将文字写入。 “python3 -m http.server”：启动python3的内置服务器。 一个程序默认是在一个线程中完成的，如果需要多个线程并行，则需要使用thread。 与python中的多线程不同，c++中的线程一旦创建就立刻运行，并阻塞当前进程，所以需要用”thread.detach()”将其与当前进程进行分离。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"有用的C++特性","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_常用的C++特性/","text":"有用的C++特性1.auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名字”) node的类型是自动推导的。 2.智能指针&#x2F;共享指针:专治占着内存不使用的程序。 指针.use_count()：得到指针引用次数。 指针.get():得到指向的内存地址。 指针-&gt;c_str():得到指针指向内存地址数据。 对象.函数(参数):直接通过对象访问成员 指针-&gt;函数(参数):通过指向对象的指针访问成员。 具体使用哪一个要看“访问者是对象本身，还是指向对象的指针”。 CPP的”colcon build”会添加到环境变量，所以没有source也能运行。(但最好还是build一下好) 💥3.lambda表达式(放在函数里面用)即换个语法写函数：capture list-(parameter list)&gt;return type{function body} 注:常用[&amp;](输入列表)-&gt;void{函数体}，其中void表示不返回 捕获列表可以为空，也可以使用默认捕获模式&amp;或者&#x3D;表示按引用或者值捕获所有外部变量。 💥4.函数包装器：统一自由函数、成员方法和Lambda函数 对于自由函数：std::function&lt;函数返回值(函数传入参数)&gt; 给该函数一个新名字 &#x3D; 原自由函数名; 对于lambda函数: 同自由函数; 对于成员方法【较复杂】： std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应函数的指针&#x2F;模板地址,对象的指针,参数数量占位符); or std::function&lt;方法返回值(方法传入参数)&gt; 给该函数一个新名字 &#x3D; std::bind(类对应创造的对象,类中要调用的方法,参数数量占位符); 注：关于绑定bind很好解决了调用成员函数必须要先创造一个成员函数的问题，它直接绑定了一个对象。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"补充一些基础编程知识","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/编程基础补充/","text":"补充一些基础编程知识1.每次修改代码文件后，需要重新colcon build构建再运行。 2.面向对象编程都可以创建类，类是对事物的封装。 3.对于继承：python： “from 父类所在文件 import 父类”; class 子类(父类): ; “.super().init(父类构造需要的参数)” :调用父类的init方法。 c++: class 子类 : public 父类 【例如】： 1Class PersonNode : public rclcpp::Node - 子类(const 参数类型 &amp;参数1,…):父类(const 参数类型 &amp;父类构造所需参数); 注：创建共享指针，”auto 节点名字 &#x3D; std::make_shared&lt;类名&gt;(“节点名”)” 注： 使用共享指针需要头文件 RCLCPP_INFO(节点名字-&gt;get_logger(),”要打印出来的文字信息”); 注意这个函数的参数形式。 传入时格式为”string”,输出时为”%s”,则可以在输出时加上”.c_str()进行强制转换”。【c_str():将str类型转换为c语言格式的字符串】 CPP文件中，有时候构造函数时会在传入参数前加上”const”（加在类型前）和”&amp;”（加在变量名前），加上前者是希望用户不要对传入的数据进行修改，加上后者(称为拷贝指针)是为了避免不必要的数据拷贝，以提高运行效率。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"编写第一个ROS节点","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_编写第一个C++节点&Python节点/","text":"编写第一个ROS节点ros中编写C++节点 当项目较小时，可以在终端中使用”g++ cpp文件名”，得到一个可执行文件，再使用“.&#x2F;可执行文件名”运行程序。 当项目较大时，使用CMake得到生成指令。过程：编写一个CMakeList.txt文件(文件名不能改)-&gt;使用cmake指令转化为Makefile文件-&gt;使用make指令转化为exe文件。 ros中编写Python节点1.直接编写后就可以使用”run 文件名”进行运行。 节点的特性 执行具体任务的进程 独立运行可执行文件 可使用不同的编程语言 可分布运行在不同主机 通过节点名称进行管理","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"git命令基础入门","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_git入门/","text":"git命令基础入门 克隆仓库 12git clone 地址cd repo 创建新分支 1git checkout -b new-feature 暂存文件：将修改过的文件添加到暂存区 12git add 文件名git add . # 添加所有修改的文件 提交更改：将暂存区的更改提交到本地仓库 1git commit -m &quot;附加信息&quot; 拉取最新更改：在推送本地之前，最好从远程仓库拉取最新的更改，以免冲突 12git pull origin maingit pull origin new-feature #添加在新的分支上 合并更改：在PR审核过合并后，可以将远程仓库的主分支合并在本地分支 123git checkout maingit pull origin maingit merge new-feature 删除分支 12git branch -d new-featuregit push origin --delete new-feature [接下来是基础但较有用的功能] git status：查看仓库当前状态，显示有变更的文件。 git diff：比较文件的不同，即暂存区和工作区的差异。 git difftool：使用外部工具比较文件差异。 git reset：回退版本（即把暂存区的文件撤出）。 git rm：将文件从暂存区和工作区删除。 git mv：移动或者重命名工作区文件。 git notes：添加注释。 git checkout：分支切换。|git switch：更清晰的分支切换。 git restore：恢复或撤销文件更改。 git show：显示git对象详细信息。 git log：查看历史提交记录。 git blame ：以列表形式查看指定文件的历史修改记录。 关于远程操作： git remove：远程仓库操作。 git fetch：从远程获得代码。 git pull：下载远程代码并合并。 git push：上传远程代码并合并。 git submodule：管理包含其他Git仓库的项目。 关于git忽略文件的命令 123git add .gitinore (在gitinore文件中添加不需要加入缓冲区的文件)git commit -m &quot;注释&quot;：添加忽略文件；rm -rf .git ：删除 .git目录。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信介绍","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信介绍/","text":"话题通信介绍1.话题通信有四个关键点：发布者、订阅者、话题名称和话题类型。 2.”ros2 node info &#x2F;节点名字”：查看接口定义。（有发布者以及订阅者等相关信息）【发布者下的内容格式：话题：消息接口】 3.”ros2 topic echo &#x2F;话题名字”：查看话题内容。 4.”ros2 topic info &#x2F;话题名字”：查看消息接口。 5.”ros2 interface show 消息接口”：找到消息接口的定义。 6.”ros2 topic pub &#x2F;话题名字 消息接口 消息接口样本格式的数据填充”:使用话题控制机器人。【使用订阅者话题】 注：消息接口样本格式的数据填充可以在”消息接口的定义”处查看，每下一个级别，需要加”{}”，参数名称后的”:”和自定义参数值之间需要加一个空格。 当自定义消息接口或者调用话题接口时常见步骤： “ros2 topic list -t”：返回话题及对应的消息接口。 “ros2 interface show 消息接口”：查消息接口的详细内容 | “ros2 interface proto 消息接口”：显示消息模板。 &#x3D;&#x3D;特点：&#x3D;&#x3D; 遵循发布&#x2F;订阅模型 订阅者和发布者可以不唯一 异步通信机制 .msg文件定义通信的消息结构 &#x3D;&#x3D;创建话题发布者的程序流程：&#x3D;&#x3D;✨ 编程接口初始化-&gt;创建节点并初始化-&gt;创建发布者对象-&gt;创建并填充话题消息-&gt;发布话题消息-&gt;销毁节点并关闭接口。 &#x3D;&#x3D;创建话题订阅者的程序流程：&#x3D;&#x3D;🎄 创建接口初始化-&gt;创建节点并初始化-&gt;创建订阅者对象-&gt;回调函数处理话题数据-&gt;销毁节点并关闭接口 【补充】：使用”rqt_graph”：可以查看当前节点结构。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战_自定义实现实时状态信息查询小工具","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_自定义实现实时状态信息查询小工具/","text":"话题通信实战_自定义实现实时状态信息查询小工具需求： 通过该工具可以看到系统的实时状态信息，包括记录信息的时间、主机名称、cpu使用率、内存使用率、内存总大小、剩余内存、网络接收数据量和网络发送数据量。 要有一个简单的界面，可以将系统信息显示出来。 要能在局域网内其他主机上查看数据。 分析： 要能获取系统状态信息–&gt;python库psutils; 要有一个展示界面–&gt;QT; 要能共享数据–&gt;ROS2话题。总体架构：&#x2F;sys_status_pub—-&gt;&#x2F;sys_status—&gt;&#x2F;sys_status_display 步骤： 1. 自定义通信接口【注】： builtin_interfaces()：提供时间戳； 按照需求编写一个.msg的接口文件。注意：msg文件的命名必须使用驼峰命名法。 需要在对应的CMakeList.txt文件中添加rosidl_generate_interfaces()，其为cmake函数，用于将msg消息接口定义文件转化为库或者头文件类。 具体实现： 123rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/SystemStatus.msg&quot; DEPENDENCIES builtin_interfaces 代码实现： 1234567builtin_interfaces/Time stamp #记录时间戳string host_name #主机名float32 memory_percent #主存使用率float32 cpu_percent #CPU使用率float32 memory_available #主存剩余率float64 net_send #网络发送率float64 net_recv #网络接收率 2. 系统信息获取和发布【注】：使用psutils和platform两个库主要用于获取信息；其中psutil库可以查询cpu利用率、内存情况和网络输出输入情况等。platform库用于查询主机名字等。 代码实现： 1234567891011121314151617181920212223242526272829303132333435import rclpyfrom rclpy.node import Nodefrom status_interfaces.msg import SystemStatusimport psutilimport platformclass SystemStatusPub(Node): def __init__(self, node_name): super().__init__(node_name) self.status_publisher_ = self.create_publisher(SystemStatus, &#x27;sys_status&#x27;, 10) self.time_ = self.create_timer(1.0, self.timer_callback) def timer_callback(self): cup_percent = psutil.cpu_percent() memory_info = psutil.virtual_memory() # 查看当前内存情况 net_io_counters = psutil.net_io_counters() # 查看网络输入输出情况 msg = SystemStatus() # 自定义的通信接口经过一系列操作变成了类 msg.stamp = self.get_clock().now().to_msg() # 获取当前时间戳并转化为信息 msg.host_name = platform.node() # 返回主机名字 msg.cpu_percent = cup_percent msg.memory_percent = memory_info.percent msg.memory_available = memory_info.available /1024/1024# 有效内存 msg.net_send = net_io_counters.packets_sent /1024/1024 # 将字节转换为兆字节 msg.net_recv = net_io_counters.packets_recv /1024/1024 self.get_logger().info(f&quot;发布相关信息：&#123;msg&#125;&quot;) self.status_publisher_.publish(msg)def main(): rclpy.init() sys_status_pub = SystemStatusPub(&quot;status_publish&quot;) rclpy.spin(sys_status_pub) rclpy.shutdown() 3.订阅数据并用QT显示【注】 使用new()创建类后需要手动释放内存，只有遇到”delete()”时才会调用析构函数 使用”类名 创建的类”这种类定义声明的方式使用后不需要手动释放，这种类中的析构函数会自动执行。 关于类对象的三种创建方法： 第一：Test test1; 栈中分配，由os进行内存分配和管理。 第二：Test test2 &#x3D; Test(); 栈中分配，由os进行内存分配和管理。 第三：Test *test3 &#x3D; new Test(); 堆中分配，由管理者进行内存分配和管理，显式使用delete()释放内存空间。 “.”:是结构体引用，”-&gt;”:是指针引用。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;QApplication&gt;#include &lt;QLabel&gt;#include &lt;QString&gt;#include &lt;rclcpp/rclcpp.hpp&gt;#include &quot;status_interfaces/msg/system_status.hpp&quot;using SystemStatus = status_interfaces::msg::SystemStatus; // 将包名进行改名class SystemStatusDisplay : public rclcpp::Node&#123;private:/*data*/ rclcpp::Subscription&lt;SystemStatus&gt;::SharedPtr subscriber_;public: QLabel *label_ = new QLabel(); SystemStatusDisplay():Node(&quot;sys_status_display&quot;)&#123; // 使用lambda函数作为回调函数,接收的函数为共享指针 subscriber_ = this-&gt;create_subscription&lt;SystemStatus&gt;(&quot;sys_status&quot;,10,[&amp;](const SystemStatus::SharedPtr msg)-&gt;void&#123; label_-&gt;setText(get_qstr_from_msg(msg)); &#125;); label_-&gt;setText(get_qstr_from_msg(std::make_shared&lt;SystemStatus&gt;())); // 初始给label传一个空的共享指针，这样有表头没有具体内容。 label_-&gt;show(); &#125;; QString get_qstr_from_msg(const SystemStatus::SharedPtr msg)&#123; // 将获取到的msg内容进行拆分组装 std::stringstream show_str; show_str &lt;&lt; &quot;==========状态可视化显示工具============\\n&quot; &lt;&lt; &quot;数 据 时 间:\\t&quot; &lt;&lt; msg-&gt;stamp.sec &lt;&lt; &quot;\\ts\\n&quot; &lt;&lt; &quot;主 机 名:\\t&quot; &lt;&lt; msg-&gt;host_name &lt;&lt; &quot;\\t\\n&quot; &lt;&lt; &quot;cpu 利 用 率:\\t&quot; &lt;&lt; msg-&gt;cpu_percent &lt;&lt; &quot;\\t%\\n&quot; &lt;&lt; &quot;内 存 利 用 率:\\t&quot; &lt;&lt; msg-&gt;memory_percent &lt;&lt; &quot;\\t%\\n&quot; &lt;&lt; &quot;剩 余 有 效 内 存:\\t&quot; &lt;&lt; msg-&gt;memory_available &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;网 络 发 送 量:\\t&quot; &lt;&lt; msg-&gt;net_send &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;网 络 接 收 量:\\t&quot; &lt;&lt; msg-&gt;net_recv &lt;&lt; &quot;\\tMB\\n&quot; &lt;&lt; &quot;=======================================&quot;; return QString::fromStdString(show_str.str()); &#125;;&#125;;int main(int argc, char* argv[])&#123; rclcpp::init(argc, argv); QApplication app(argc, argv); //类对象的声明 auto node = std::make_shared&lt;SystemStatusDisplay&gt;(); // 创建一个模板为SystemStatusDisplay的共享指针 std::thread spin_thread([&amp;]()-&gt;void&#123; rclcpp::spin(node); // 为其单独开一个线程 &#125;); spin_thread.detach(); app.exec(); rclcpp::shutdown(); return 0;&#125; 关于rclcpp::spin()：会阻塞调用它的线程，直到与它关联的节点被销毁。函数执行期间，它执行以下操作： 处理回调：调用所有已注册的回调，包括订阅者的消息回调、服务的请求回调、定时器回调。 事件循环：处理所有ROS通信相关的事件，确保节点能够响应外部消息和服务请求。 阻塞执行：该函数会一直运行，直到调用其的节点被销毁或者显示地调用rclcpp::shutdown()。 学习收获： 如何根据需求自定义.msg文件 ； 如何获取电脑基本参数信息； 如何进行字符串流输出。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战-通过话题发布小说","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战-通过话题发布小说/","text":"话题通信实战-通过话题发布小说需求：下载小说并通过话题间隔5s发布一行核心问题： 1. 怎么下载小说？ 使用requests; 2. 怎么发布？确定名字和接口; 3. 怎么间隔5s发布？Timer定时器。 1. 定义一个继承rclpy.node的节点 属性： 存放小说的队列 发布者 定时器 方法： 判断队列大小的回调函数 下载函数 【注】： 创建发布者代码： 1self.create_publisher(消息接口,&#x27;自定义话题名字&#x27;,服务质量配置) 关于服务质量配置是给一个表示队列大小的数字。create_publisher()的返回值为 一个发布者。 创建定时器代码： 1self.create_timer(时间间隔周期,自定义回调函数) create_timer()没有返回值，其会按照传入的间隔周期去调用回调函数。 2. 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041import rclpyfrom rclpy.node import Nodeimport requestsfrom example_interfaces.msg import Stringfrom queue import Queueclass pubNode(Node): def __init__(self, node_name): super().__init__(node_name) self.get_logger().info(f&quot;&#123;node_name&#125;,启动！&quot;) self.novels_queue = Queue() # 创建队列 # 参数依次为：消息接口，话题的名字(自定义)，服务质量配置（给一个表示队列大小的数字;返回值为发布者 self.novel_publisher_ = self.create_publisher(String,&#x27;novel&#x27;,100) self.create_timer(5,self.timer_callback) # 参数：时间间隔周期，回调函数 # 判断队列大小-&gt;若大于0则从队列里面取一行数据-&gt;组装成消息-&gt;发布消息 def timer_callback(self): # 设置一个回调函数 if self.novels_queue.qsize() &gt; 0: line = self.novels_queue.get() msg = String() # 组装数据 msg.data = line self.novel_publisher_.publish(msg) self.get_logger().info(f&quot;发布了：&#123;msg&#125;&quot;) # 下载：获取请求-&gt;按行分割-&gt;放到队列里面 def download(self, url): res = requests.get(url) res.encoding = &#x27;utf-8&#x27; text = res.text # text.splitlines() #把下载的内容按行分割 self.get_logger().info(f&quot;下载&#123;url&#125;,&#123;len(text)&#125;&quot;) for line in text.splitlines(): self.novels_queue.put(line) def main(): rclpy.init() node = pubNode(&quot;novel_pub&quot;) node.download(&quot;http://0.0.0.0:8000/novel1.txt&quot;) rclpy.spin(node) rclpy.shutdown() 【笔记】： example_interface：样例消息类。 回调函数依赖的成员变量容器要提前初始化。 “python -m http.server”：在当前目录启动一个HTTP服务器，默认监听端口为8000。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实训-订阅pose实现闭环控制","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_订阅pose实现闭环控制/","text":"话题通信实训-订阅pose实现闭环控制核心任务： 1. 小海龟怎么听我的？发布话题； 2. 小海龟现在在哪里？订阅话题； 3. 怎么根据当前位置和目标位置计算角速度和线速度？两点之间距离-&gt;线速度 当前朝向和目标朝向-&gt;角速度。 1.定义控制小海龟的类 属性： 发布者的智能指针 订阅者的智能指针 目标坐标点、比例系数（用于控制运行速度）、最大速度 方法： 获取当前位置，并计算新位置发布出去的函数 【注】： 不同于python，C++在创建实例前需要声明。以下是发布者和订阅者声明的代码： 12rclcpp::Publisher&lt;消息接口&gt;::SharedPtr publisher_; //发布者的智能共享指针rclcpp::Subscription&lt;消息接口&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 发布者和订阅者创建代码： 123publisher_ = this-&gt;create_publisher&lt;消息接口&gt;(&quot;话题名称&quot;,qos); //创建发布者subscriber_ = this-&gt;create_subscription&lt;消息接口&gt;(&quot;话题名称&quot;,qos,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); //创建订阅者 关于回调函数，这里采用的是将成员方法放入函数包装器中（其实用lambda函数更简单）。函数形式：std::bind(&amp;类节点实例化, 对象指针, 参数占位符))。”订阅者的话题名称”要与对应的发布者消息接口对应。 2.完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &quot;turtlesim/msg/pose.hpp&quot;#include &lt;chrono&gt;using namespace std::chrono_literals;class TurtleControlNode: public rclcpp::Node&#123;private: // rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能共享指针 rclcpp::Subscription&lt;turtlesim::msg::Pose&gt;::SharedPtr subscriber_; //订阅者的智能共享指针 double target_x_&#123;1.0&#125;; double target_y_&#123;1.0&#125;; double k_&#123;1.0&#125;; //比例系数【间接控制速度】 double max_speed_&#123;3.0&#125;; //最大速度 public: explicit TurtleControlNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); // 这里传入运动控制的消息接口，由其发布控制信息给小海龟 subscriber_ = this-&gt;create_subscription&lt;turtlesim::msg::Pose&gt;(&quot;/turtle1/pose&quot;,10,std::bind(&amp;TurtleControlNode::on_pose_received,this, std::placeholders::_1)); // timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleControlNode::timer_callback,this)); &#125; // 获取当前位置，并计算新位置发布出去 void on_pose_received(const turtlesim::msg::Pose::SharedPtr pose)&#123; //参数：收到数据的共享指针 // 1.获取当前位置 auto current_x = pose-&gt;x; auto current_y = pose-&gt;y; RCLCPP_INFO(get_logger(),&quot;获取当前位置:x=%f,y=%f&quot;,current_x,current_y); // 2.计算当前海龟位置跟目标位置之间的距离差和角度差。 auto distanc e = std::sqrt((target_x_-current_x)*(target_x_-current_x)+(target_y_-current_y)*(target_y_-current_y)); // 目标角度和当前角度的差值 auto angle = std::atan2((target_y_-current_y),(target_x_-current_x))- pose-&gt;theta; // 3.控制策略 auto msg = geometry_msgs::msg::Twist(); if(distance&gt;0.1)&#123; if(fabs(angle)&gt;0.2)&#123; msg.angular.z = fabs(angle); //如果角度差大于0.2则改变角度(进行旋转) &#125;else&#123; msg.linear.x = k_*distance; //如果角度差不大，则提高速度 &#125; &#125; //限制最大线速度 if(msg.linear.x &gt; max_speed_)&#123; msg.linear.x = max_speed_; &#125; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleControlNode&gt;(&quot;turtle_control&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 学习收获： 学会了C++版本的发布者和订阅者的声明和创建。 在小海龟程序中，可以通过”urtlesim&#x2F;msg&#x2F;pose”接口来获取当前海龟位置，通过”geometry_msgs&#x2F;msg&#x2F;twist”接口来控制海龟的运动。 在关键字前添加”explicit”：防止类进行单参数隐式转换。即类的构造函数只有一个参数时，可以通过唯一的参数值来构造该类。 c++中的”::”：访问命名空间内的标识符，避免不同命名空间的同名冲突。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战_发布控制速度海龟画圈","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_发布控制速度海龟画圈/","text":"话题通信实战_发布控制速度海龟画圈核心要求： 如何让小海龟按着我的指令？话题 怎么画圆？线速度&#x2F;角速度&#x3D;半径 发一下就停，如何循环发？定时器 1.创建类 属性： 定时器 发布者的智能指针 方法： 定时发布控制信息的函数 【注】： 定时器声明代码： 1rclcpp::Publisher&lt;消息接口&gt;::SharedPtr 发布者实例名; 定时器创建代码： 1timer_ = this-&gt;create_wall_timer(间隔时长, 回调函数); “create_wall_timer()”也称为墙钟函数，它与一般的定时器函数相比使用的不是ros时间，而是系统时间。 2.完整代码： 123456789101112131415161718192021222324252627282930313233#include &quot;rclcpp/rclcpp.hpp&quot;#include &quot;geometry_msgs/msg/twist.hpp&quot;#include &lt;chrono&gt;using namespace std::chrono_literals;class TurtleCircleNode: public rclcpp::Node&#123;private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr publisher_; //发布者的智能指针public: explicit TurtleCircleNode(const std::string&amp; node_name):Node(node_name) &#123; publisher_ = this-&gt;create_publisher&lt;geometry_msgs::msg::Twist&gt;(&quot;/turtle1/cmd_vel&quot;,10); timer_ = this-&gt;create_wall_timer(1000ms, std::bind(&amp;TurtleCircleNode::timer_callback,this)); &#125; void timer_callback()&#123; auto msg = geometry_msgs::msg::Twist(); msg.linear.x = 1.0; msg.angular.z = 0.5; publisher_-&gt;publish(msg); &#125;&#125;;int main(int argc,char* argv[])&#123; rclcpp::init(argc, argv); auto node = std::make_shared&lt;TurtleCircleNode&gt;(&quot;turtleCircle&quot;); rclcpp::spin(node); rclcpp::shutdown(); return 0;&#125; 学习收获： 学会了墙钟定时器的声明和创建","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"话题通信实战-订阅小说并合成语音","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/话题通信/ros_话题通信实战_订阅小说并合成语音/","text":"话题通信实战-订阅小说并合成语音核心要求： 1. 怎么订阅？ 2. 用什么朗读文本？ Espeak 3. 小说来的快，读得慢怎么办？使用队列 1. 定义一个继承rclpy.node的节点类 属性： 存放小说的队列 订阅者 线程对象 方法： 回调函数：用于不断将小说放入队列中。 线程函数：检测到队列中存在小说就开始朗读。 下载小说的函数。 【注】： 创建订阅者的代码： 1self.create_subscription(消息接口, &quot;自定义话题名称&quot;, 回调函数, qos) 这里的qos就是前文提到的ros2中的通信服务质量，通常是一个数字；函数返回值为一个订阅者实例。还要注意的是，这里的**”自定义话题名称”需要与话题发布者的名称相同**，这样才能订阅到话题。 创建线程的代码： 12self.speech_thread_=threading.Thread(target=线程函数,传给线程函数的tuple类型参数) self.speech_thread_.start() # 注意python的线程不会自己启动，需要手动开始 “传给线程函数的tuple类型参数”有默认值，可以不传参数。 2. 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import espeakng import rclpyfrom rclpy.node import Nodeimport requestsfrom example_interfaces.msg import Stringfrom queue import Queueimport threadingimport timeclass Novel_sub_Node(Node): def __init__(self, node_name): super().__init__(node_name) self.novel_queue = Queue() self.get_logger().info(f&quot;&#123;node_name&#125;,启动！&quot;) # 创建订阅者 参数：信息类型，话题名称（这里一定要与发布者取的名字一致），回调函数,qos self.novel_sub_ = self.create_subscription(String, &quot;novel&quot;, self.novel_callback, 10) self.speech_thread_ = threading.Thread(target=self.speak_thread) self.speech_thread_.start() # 注意python的线程不会自己启动，需要手动开始 def novel_callback(self, msg): self.novel_queue.put(msg.data) def speak_thread(self): speaker = espeakng.Speaker() speaker.voice = &#x27;zh&#x27; while rclpy.ok(): # 检测当前ROS上下文是否ok；用于检查ROS2系统的运行状态，通常用于控制循环的执行，确保在系统关闭时能够优雅地退出。 if self.novel_queue.qsize() &gt; 0: text = self.novel_queue.get() self.get_logger().info(f&quot;朗读：&#123;text&#125;&quot;) speaker.say(text) speaker.wait() else: # 当朗读队列为空时 time.sleep(1) # 让该线程休眠1s def download(self, url): res = requests.get(url) res.encoding = &#x27;utf-8&#x27; text = res.text self.get_logger().info(f&quot;&#123;url&#125;,&#123;len(text)&#125;&quot;)def main(): rclpy.init() node = Novel_sub_Node(&quot;novel_sub&quot;) node.download(&quot;http://0.0.0.0:8000/novel1.txt&quot;) rclpy.spin(node) rclpy.shutdown() 学习收获： 认识了python中可以获取文字并朗读的库”espeakng”，使用”espeakng.Speaker()”可以创建一个espeakng实例。 学会创建订阅者和线程。","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"Topic_communication","slug":"Topic-communication","permalink":"http://example.com/tags/Topic-communication/"}]},{"title":"ros_功能包与工作空间","date":"2025-09-18T16:00:00.000Z","path":"2025/09/19/ros2/基础/ros_功能包与工作空间/","text":"ros_功能包与工作空间关于功能包💖基本流程：命令行创建功能包-&gt;在功能包中创建节点-&gt;在set.up文件中进行配置-&gt;在xml文件中添加依赖信息（但是如果创建功能包时添加了–dependencies就不需要这步）-&gt;colcon build进行构建-&gt;source install&#x2F;setup.bash-&gt;“ros2 run 包名 文件名”运行文件 使用”ros2 pkg create demo_python_pkg –build-type ament_python –license Apache-2.0”可以创建Python功能包，如果不指定build-type，默认为C++类型功能包。【有时候还会有–dependencies等选项】 可以在第二级demo_python_pkg目录下新建节点文件。 在功能包中注册节点。[即在setup.py文件中添加节点函数在那一层] 打开功能包中的xml文件添加依赖信息。[添加“rclpy”] “colcon build”:功能包的构建。[支持软链接，会把原来的包复制一份，然后执行复制的那份，即在install里面的python3.12&#x2F;site-packages中最里面那个python_node.py] [注]：colcon build一般在工作空间的根目录下进行，可以使用“colcon build-packages-select 包名”对特定的包进行构建。 “source install&#x2F;setup.bash”：生成环境变量。[setup.bash脚本用于修改环境变量] [补]:”ros2 功能包名 节点名”：运行节点 export PYTHONPATH&#x3D;新位置:$PYTHONPATH”:临时修改参数的环境变量。[使用6就可以不用这个方法] 修改环境变量的几种方法： 手动修改，即使用第7点 自动修改，即使用第6点 如果希望节点能以”ros2 run 包名 节点名”的形式运行，创建类的时候需要对rclcpp&#x2F;rclpy中的Node进行继承。 【补充】： python节点文件的配置(setup.py文件里)：结构大致为 ‘节点名 &#x3D; 包名.节点名:main’； c++节点文件的配置 关于C++和Python继承Node后，在main函数中的代码主要框架： C++： 1234567int main(int argc, char* argv)&#123; rclcpp::init(argc,argv); ... rclcpp::spin(创建的节点); rclcpp::shutdown(); return 0;&#125; Python： 12345def main: rclpy.init() ... rclpy.spin(节点) rclpy.shutdown() 关于工作空间 关于工作空间下常见的文件夹及其功能： src：代码空间，一般colcon build会将其下资源拷贝到install目录中，ros2 run时会在install目录下找到对应节点文件并运行。 install：安装空间 build：编译空间 log：日志空间 创建工作空间、自动安装依赖、编译工作空间和设置环境变量的指令： ![1728ba8cfdfb8a541b6b44df1cac34a1_720](N:&#x2F;qq_massage&#x2F;Tencent Files&#x2F;2454428604&#x2F;nt_qq&#x2F;nt_data&#x2F;Pic&#x2F;2025-09&#x2F;Thumb&#x2F;1728ba8cfdfb8a541b6b44df1cac34a1_720.jpg) 关于echo “source&#x2F;dev_ws&#x2F;install&#x2F;local_setup.sh” &gt;&gt;&#x2F;.bashrc 是将source~&#x2F;dev_ws&#x2F;install&#x2F;local_setup.sh写进配置文件.bashrc中，这样每次启动新终端时就会执行该配置，方便系统找到工作空间的位置。 “source install&#x2F;local_setup.sh”——&gt;”source install&#x2F;setup.bash”。 关于C++功能包：里面核心为CMakeLists.txt和package.xml两个配置文件。【对于C++文件需要将源码编译成可执行文件】 关于python功能包：里面核心为setup.py、setup.cfg和package.xml三个配置文件。【python是解析型语言】","categories":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/categories/ROS2/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"http://example.com/tags/ROS2/"},{"name":"foundation","slug":"foundation","permalink":"http://example.com/tags/foundation/"}]},{"title":"基本格式","date":"2025-09-18T08:28:11.787Z","path":"2025/09/18/基础相关/format/","text":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]},{"title":"实现Ubuntu与主机之间复制粘贴","date":"2025-09-18T08:02:00.000Z","path":"2025/09/18/记录杂七杂八小问题/实现Ubuntu与主机之间复制粘贴/","text":"方法一：虚拟机顶部工具栏点击”虚拟机设置”-&gt;”选项”-&gt;”客户机隔离”勾选，再次启动Ubuntu。 方法二：使用Ubuntu命令 在终端中依次运行： 123sudo su- //进入管理员模式sudo apt-get install open-vm-tools open-vm-tools-desktop //安装命令vmware-user //开启服务 最后，重启虚拟机就可以实现跨平台复制粘贴。 方法三：（永久开启该服务） 编写service配置文件 1234567891011# /etc/systemd/system/vmware-user.service [Unit] Description=开机启动一次vmware-user After=network.target [Service] Type=oneshot ExecStart=vmware-user [Install] WantedBy=multi-user.target 重新加载systemd配置 1systemctl daemon-reload 设置开机自启动 1systemctl enable vmware-user 重启虚拟机后基本成功","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"Ubuntu 跨操作系统复制","slug":"Ubuntu-跨操作系统复制","permalink":"http://example.com/tags/Ubuntu-%E8%B7%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E5%88%B6/"}]},{"title":"Hello Hexo","date":"2025-09-18T08:02:00.000Z","path":"2025/09/18/基础相关/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Typora的基础使用方法","date":"2025-09-18T07:39:00.000Z","path":"2025/09/18/基础相关/Typora_use/","text":"注：在文件最前面输入”[“TOC”]”，自动生成可跳转的文件目录 [TOC] 一.关于标题这是二级标题笔记：关于快捷键【但我的电脑不知道为啥用不了】 1.Ctrl+数字1-6对应将选中文本调节至对应级别的标题。 2.Ctrl+0可以快速将选中的文本调成普通文本。 3.Ctrl+加号&#x2F;减号对标题级别进行调整。 4.“#”数量控制字体级别，注意”#”与标题间有一个空格。 二.关于换行1.“Shift”+“Enter”可以进行比”Shift”更小的换行。 2.“分割线”：“—”按回车或者”***”按回车。 三.文字显示1.关于字体（1）粗体：用一对双星号包裹 e.g：这是粗体 （2）剔除线：用一对双飘号包裹 e.g:这是剔除线 （3）下划线：用一对u标签(html)包裹 e.g:这是下划线 （4）斜体：用一对单星号包裹 e.g:这是斜体 （5）高亮：用一对双等号包裹 e.g：&#x3D;&#x3D;这是高亮&#x3D;&#x3D; 快捷键：(按双数次取消效果) 加粗：Ctrl+B删除线：Shift+Alt+5下划线：Ctrl+u斜体：Ctrl+i 注：反斜杠+星：解决星号不显示的问题 * 2.上下标(1)一对”^”：表示上标。 x^2^ (2)一对”“：表示下标。 H2~O 四.列表1.无序列表（1）同级序号 ctrl+Shift+”]”：进入序列，两次回车退出序列。 （2）子集序列:Ctrl+”]”：列表右缩进。 这是一级序列 这是二级序列 又变一级 2.有序列表（1）同级序号 ctrl+Shift+”[“：进入序列，两次回车退出序列。 (2) 子集序列：子集序列:Ctrl+”]”：列表右缩进。 3.任务列表 :无序列表符+”[ ]” 五.区块显示 :”英文箭头加回车”。 六.代码显示1.行内代码 int a =2;:用一对“&#96;”包裹。 2.代码块：Ctrl+Shift+K 123int a = 2;int b =3; 1#include &lt;iostream&gt; 七.链接哔哩哔哩：Ctrl+K [一.关于标题](# 一.关于标题)：关于文件内标题跳转，前面括号写显示内容，后面括号写入跳转标题(记得加上对应格式)；跳转的时候Ctrl+点击。 八.脚注文字^1 ：“[”+”^”想要脚注的文字+”]” 上面的实现：“[”+”^”想要脚注的文字+”]”:解释说明。 ​ 注意：上下想要脚注的文字的文字需要一致才能有脚注； ​ 冒号要用英文格式的； ​ “&lt;”br”&gt;”：可以实现回车。 九.图片插入![不显示只给写文件的人提醒的一段文字](图片路径 “图片标题”) 还可以拖拽进行添加图片 十.表格快捷键：Ctrl+T id name score 23 张三 99 3 李四 100 十一.表情符号:happy: 、:cry: 两个冒号间加对应英文；（win+. ：可以快速打开表情面板） 十二.数学公式输入$$x^2+(y+1)^2&#x3D;5$$","categories":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/categories/Typora/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"},{"name":"basic-Usage","slug":"basic-Usage","permalink":"http://example.com/tags/basic-Usage/"}]}]